(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Puf = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}],3:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule KeyEscapeUtils
 * 
 */

'use strict';

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils = {
  escape: escape,
  unescape: unescape
};

module.exports = KeyEscapeUtils;
},{}],4:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule PooledClass
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4, a5);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4, a5);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler,
  fiveArgumentPooler: fiveArgumentPooler
};

module.exports = PooledClass;
}).call(this,require('_process'))

},{"./reactProdInvariant":25,"_process":1,"fbjs/lib/invariant":29}],5:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule React
 */

'use strict';

var _assign = require('object-assign');

var ReactChildren = require('./ReactChildren');
var ReactComponent = require('./ReactComponent');
var ReactPureComponent = require('./ReactPureComponent');
var ReactClass = require('./ReactClass');
var ReactDOMFactories = require('./ReactDOMFactories');
var ReactElement = require('./ReactElement');
var ReactPropTypes = require('./ReactPropTypes');
var ReactVersion = require('./ReactVersion');

var onlyChild = require('./onlyChild');
var warning = require('fbjs/lib/warning');

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if (process.env.NODE_ENV !== 'production') {
  var ReactElementValidator = require('./ReactElementValidator');
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var __spread = _assign;

if (process.env.NODE_ENV !== 'production') {
  var warned = false;
  __spread = function () {
    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
    warned = true;
    return _assign.apply(null, arguments);
  };
}

var React = {

  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactComponent,
  PureComponent: ReactPureComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: ReactClass.createClass,
  createFactory: createFactory,
  createMixin: function (mixin) {
    // Currently a noop. Will be used to validate and trace mixins.
    return mixin;
  },

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Deprecated hook for JSX spread, don't use this for anything.
  __spread: __spread
};

module.exports = React;
}).call(this,require('_process'))

},{"./ReactChildren":6,"./ReactClass":7,"./ReactComponent":8,"./ReactDOMFactories":11,"./ReactElement":12,"./ReactElementValidator":13,"./ReactPropTypes":17,"./ReactPureComponent":19,"./ReactVersion":20,"./onlyChild":24,"_process":1,"fbjs/lib/warning":32,"object-assign":33}],6:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactChildren
 */

'use strict';

var PooledClass = require('./PooledClass');
var ReactElement = require('./ReactElement');

var emptyFunction = require('fbjs/lib/emptyFunction');
var traverseAllChildren = require('./traverseAllChildren');

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func;
  var context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result;
  var keyPrefix = bookKeeping.keyPrefix;
  var func = bookKeeping.func;
  var context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement.isValidElement(mappedChild)) {
      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

module.exports = ReactChildren;
},{"./PooledClass":4,"./ReactElement":12,"./traverseAllChildren":26,"fbjs/lib/emptyFunction":27}],7:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactClass
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var ReactComponent = require('./ReactComponent');
var ReactElement = require('./ReactElement');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var keyMirror = require('fbjs/lib/keyMirror');
var keyOf = require('fbjs/lib/keyOf');
var warning = require('fbjs/lib/warning');

var MIXINS_KEY = keyOf({ mixins: null });

/**
 * Policies that describe methods in `ReactClassInterface`.
 */
var SpecPolicy = keyMirror({
  /**
   * These methods may be defined only once by the class specification or mixin.
   */
  DEFINE_ONCE: null,
  /**
   * These methods may be defined by both the class specification and mixins.
   * Subsequent definitions will be chained. These methods must return void.
   */
  DEFINE_MANY: null,
  /**
   * These methods are overriding the base class.
   */
  OVERRIDE_BASE: null,
  /**
   * These methods are similar to DEFINE_MANY, except we assume they return
   * objects. We try to merge the keys of the return values of all the mixed in
   * functions. If there is a key conflict we throw.
   */
  DEFINE_MANY_MERGED: null
});

var injectedMixins = [];

/**
 * Composite components are higher-level components that compose other composite
 * or host components.
 *
 * To create a new type of `ReactClass`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactClassInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will be available on the prototype.
 *
 * @interface ReactClassInterface
 * @internal
 */
var ReactClassInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: SpecPolicy.DEFINE_MANY,

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: SpecPolicy.DEFINE_MANY,

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: SpecPolicy.DEFINE_MANY,

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * @return {object}
   * @optional
   */
  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @nosideeffects
   * @required
   */
  render: SpecPolicy.DEFINE_ONCE,

  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: SpecPolicy.DEFINE_MANY,

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: SpecPolicy.DEFINE_MANY,

  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: SpecPolicy.OVERRIDE_BASE

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function (Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function (Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function (Constructor, childContextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
    }
    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
  },
  contextTypes: function (Constructor, contextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
    }
    Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function (Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function (Constructor, propTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
    }
    Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
  },
  statics: function (Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  },
  autobind: function () {} };

// noop
function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      // use a warning instead of an invariant so components
      // don't show up in prod but only in __DEV__
      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
    }
  }
}

function validateMethodOverride(isAlreadyDefined, name) {
  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (isAlreadyDefined) {
    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
  }
}

/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building React classes.
 */
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    if (process.env.NODE_ENV !== 'production') {
      var typeofSpec = typeof spec;
      var isMixinValid = typeofSpec === 'object' && spec !== null;

      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
    }

    return;
  }

  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;

  var proto = Constructor.prototype;
  var autoBindPairs = proto.__reactAutoBindPairs;

  // By handling mixins before any other properties, we ensure the same
  // chaining order is applied to methods with DEFINE_MANY policy, whether
  // mixins are listed before or after these methods in the spec.
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    if (name === MIXINS_KEY) {
      // We have already handled mixins in a special case above.
      continue;
    }

    var property = spec[name];
    var isAlreadyDefined = proto.hasOwnProperty(name);
    validateMethodOverride(isAlreadyDefined, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactClass methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      var isFunction = typeof property === 'function';
      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

      if (shouldAutoBind) {
        autoBindPairs.push(name, property);
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactClassInterface[name];

          // These cases should already be caught by validateMethodOverride.
          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if (process.env.NODE_ENV !== 'production') {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isReserved = name in RESERVED_SPEC_KEYS;
    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;

    var isInherited = name in Constructor;
    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
    Constructor[name] = property;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeIntoWithNoDuplicateKeys(one, two) {
  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;

  for (var key in two) {
    if (two.hasOwnProperty(key)) {
      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
      one[key] = two[key];
    }
  }
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    var c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    return c;
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * Binds a method to the component.
 *
 * @param {object} component Component whose method is going to be bound.
 * @param {function} method Method to be bound.
 * @return {function} The bound method.
 */
function bindAutoBindMethod(component, method) {
  var boundMethod = method.bind(component);
  if (process.env.NODE_ENV !== 'production') {
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = null;
    var componentName = component.constructor.displayName;
    var _bind = boundMethod.bind;
    boundMethod.bind = function (newThis) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // User is trying to bind() an autobound method; we effectively will
      // ignore the value of "this" that the user is trying to use, so
      // let's warn.
      if (newThis !== component && newThis !== null) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
      } else if (!args.length) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
        return boundMethod;
      }
      var reboundMethod = _bind.apply(boundMethod, arguments);
      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      return reboundMethod;
    };
  }
  return boundMethod;
}

/**
 * Binds all auto-bound methods in a component.
 *
 * @param {object} component Component whose method is going to be bound.
 */
function bindAutoBindMethods(component) {
  var pairs = component.__reactAutoBindPairs;
  for (var i = 0; i < pairs.length; i += 2) {
    var autoBindKey = pairs[i];
    var method = pairs[i + 1];
    component[autoBindKey] = bindAutoBindMethod(component, method);
  }
}

/**
 * Add more to the ReactClass base class. These are all legacy features and
 * therefore not already part of the modern ReactComponent.
 */
var ReactClassMixin = {

  /**
   * TODO: This will be deprecated because state should always keep a consistent
   * type signature and the only use case for this, is to avoid that.
   */
  replaceState: function (newState, callback) {
    this.updater.enqueueReplaceState(this, newState);
    if (callback) {
      this.updater.enqueueCallback(this, callback, 'replaceState');
    }
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function () {
    return this.updater.isMounted(this);
  }
};

var ReactClassComponent = function () {};
_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

/**
 * Module for creating composite components.
 *
 * @class ReactClass
 */
var ReactClass = {

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function (spec) {
    var Constructor = function (props, context, updater) {
      // This constructor gets overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
      }

      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if (process.env.NODE_ENV !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (initialState === undefined && this.getInitialState._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;

      this.state = initialState;
    };
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if (process.env.NODE_ENV !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  },

  injection: {
    injectMixin: function (mixin) {
      injectedMixins.push(mixin);
    }
  }

};

module.exports = ReactClass;
}).call(this,require('_process'))

},{"./ReactComponent":8,"./ReactElement":12,"./ReactNoopUpdateQueue":14,"./ReactPropTypeLocationNames":15,"./ReactPropTypeLocations":16,"./reactProdInvariant":25,"_process":1,"fbjs/lib/emptyObject":28,"fbjs/lib/invariant":29,"fbjs/lib/keyMirror":30,"fbjs/lib/keyOf":31,"fbjs/lib/warning":32,"object-assign":33}],8:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponent
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var canDefineProperty = require('./canDefineProperty');
var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'forceUpdate');
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if (process.env.NODE_ENV !== 'production') {
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    if (canDefineProperty) {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function () {
          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

module.exports = ReactComponent;
}).call(this,require('_process'))

},{"./ReactNoopUpdateQueue":14,"./canDefineProperty":21,"./reactProdInvariant":25,"_process":1,"fbjs/lib/emptyObject":28,"fbjs/lib/invariant":29,"fbjs/lib/warning":32}],9:[function(require,module,exports){
(function (process){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentTreeHook
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('./ReactCurrentOwner');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function isNative(fn) {
  // Based on isNative() from Lodash
  var funcToString = Function.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString
  // Take an example native function source for comparison
  .call(hasOwnProperty)
  // Strip regex characters so we can use it for regex
  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  // Remove hasOwnProperty from the template to make it generic
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  try {
    var source = funcToString.call(fn);
    return reIsNative.test(source);
  } catch (err) {
    return false;
  }
}

var canUseCollections =
// Array.from
typeof Array.from === 'function' &&
// Map
typeof Map === 'function' && isNative(Map) &&
// Map.prototype.keys
Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
// Set
typeof Set === 'function' && isNative(Set) &&
// Set.prototype.keys
Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

var itemMap;
var rootIDSet;

var itemByKey;
var rootByKey;

if (canUseCollections) {
  itemMap = new Map();
  rootIDSet = new Set();
} else {
  itemByKey = {};
  rootByKey = {};
}

var unmountedIDs = [];

// Use non-numeric keys to prevent V8 performance issues:
// https://github.com/facebook/react/pull/7232
function getKeyFromID(id) {
  return '.' + id;
}
function getIDFromKey(key) {
  return parseInt(key.substr(1), 10);
}

function get(id) {
  if (canUseCollections) {
    return itemMap.get(id);
  } else {
    var key = getKeyFromID(id);
    return itemByKey[key];
  }
}

function remove(id) {
  if (canUseCollections) {
    itemMap['delete'](id);
  } else {
    var key = getKeyFromID(id);
    delete itemByKey[key];
  }
}

function create(id, element, parentID) {
  var item = {
    element: element,
    parentID: parentID,
    text: null,
    childIDs: [],
    isMounted: false,
    updateCount: 0
  };

  if (canUseCollections) {
    itemMap.set(id, item);
  } else {
    var key = getKeyFromID(id);
    itemByKey[key] = item;
  }
}

function addRoot(id) {
  if (canUseCollections) {
    rootIDSet.add(id);
  } else {
    var key = getKeyFromID(id);
    rootByKey[key] = true;
  }
}

function removeRoot(id) {
  if (canUseCollections) {
    rootIDSet['delete'](id);
  } else {
    var key = getKeyFromID(id);
    delete rootByKey[key];
  }
}

function getRegisteredIDs() {
  if (canUseCollections) {
    return Array.from(itemMap.keys());
  } else {
    return Object.keys(itemByKey).map(getIDFromKey);
  }
}

function getRootIDs() {
  if (canUseCollections) {
    return Array.from(rootIDSet.keys());
  } else {
    return Object.keys(rootByKey).map(getIDFromKey);
  }
}

function purgeDeep(id) {
  var item = get(id);
  if (item) {
    var childIDs = item.childIDs;

    remove(id);
    childIDs.forEach(purgeDeep);
  }
}

function describeComponentFrame(name, source, ownerName) {
  return '\n    in ' + name + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
}

function getDisplayName(element) {
  if (element == null) {
    return '#empty';
  } else if (typeof element === 'string' || typeof element === 'number') {
    return '#text';
  } else if (typeof element.type === 'string') {
    return element.type;
  } else {
    return element.type.displayName || element.type.name || 'Unknown';
  }
}

function describeID(id) {
  var name = ReactComponentTreeHook.getDisplayName(id);
  var element = ReactComponentTreeHook.getElement(id);
  var ownerID = ReactComponentTreeHook.getOwnerID(id);
  var ownerName;
  if (ownerID) {
    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
  }
  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
  return describeComponentFrame(name, element && element._source, ownerName);
}

var ReactComponentTreeHook = {
  onSetChildren: function (id, nextChildIDs) {
    var item = get(id);
    item.childIDs = nextChildIDs;

    for (var i = 0; i < nextChildIDs.length; i++) {
      var nextChildID = nextChildIDs[i];
      var nextChild = get(nextChildID);
      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
      if (nextChild.parentID == null) {
        nextChild.parentID = id;
        // TODO: This shouldn't be necessary but mounting a new root during in
        // componentWillMount currently causes not-yet-mounted components to
        // be purged from our tree data so their parent ID is missing.
      }
      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
    }
  },
  onBeforeMountComponent: function (id, element, parentID) {
    create(id, element, parentID);
  },
  onBeforeUpdateComponent: function (id, element) {
    var item = get(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.element = element;
  },
  onMountComponent: function (id) {
    var item = get(id);
    item.isMounted = true;
    var isRoot = item.parentID === 0;
    if (isRoot) {
      addRoot(id);
    }
  },
  onUpdateComponent: function (id) {
    var item = get(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.updateCount++;
  },
  onUnmountComponent: function (id) {
    var item = get(id);
    if (item) {
      // We need to check if it exists.
      // `item` might not exist if it is inside an error boundary, and a sibling
      // error boundary child threw while mounting. Then this instance never
      // got a chance to mount, but it still gets an unmounting event during
      // the error boundary cleanup.
      item.isMounted = false;
      var isRoot = item.parentID === 0;
      if (isRoot) {
        removeRoot(id);
      }
    }
    unmountedIDs.push(id);
  },
  purgeUnmountedComponents: function () {
    if (ReactComponentTreeHook._preventPurging) {
      // Should only be used for testing.
      return;
    }

    for (var i = 0; i < unmountedIDs.length; i++) {
      var id = unmountedIDs[i];
      purgeDeep(id);
    }
    unmountedIDs.length = 0;
  },
  isMounted: function (id) {
    var item = get(id);
    return item ? item.isMounted : false;
  },
  getCurrentStackAddendum: function (topElement) {
    var info = '';
    if (topElement) {
      var type = topElement.type;
      var name = typeof type === 'function' ? type.displayName || type.name : type;
      var owner = topElement._owner;
      info += describeComponentFrame(name || 'Unknown', topElement._source, owner && owner.getName());
    }

    var currentOwner = ReactCurrentOwner.current;
    var id = currentOwner && currentOwner._debugID;

    info += ReactComponentTreeHook.getStackAddendumByID(id);
    return info;
  },
  getStackAddendumByID: function (id) {
    var info = '';
    while (id) {
      info += describeID(id);
      id = ReactComponentTreeHook.getParentID(id);
    }
    return info;
  },
  getChildIDs: function (id) {
    var item = get(id);
    return item ? item.childIDs : [];
  },
  getDisplayName: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element) {
      return null;
    }
    return getDisplayName(element);
  },
  getElement: function (id) {
    var item = get(id);
    return item ? item.element : null;
  },
  getOwnerID: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element || !element._owner) {
      return null;
    }
    return element._owner._debugID;
  },
  getParentID: function (id) {
    var item = get(id);
    return item ? item.parentID : null;
  },
  getSource: function (id) {
    var item = get(id);
    var element = item ? item.element : null;
    var source = element != null ? element._source : null;
    return source;
  },
  getText: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (typeof element === 'string') {
      return element;
    } else if (typeof element === 'number') {
      return '' + element;
    } else {
      return null;
    }
  },
  getUpdateCount: function (id) {
    var item = get(id);
    return item ? item.updateCount : 0;
  },


  getRegisteredIDs: getRegisteredIDs,

  getRootIDs: getRootIDs
};

module.exports = ReactComponentTreeHook;
}).call(this,require('_process'))

},{"./ReactCurrentOwner":10,"./reactProdInvariant":25,"_process":1,"fbjs/lib/invariant":29,"fbjs/lib/warning":32}],10:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactCurrentOwner
 */

'use strict';

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */

var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;
},{}],11:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOMFactories
 */

'use strict';

var ReactElement = require('./ReactElement');

/**
 * Create a factory that creates HTML tag elements.
 *
 * @private
 */
var createDOMFactory = ReactElement.createFactory;
if (process.env.NODE_ENV !== 'production') {
  var ReactElementValidator = require('./ReactElementValidator');
  createDOMFactory = ReactElementValidator.createFactory;
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOMFactories = {
  a: createDOMFactory('a'),
  abbr: createDOMFactory('abbr'),
  address: createDOMFactory('address'),
  area: createDOMFactory('area'),
  article: createDOMFactory('article'),
  aside: createDOMFactory('aside'),
  audio: createDOMFactory('audio'),
  b: createDOMFactory('b'),
  base: createDOMFactory('base'),
  bdi: createDOMFactory('bdi'),
  bdo: createDOMFactory('bdo'),
  big: createDOMFactory('big'),
  blockquote: createDOMFactory('blockquote'),
  body: createDOMFactory('body'),
  br: createDOMFactory('br'),
  button: createDOMFactory('button'),
  canvas: createDOMFactory('canvas'),
  caption: createDOMFactory('caption'),
  cite: createDOMFactory('cite'),
  code: createDOMFactory('code'),
  col: createDOMFactory('col'),
  colgroup: createDOMFactory('colgroup'),
  data: createDOMFactory('data'),
  datalist: createDOMFactory('datalist'),
  dd: createDOMFactory('dd'),
  del: createDOMFactory('del'),
  details: createDOMFactory('details'),
  dfn: createDOMFactory('dfn'),
  dialog: createDOMFactory('dialog'),
  div: createDOMFactory('div'),
  dl: createDOMFactory('dl'),
  dt: createDOMFactory('dt'),
  em: createDOMFactory('em'),
  embed: createDOMFactory('embed'),
  fieldset: createDOMFactory('fieldset'),
  figcaption: createDOMFactory('figcaption'),
  figure: createDOMFactory('figure'),
  footer: createDOMFactory('footer'),
  form: createDOMFactory('form'),
  h1: createDOMFactory('h1'),
  h2: createDOMFactory('h2'),
  h3: createDOMFactory('h3'),
  h4: createDOMFactory('h4'),
  h5: createDOMFactory('h5'),
  h6: createDOMFactory('h6'),
  head: createDOMFactory('head'),
  header: createDOMFactory('header'),
  hgroup: createDOMFactory('hgroup'),
  hr: createDOMFactory('hr'),
  html: createDOMFactory('html'),
  i: createDOMFactory('i'),
  iframe: createDOMFactory('iframe'),
  img: createDOMFactory('img'),
  input: createDOMFactory('input'),
  ins: createDOMFactory('ins'),
  kbd: createDOMFactory('kbd'),
  keygen: createDOMFactory('keygen'),
  label: createDOMFactory('label'),
  legend: createDOMFactory('legend'),
  li: createDOMFactory('li'),
  link: createDOMFactory('link'),
  main: createDOMFactory('main'),
  map: createDOMFactory('map'),
  mark: createDOMFactory('mark'),
  menu: createDOMFactory('menu'),
  menuitem: createDOMFactory('menuitem'),
  meta: createDOMFactory('meta'),
  meter: createDOMFactory('meter'),
  nav: createDOMFactory('nav'),
  noscript: createDOMFactory('noscript'),
  object: createDOMFactory('object'),
  ol: createDOMFactory('ol'),
  optgroup: createDOMFactory('optgroup'),
  option: createDOMFactory('option'),
  output: createDOMFactory('output'),
  p: createDOMFactory('p'),
  param: createDOMFactory('param'),
  picture: createDOMFactory('picture'),
  pre: createDOMFactory('pre'),
  progress: createDOMFactory('progress'),
  q: createDOMFactory('q'),
  rp: createDOMFactory('rp'),
  rt: createDOMFactory('rt'),
  ruby: createDOMFactory('ruby'),
  s: createDOMFactory('s'),
  samp: createDOMFactory('samp'),
  script: createDOMFactory('script'),
  section: createDOMFactory('section'),
  select: createDOMFactory('select'),
  small: createDOMFactory('small'),
  source: createDOMFactory('source'),
  span: createDOMFactory('span'),
  strong: createDOMFactory('strong'),
  style: createDOMFactory('style'),
  sub: createDOMFactory('sub'),
  summary: createDOMFactory('summary'),
  sup: createDOMFactory('sup'),
  table: createDOMFactory('table'),
  tbody: createDOMFactory('tbody'),
  td: createDOMFactory('td'),
  textarea: createDOMFactory('textarea'),
  tfoot: createDOMFactory('tfoot'),
  th: createDOMFactory('th'),
  thead: createDOMFactory('thead'),
  time: createDOMFactory('time'),
  title: createDOMFactory('title'),
  tr: createDOMFactory('tr'),
  track: createDOMFactory('track'),
  u: createDOMFactory('u'),
  ul: createDOMFactory('ul'),
  'var': createDOMFactory('var'),
  video: createDOMFactory('video'),
  wbr: createDOMFactory('wbr'),

  // SVG
  circle: createDOMFactory('circle'),
  clipPath: createDOMFactory('clipPath'),
  defs: createDOMFactory('defs'),
  ellipse: createDOMFactory('ellipse'),
  g: createDOMFactory('g'),
  image: createDOMFactory('image'),
  line: createDOMFactory('line'),
  linearGradient: createDOMFactory('linearGradient'),
  mask: createDOMFactory('mask'),
  path: createDOMFactory('path'),
  pattern: createDOMFactory('pattern'),
  polygon: createDOMFactory('polygon'),
  polyline: createDOMFactory('polyline'),
  radialGradient: createDOMFactory('radialGradient'),
  rect: createDOMFactory('rect'),
  stop: createDOMFactory('stop'),
  svg: createDOMFactory('svg'),
  text: createDOMFactory('text'),
  tspan: createDOMFactory('tspan')
};

module.exports = ReactDOMFactories;
}).call(this,require('_process'))

},{"./ReactElement":12,"./ReactElementValidator":13,"_process":1}],12:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElement
 */

'use strict';

var _assign = require('object-assign');

var ReactCurrentOwner = require('./ReactCurrentOwner');

var warning = require('fbjs/lib/warning');
var canDefineProperty = require('./canDefineProperty');
var hasOwnProperty = Object.prototype.hasOwnProperty;

// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown, specialPropRefWarningShown;

function hasValidRef(config) {
  if (process.env.NODE_ENV !== 'production') {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  if (process.env.NODE_ENV !== 'production') {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  if (process.env.NODE_ENV !== 'production') {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};
    var shadowChildren = Array.isArray(props.children) ? props.children.slice(0) : props.children;

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      Object.defineProperty(element, '_shadowChildren', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: shadowChildren
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._shadowChildren = shadowChildren;
      element._source = source;
    }
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
 */
ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if (process.env.NODE_ENV !== 'production') {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

/**
 * Return a function that produces ReactElements of a given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
 */
ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
 */
ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
};

/**
 * Verifies the object is a ReactElement.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

ReactElement.REACT_ELEMENT_TYPE = REACT_ELEMENT_TYPE;

module.exports = ReactElement;
}).call(this,require('_process'))

},{"./ReactCurrentOwner":10,"./canDefineProperty":21,"_process":1,"fbjs/lib/warning":32,"object-assign":33}],13:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactElementValidator
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */

'use strict';

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactComponentTreeHook = require('./ReactComponentTreeHook');
var ReactElement = require('./ReactElement');
var ReactPropTypeLocations = require('./ReactPropTypeLocations');

var checkReactTypeSpec = require('./checkReactTypeSpec');

var canDefineProperty = require('./canDefineProperty');
var getIteratorFn = require('./getIteratorFn');
var warning = require('fbjs/lib/warning');

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = ' Check the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (memoizer[currentComponentErrorInfo]) {
    return;
  }
  memoizer[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }

  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkReactTypeSpec(componentClass.propTypes, element.props, ReactPropTypeLocations.prop, name, element, null);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}

var ReactElementValidator = {

  createElement: function (type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    if (!validType) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;
    }

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function (type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if (process.env.NODE_ENV !== 'production') {
      if (canDefineProperty) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }

    return validatedFactory;
  },

  cloneElement: function (element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }

};

module.exports = ReactElementValidator;
}).call(this,require('_process'))

},{"./ReactComponentTreeHook":9,"./ReactCurrentOwner":10,"./ReactElement":12,"./ReactPropTypeLocations":16,"./canDefineProperty":21,"./checkReactTypeSpec":22,"./getIteratorFn":23,"_process":1,"fbjs/lib/warning":32}],14:[function(require,module,exports){
(function (process){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactNoopUpdateQueue
 */

'use strict';

var warning = require('fbjs/lib/warning');

function warnNoop(publicInstance, callerName) {
  if (process.env.NODE_ENV !== 'production') {
    var constructor = publicInstance.constructor;
    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    warnNoop(publicInstance, 'setState');
  }
};

module.exports = ReactNoopUpdateQueue;
}).call(this,require('_process'))

},{"_process":1,"fbjs/lib/warning":32}],15:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocationNames
 */

'use strict';

var ReactPropTypeLocationNames = {};

if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
}).call(this,require('_process'))

},{"_process":1}],16:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypeLocations
 */

'use strict';

var keyMirror = require('fbjs/lib/keyMirror');

var ReactPropTypeLocations = keyMirror({
  prop: null,
  context: null,
  childContext: null
});

module.exports = ReactPropTypeLocations;
},{"fbjs/lib/keyMirror":30}],17:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypes
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactPropTypesSecret = require('./ReactPropTypesSecret');

var emptyFunction = require('fbjs/lib/emptyFunction');
var getIteratorFn = require('./getIteratorFn');
var warning = require('fbjs/lib/warning');

/**
 * Collection of methods that allow declaration and validation of props that are
 * supplied to React components. Example usage:
 *
 *   var Props = require('ReactPropTypes');
 *   var MyArticle = React.createClass({
 *     propTypes: {
 *       // An optional string prop named "description".
 *       description: Props.string,
 *
 *       // A required enum prop named "category".
 *       category: Props.oneOf(['News','Photos']).isRequired,
 *
 *       // A prop named "dialog" that requires an instance of Dialog.
 *       dialog: Props.instanceOf(Dialog).isRequired
 *     },
 *     render: function() { ... }
 *   });
 *
 * A more formal specification of how these methods are used:
 *
 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
 *   decl := ReactPropTypes.{type}(.isRequired)?
 *
 * Each and every declaration produces a function with the same signature. This
 * allows the creation of custom validation functions. For example:
 *
 *  var MyLink = React.createClass({
 *    propTypes: {
 *      // An optional string or URI prop named "href".
 *      href: function(props, propName, componentName) {
 *        var propValue = props[propName];
 *        if (propValue != null && typeof propValue !== 'string' &&
 *            !(propValue instanceof URI)) {
 *          return new Error(
 *            'Expected a string or an URI for ' + propName + ' in ' +
 *            componentName
 *          );
 *        }
 *      }
 *    },
 *    render: function() {...}
 *  });
 *
 * @internal
 */

var ANONYMOUS = '<<anonymous>>';

var ReactPropTypes = {
  array: createPrimitiveTypeChecker('array'),
  bool: createPrimitiveTypeChecker('boolean'),
  func: createPrimitiveTypeChecker('function'),
  number: createPrimitiveTypeChecker('number'),
  object: createPrimitiveTypeChecker('object'),
  string: createPrimitiveTypeChecker('string'),
  symbol: createPrimitiveTypeChecker('symbol'),

  any: createAnyTypeChecker(),
  arrayOf: createArrayOfTypeChecker,
  element: createElementTypeChecker(),
  instanceOf: createInstanceTypeChecker,
  node: createNodeChecker(),
  objectOf: createObjectOfTypeChecker,
  oneOf: createEnumTypeChecker,
  oneOfType: createUnionTypeChecker,
  shape: createShapeTypeChecker
};

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
/*eslint-disable no-self-compare*/
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return x !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}
/*eslint-enable no-self-compare*/

/**
 * We use an Error-like object for backward compatibility as people may call
 * PropTypes directly and inspect their output. However we don't use real
 * Errors anymore. We don't inspect their stack anyway, and creating them
 * is prohibitively expensive if they are created too often, such as what
 * happens in oneOfType() for any type before the one that matched.
 */
function PropTypeError(message) {
  this.message = message;
  this.stack = '';
}
// Make `instanceof Error` still work for returned errors.
PropTypeError.prototype = Error.prototype;

function createChainableTypeChecker(validate) {
  if (process.env.NODE_ENV !== 'production') {
    var manualPropTypeCallCache = {};
  }
  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
    componentName = componentName || ANONYMOUS;
    propFullName = propFullName || propName;
    if (process.env.NODE_ENV !== 'production') {
      if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
        var cacheKey = componentName + ':' + propName;
        if (!manualPropTypeCallCache[cacheKey]) {
          process.env.NODE_ENV !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in the next major version. You may be ' + 'seeing this warning due to a third-party PropTypes library. ' + 'See https://fb.me/react-warning-dont-call-proptypes for details.', propFullName, componentName) : void 0;
          manualPropTypeCallCache[cacheKey] = true;
        }
      }
    }
    if (props[propName] == null) {
      var locationName = ReactPropTypeLocationNames[location];
      if (isRequired) {
        return new PropTypeError('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
      }
      return null;
    } else {
      return validate(props, propName, componentName, location, propFullName);
    }
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);

  return chainedCheckType;
}

function createPrimitiveTypeChecker(expectedType) {
  function validate(props, propName, componentName, location, propFullName, secret) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== expectedType) {
      var locationName = ReactPropTypeLocationNames[location];
      // `propValue` being instance of, say, date/regexp, pass the 'object'
      // check, but we can offer a more precise error message here rather than
      // 'of type `object`'.
      var preciseType = getPreciseType(propValue);

      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createAnyTypeChecker() {
  return createChainableTypeChecker(emptyFunction.thatReturns(null));
}

function createArrayOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    if (typeof typeChecker !== 'function') {
      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
    }
    var propValue = props[propName];
    if (!Array.isArray(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
    }
    for (var i = 0; i < propValue.length; i++) {
      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
      if (error instanceof Error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createElementTypeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    if (!ReactElement.isValidElement(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createInstanceTypeChecker(expectedClass) {
  function validate(props, propName, componentName, location, propFullName) {
    if (!(props[propName] instanceof expectedClass)) {
      var locationName = ReactPropTypeLocationNames[location];
      var expectedClassName = expectedClass.name || ANONYMOUS;
      var actualClassName = getClassName(props[propName]);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createEnumTypeChecker(expectedValues) {
  if (!Array.isArray(expectedValues)) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
    return emptyFunction.thatReturnsNull;
  }

  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    for (var i = 0; i < expectedValues.length; i++) {
      if (is(propValue, expectedValues[i])) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    var valuesString = JSON.stringify(expectedValues);
    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
  }
  return createChainableTypeChecker(validate);
}

function createObjectOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    if (typeof typeChecker !== 'function') {
      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
    }
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
    }
    for (var key in propValue) {
      if (propValue.hasOwnProperty(key)) {
        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createUnionTypeChecker(arrayOfTypeCheckers) {
  if (!Array.isArray(arrayOfTypeCheckers)) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
    return emptyFunction.thatReturnsNull;
  }

  function validate(props, propName, componentName, location, propFullName) {
    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
  }
  return createChainableTypeChecker(validate);
}

function createNodeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!isNode(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createShapeTypeChecker(shapeTypes) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
    }
    for (var key in shapeTypes) {
      var checker = shapeTypes[key];
      if (!checker) {
        continue;
      }
      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
      if (error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function isNode(propValue) {
  switch (typeof propValue) {
    case 'number':
    case 'string':
    case 'undefined':
      return true;
    case 'boolean':
      return !propValue;
    case 'object':
      if (Array.isArray(propValue)) {
        return propValue.every(isNode);
      }
      if (propValue === null || ReactElement.isValidElement(propValue)) {
        return true;
      }

      var iteratorFn = getIteratorFn(propValue);
      if (iteratorFn) {
        var iterator = iteratorFn.call(propValue);
        var step;
        if (iteratorFn !== propValue.entries) {
          while (!(step = iterator.next()).done) {
            if (!isNode(step.value)) {
              return false;
            }
          }
        } else {
          // Iterator will provide entry [k,v] tuples rather than values.
          while (!(step = iterator.next()).done) {
            var entry = step.value;
            if (entry) {
              if (!isNode(entry[1])) {
                return false;
              }
            }
          }
        }
      } else {
        return false;
      }

      return true;
    default:
      return false;
  }
}

function isSymbol(propType, propValue) {
  // Native Symbol.
  if (propType === 'symbol') {
    return true;
  }

  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
  if (propValue['@@toStringTag'] === 'Symbol') {
    return true;
  }

  // Fallback for non-spec compliant Symbols which are polyfilled.
  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
    return true;
  }

  return false;
}

// Equivalent of `typeof` but with special handling for array and regexp.
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return 'array';
  }
  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return 'object';
  }
  if (isSymbol(propType, propValue)) {
    return 'symbol';
  }
  return propType;
}

// This handles more types than `getPropType`. Only used for error messages.
// See `createPrimitiveTypeChecker`.
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === 'object') {
    if (propValue instanceof Date) {
      return 'date';
    } else if (propValue instanceof RegExp) {
      return 'regexp';
    }
  }
  return propType;
}

// Returns class name of the object, if any.
function getClassName(propValue) {
  if (!propValue.constructor || !propValue.constructor.name) {
    return ANONYMOUS;
  }
  return propValue.constructor.name;
}

module.exports = ReactPropTypes;
}).call(this,require('_process'))

},{"./ReactElement":12,"./ReactPropTypeLocationNames":15,"./ReactPropTypesSecret":18,"./getIteratorFn":23,"_process":1,"fbjs/lib/emptyFunction":27,"fbjs/lib/warning":32}],18:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPropTypesSecret
 */

'use strict';

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;
},{}],19:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactPureComponent
 */

'use strict';

var _assign = require('object-assign');

var ReactComponent = require('./ReactComponent');
var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var emptyObject = require('fbjs/lib/emptyObject');

/**
 * Base class helpers for the updating state of a component.
 */
function ReactPureComponent(props, context, updater) {
  // Duplicated from ReactComponent.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = ReactComponent.prototype;
ReactPureComponent.prototype = new ComponentDummy();
ReactPureComponent.prototype.constructor = ReactPureComponent;
// Avoid an extra prototype jump for these methods.
_assign(ReactPureComponent.prototype, ReactComponent.prototype);
ReactPureComponent.prototype.isPureReactComponent = true;

module.exports = ReactPureComponent;
},{"./ReactComponent":8,"./ReactNoopUpdateQueue":14,"fbjs/lib/emptyObject":28,"object-assign":33}],20:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactVersion
 */

'use strict';

module.exports = '15.3.2';
},{}],21:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule canDefineProperty
 */

'use strict';

var canDefineProperty = false;
if (process.env.NODE_ENV !== 'production') {
  try {
    Object.defineProperty({}, 'x', { get: function () {} });
    canDefineProperty = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

module.exports = canDefineProperty;
}).call(this,require('_process'))

},{"_process":1}],22:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule checkReactTypeSpec
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactPropTypesSecret = require('./ReactPropTypesSecret');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = require('./ReactComponentTreeHook');
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if (process.env.NODE_ENV !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = require('./ReactComponentTreeHook');
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
}).call(this,require('_process'))

},{"./ReactComponentTreeHook":9,"./ReactPropTypeLocationNames":15,"./ReactPropTypesSecret":18,"./reactProdInvariant":25,"_process":1,"fbjs/lib/invariant":29,"fbjs/lib/warning":32}],23:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getIteratorFn
 * 
 */

'use strict';

/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;
},{}],24:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule onlyChild
 */
'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactElement = require('./ReactElement');

var invariant = require('fbjs/lib/invariant');

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
  return children;
}

module.exports = onlyChild;
}).call(this,require('_process'))

},{"./ReactElement":12,"./reactProdInvariant":25,"_process":1,"fbjs/lib/invariant":29}],25:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule reactProdInvariant
 * 
 */
'use strict';

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

function reactProdInvariant(code) {
  var argCount = arguments.length - 1;

  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }

  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

  throw error;
}

module.exports = reactProdInvariant;
},{}],26:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule traverseAllChildren
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('./ReactCurrentOwner');
var ReactElement = require('./ReactElement');

var getIteratorFn = require('./getIteratorFn');
var invariant = require('fbjs/lib/invariant');
var KeyEscapeUtils = require('./KeyEscapeUtils');
var warning = require('fbjs/lib/warning');

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if (process.env.NODE_ENV !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (process.env.NODE_ENV !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
      !false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
}).call(this,require('_process'))

},{"./KeyEscapeUtils":3,"./ReactCurrentOwner":10,"./ReactElement":12,"./getIteratorFn":23,"./reactProdInvariant":25,"_process":1,"fbjs/lib/invariant":29,"fbjs/lib/warning":32}],27:[function(require,module,exports){
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;
},{}],28:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
}).call(this,require('_process'))

},{"_process":1}],29:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

function invariant(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
}).call(this,require('_process'))

},{"_process":1}],30:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks static-only
 */

'use strict';

var invariant = require('./invariant');

/**
 * Constructs an enumeration with keys equal to their value.
 *
 * For example:
 *
 *   var COLORS = keyMirror({blue: null, red: null});
 *   var myColor = COLORS.blue;
 *   var isColorValid = !!COLORS[myColor];
 *
 * The last line could not be performed if the values of the generated enum were
 * not equal to their keys.
 *
 *   Input:  {key1: val1, key2: val2}
 *   Output: {key1: key1, key2: key2}
 *
 * @param {object} obj
 * @return {object}
 */
var keyMirror = function keyMirror(obj) {
  var ret = {};
  var key;
  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : void 0;
  for (key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = key;
  }
  return ret;
};

module.exports = keyMirror;
}).call(this,require('_process'))

},{"./invariant":29,"_process":1}],31:[function(require,module,exports){
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * Allows extraction of a minified key. Let's the build system minify keys
 * without losing the ability to dynamically use key strings as values
 * themselves. Pass in an object with a single key/val pair and it will return
 * you the string key of that single record. Suppose you want to grab the
 * value for a key 'className' inside of an object. Key/val minification may
 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
 * reuse those resolutions.
 */
var keyOf = function keyOf(oneKeyObj) {
  var key;
  for (key in oneKeyObj) {
    if (!oneKeyObj.hasOwnProperty(key)) {
      continue;
    }
    return key;
  }
  return null;
};

module.exports = keyOf;
},{}],32:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var emptyFunction = require('./emptyFunction');

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  (function () {
    var printWarning = function printWarning(format) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };

    warning = function warning(condition, format) {
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }

      if (format.indexOf('Failed Composite propType: ') === 0) {
        return; // Ignore CompositeComponent proptype check.
      }

      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        printWarning.apply(undefined, [format].concat(args));
      }
    };
  })();
}

module.exports = warning;
}).call(this,require('_process'))

},{"./emptyFunction":27,"_process":1}],33:[function(require,module,exports){
'use strict';
/* eslint-disable no-unused-vars */
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (e) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],34:[function(require,module,exports){
'use strict';

module.exports = require('./lib/React');

},{"./lib/React":5}],35:[function(require,module,exports){
'use strict';

module.exports = require('./src/Puf');

},{"./src/Puf":36}],36:[function(require,module,exports){
/**
 * React Puf Bundle
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/03/08
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 */
'use strict';

// components
// Elements

var _Alert = require('./components/Alert');

var _Alert2 = _interopRequireDefault(_Alert);

var _Button = require('./components/Button');

var _Button2 = _interopRequireDefault(_Button);

var _ToggleButton = require('./components/ToggleButton');

var _ToggleButton2 = _interopRequireDefault(_ToggleButton);

var _ButtonDropdown = require('./components/ButtonDropdown');

var _ButtonDropdown2 = _interopRequireDefault(_ButtonDropdown);

var _HiddenContent = require('./components/HiddenContent');

var _HiddenContent2 = _interopRequireDefault(_HiddenContent);

var _MainFrameSplitter = require('./components/MainFrameSplitter');

var _MainFrameSplitter2 = _interopRequireDefault(_MainFrameSplitter);

var _Modal = require('./components/Modal');

var _Panel = require('./components/Panel');

var _Checkbox = require('./components/Checkbox');

var _Checkbox2 = _interopRequireDefault(_Checkbox);

var _RadioGroup = require('./components/radio/RadioGroup');

var _RadioGroup2 = _interopRequireDefault(_RadioGroup);

var _Radio = require('./components/radio/Radio');

var _Radio2 = _interopRequireDefault(_Radio);

var _RadioDivider = require('./components/radio/RadioDivider');

var _RadioDivider2 = _interopRequireDefault(_RadioDivider);

var _Fieldset = require('./components/Fieldset');

var _Fieldset2 = _interopRequireDefault(_Fieldset);

var _FineUploader = require('./components/FineUploader');

var _FineUploader2 = _interopRequireDefault(_FineUploader);

var _TabStrip = require('./kendo/tabstrip/TabStrip');

var _TabStrip2 = _interopRequireDefault(_TabStrip);

var _Tabs = require('./kendo/tabstrip/Tabs');

var _Tabs2 = _interopRequireDefault(_Tabs);

var _Tab = require('./kendo/tabstrip/Tab');

var _Tab2 = _interopRequireDefault(_Tab);

var _TabContent = require('./kendo/tabstrip/TabContent');

var _TabContent2 = _interopRequireDefault(_TabContent);

var _AutoComplete = require('./kendo/AutoComplete');

var _AutoComplete2 = _interopRequireDefault(_AutoComplete);

var _DatePicker = require('./kendo/DatePicker');

var _DatePicker2 = _interopRequireDefault(_DatePicker);

var _DateRangePicker = require('./kendo/DateRangePicker');

var _DateRangePicker2 = _interopRequireDefault(_DateRangePicker);

var _DropDownList = require('./kendo/DropDownList');

var _DropDownList2 = _interopRequireDefault(_DropDownList);

var _Grid = require('./kendo/Grid');

var _Grid2 = _interopRequireDefault(_Grid);

var _MultiSelect = require('./kendo/MultiSelect');

var _MultiSelect2 = _interopRequireDefault(_MultiSelect);

var _NumericTextBox = require('./kendo/NumericTextBox');

var _NumericTextBox2 = _interopRequireDefault(_NumericTextBox);

var _PanelBar = require('./kendo/PanelBar');

var _ProgressBar = require('./kendo/ProgressBar');

var _ProgressBar2 = _interopRequireDefault(_ProgressBar);

var _TreeView = require('./kendo/TreeView');

var _TreeView2 = _interopRequireDefault(_TreeView);

var _Window = require('./kendo/Window');

var _Window2 = _interopRequireDefault(_Window);

var _Slider = require('./kendo/Slider');

var _Slider2 = _interopRequireDefault(_Slider);

var _LineChart = require('./charts/highcharts/LineChart');

var _LineChart2 = _interopRequireDefault(_LineChart);

var _ScatterChart = require('./charts/highcharts/ScatterChart');

var _ScatterChart2 = _interopRequireDefault(_ScatterChart);

var _ColumnChart = require('./charts/highcharts/ColumnChart');

var _ColumnChart2 = _interopRequireDefault(_ColumnChart);

var _PieChart = require('./charts/highcharts/PieChart');

var _PieChart2 = _interopRequireDefault(_PieChart);

var _DefaultChartOption = require('./charts/highcharts/DefaultChartOption');

var _DefaultChartOption2 = _interopRequireDefault(_DefaultChartOption);

var _Util = require('./services/Util');

var _Util2 = _interopRequireDefault(_Util);

var _NumberUtil = require('./services/NumberUtil');

var _NumberUtil2 = _interopRequireDefault(_NumberUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Highcharts


// Etc Elements
//var TabSet = require('./components/tabs/TabSet');
//var Tabs = require('./components/tabs/Tabs');
//var Tab = require('./components/tabs/Tab');
//var TabContents = require('./components/tabs/TabContents');
//var TabContent = require('./components/tabs/TabContent');

// Kendo


// Form Elements

var DateUtil = require('./services/DateUtil');

// Services

var RegExp = require('./services/RegExp');
var Resource = require('./services/Resource');

var Puf = {
    // Elements
    Alert: _Alert2.default,
    Button: _Button2.default,
    ToggleButton: _ToggleButton2.default,
    ButtonDropdown: _ButtonDropdown2.default,
    HiddenContent: _HiddenContent2.default,
    MainFrameSplitter: _MainFrameSplitter2.default,
    Modal: _Modal.Modal,
    ModalHeader: _Modal.ModalHeader,
    ModalBody: _Modal.ModalBody,
    ModalFooter: _Modal.ModalFooter,
    Panel: _Panel.Panel,
    PanelHeader: _Panel.PanelHeader,
    PanelBody: _Panel.PanelBody,
    PanelFooter: _Panel.PanelFooter,

    // Form Elements
    Checkbox: _Checkbox2.default,
    RadioGroup: _RadioGroup2.default,
    Radio: _Radio2.default,
    RadioDivider: _RadioDivider2.default,
    Fieldset: _Fieldset2.default,
    FineUploader: _FineUploader2.default,

    // Etc Elements
    //TabSet: TabSet,
    //Tabs: Tabs,
    //Tab: Tab,
    //TabContents: TabContents,
    //TabContent: TabContent,

    // Kendo
    TabStrip: _TabStrip2.default,
    Tabs: _Tabs2.default,
    Tab: _Tab2.default,
    TabContent: _TabContent2.default,
    AutoComplete: _AutoComplete2.default,
    DatePicker: _DatePicker2.default,
    DateRangePicker: _DateRangePicker2.default,
    DropDownList: _DropDownList2.default,
    Grid: _Grid2.default,
    MultiSelect: _MultiSelect2.default,
    NumericTextBox: _NumericTextBox2.default,
    PanelBar: _PanelBar.PanelBar,
    PanelBarPane: _PanelBar.PanelBarPane,
    ProgressBar: _ProgressBar2.default,
    TreeView: _TreeView2.default,
    Window: _Window2.default,
    Slider: _Slider2.default,

    kendo: {
        TabStrip: _TabStrip2.default,
        Tabs: _Tabs2.default,
        Tab: _Tab2.default,
        TabContent: _TabContent2.default,
        AutoComplete: _AutoComplete2.default,
        DatePicker: _DatePicker2.default,
        DateRangePicker: _DateRangePicker2.default,
        DropDownList: _DropDownList2.default,
        Grid: _Grid2.default,
        MultiSelect: _MultiSelect2.default,
        NumericTextBox: _NumericTextBox2.default,
        PanelBar: _PanelBar.PanelBar,
        PanelBarPane: _PanelBar.PanelBarPane,
        ProgressBar: _ProgressBar2.default,
        TreeView: _TreeView2.default,
        Window: _Window2.default,
        Slider: _Slider2.default
    },

    // Highcharts
    LineChart: _LineChart2.default,
    ScatterChart: _ScatterChart2.default,
    ColumnChart: _ColumnChart2.default,
    PieChart: _PieChart2.default,
    DefaultChartOption: _DefaultChartOption2.default,

    // Services
    Util: _Util2.default,
    DateUtil: DateUtil,
    NumberUtil: _NumberUtil2.default,
    RegExp: RegExp,
    Resource: Resource
};

module.exports = Puf;

},{"./charts/highcharts/ColumnChart":37,"./charts/highcharts/DefaultChartOption":38,"./charts/highcharts/LineChart":40,"./charts/highcharts/PieChart":41,"./charts/highcharts/ScatterChart":42,"./components/Alert":43,"./components/Button":44,"./components/ButtonDropdown":45,"./components/Checkbox":46,"./components/Fieldset":47,"./components/FineUploader":48,"./components/HiddenContent":49,"./components/MainFrameSplitter":50,"./components/Modal":51,"./components/Panel":52,"./components/ToggleButton":53,"./components/radio/Radio":54,"./components/radio/RadioDivider":55,"./components/radio/RadioGroup":56,"./kendo/AutoComplete":57,"./kendo/DatePicker":58,"./kendo/DateRangePicker":59,"./kendo/DropDownList":60,"./kendo/Grid":61,"./kendo/MultiSelect":62,"./kendo/NumericTextBox":63,"./kendo/PanelBar":64,"./kendo/ProgressBar":65,"./kendo/Slider":66,"./kendo/TreeView":67,"./kendo/Window":68,"./kendo/tabstrip/Tab":69,"./kendo/tabstrip/TabContent":70,"./kendo/tabstrip/TabStrip":71,"./kendo/tabstrip/Tabs":72,"./services/DateUtil":73,"./services/NumberUtil":74,"./services/RegExp":75,"./services/Resource":76,"./services/Util":77}],37:[function(require,module,exports){
/**
 * ColumnChart component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/03/03
 * author <a href="mailto:kjuhwa@nkia.co.kr">kjuhwa</a>
 *
 * example:
 * <Puf.ColumnChart options={options} />
 *
 * Highcharts 라이브러리에 종속적이다.
 * 
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../../services/Util');

var _Util2 = _interopRequireDefault(_Util);

var _DefaultChartOption = require('./DefaultChartOption');

var _DefaultChartOption2 = _interopRequireDefault(_DefaultChartOption);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    options: _react.PropTypes.object,
    autoInit: _react.PropTypes.bool,

    colors: _react.PropTypes.array,
    width: _react.PropTypes.number,
    height: _react.PropTypes.number,

    categories: _react.PropTypes.array,
    series: _react.PropTypes.array,

    liveInterval: _react.PropTypes.number,
    units: _react.PropTypes.string,

    onLoad: _react.PropTypes.func,
    // 실시간 데이타 추가 Func
    onLive: _react.PropTypes.func,
    // Tooltip
    tooltipFormatter: _react.PropTypes.func
};

// 클래스가 생성될 때 한번 호출되고 캐시된다.
// 부모 컴포넌트에서 prop이 넘어오지 않은 경우 (in 연산자로 확인) 매핑의 값이 this.props에 설정된다.
var defaultProps = {
    width: null,
    height: null,
    liveInterval: 1000,
    autoInit: true
};

var ColumnChart = function (_Component) {
    _inherits(ColumnChart, _Component);

    function ColumnChart(props) {
        _classCallCheck(this, ColumnChart);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ColumnChart).call(this, props));

        var id = props.id;
        if (typeof id === 'undefined') {
            id = _Util2.default.getUUID();
        }

        _this.id = id;
        _this.columnChart = null;

        // Manually bind this method to the component instance...
        //this.onLoad = this.onLoad.bind(this);
        return _this;
    }

    _createClass(ColumnChart, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.autoInit) {
                this.columnChart = new Highcharts.Chart(this.options());
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            // props 값이 변경 될 때마다 호출한다.
            // 수동 생성으로 설정되어 있을때에만 차트를 생성해 준다.
            // series에 값이 있으면서 차트가 생성되어 있지 않을때에...
            if (!this.props.autoInit && this.columnChart == null) {
                this.columnChart = new Highcharts.Chart(this.options());
            }
        }

        //-----------------------------
        // private
        /**
         * @private
         */

    }, {
        key: 'options',
        value: function options() {
            var _props = this.props;
            var width = _props.width;
            var height = _props.height;
            var colors = _props.colors;
            var categories = _props.categories;
            var series = _props.series;
            var onLoad = _props.onLoad;
            var units = _props.units;
            var tooltipFormatter = _props.tooltipFormatter;


            var options = _DefaultChartOption2.default.getDefaultChartOption();

            $.extend(true, options, {
                chart: {
                    type: 'column',
                    width: width,
                    height: height,
                    renderTo: this.id
                }
            });

            if (typeof colors !== 'undefined') {
                $.extend(true, options, { colors: colors });
            }

            if (typeof categories !== 'undefined') {
                $.extend(true, options, { xAxis: { categories: categories } });
            }

            if (typeof series !== 'undefined') {
                $.extend(true, options, { series: series });
            }

            if (typeof onLoad !== 'undefined') {
                $.extend(true, options, {
                    chart: {
                        events: {
                            load: onLoad
                        }
                    }
                });
            }

            if (typeof units !== 'undefined') {
                $.extend(true, options, {
                    yAxis: {
                        labels: {
                            formatter: function formatter() {
                                return _DefaultChartOption2.default.convertYAixUnit(units, this.value);
                            }
                        }
                    }
                });
            }

            if (typeof tooltipFormatter !== 'undefined') {
                $.extend(true, options, {
                    tooltip: {
                        formatter: tooltipFormatter
                    }
                });
            }

            if (typeof this.props.options !== 'undefined') {
                $.extend(true, options, this.props.options);
            }

            return options;
        }
    }, {
        key: 'chartId',
        value: function chartId() {
            return this.id;
        }
    }, {
        key: 'update',
        value: function update(series) {
            // Highcharts 5.0.0
            this.columnChart.update({
                series: series
            });
        }
    }, {
        key: 'reflow',
        value: function reflow() {
            this.columnChart.reflow();
        }
    }, {
        key: 'startLive',
        value: function startLive() {
            var _this2 = this;

            var _props2 = this.props;
            var onLive = _props2.onLive;
            var liveInterval = _props2.liveInterval;


            if (typeof onLive !== 'undefined') {
                (function () {

                    var columnChart = _this2.columnChart;
                    var id = _this2.id;
                    (function appendData() {
                        onLive(columnChart);
                        window.basicChartTimeoutMap[id] = setTimeout(appendData, liveInterval);
                    }).bind(_this2)();
                })();
            }
        }
    }, {
        key: 'stopLive',
        value: function stopLive() {
            var onLive = this.props.onLive;


            if (typeof onLive !== 'undefined') {
                if (window.basicChartTimeoutMap[this.id]) {
                    clearTimeout(window.basicChartTimeoutMap[this.id]);
                }
            }
        }
    }, {
        key: 'componentWillMount',
        value: function componentWillMount() {
            // Timer 객체 공간이 구성되지 않았다면 초기화를 시켜준다.
            // cygnus에서 사용 중이기 때문에 크게 문제 될건 없을 듯 하다.
            if (window.basicChartTimeoutMap == undefined) {
                window.basicChartTimeoutMap = {};
            }
        }

        // 차트 삭제시 메모리에 올라와 있는 Highcharts 객체와 Timer를 지운다.

    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            var chartId = this.id;
            $.each(Highcharts.charts, function (i, chart) {
                if (chart && chartId == chart.container.parentNode.id) {
                    chart.destroy();
                }
            });

            if (!window.basicChartTimeoutMap) {
                window.basicChartTimeoutMap = {};
                window.basicChartTimeoutMap[chartId] = null;
            } else if (window.basicChartTimeoutMap[chartId]) {
                clearTimeout(window.basicChartTimeoutMap[chartId]);
            }

            this.columnChart = null;
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props3 = this.props;
            var className = _props3.className;
            var height = _props3.height;


            return _react2.default.createElement(
                'div',
                { id: this.id, className: className, style: { height: height } },
                _react2.default.createElement(
                    'div',
                    { className: 'chart-loading' },
                    _react2.default.createElement('i', { className: 'fa fa-refresh fa-spin fa-lg fa-fw' })
                )
            );
        }
    }]);

    return ColumnChart;
}(_react.Component);

ColumnChart.propTypes = propTypes;
ColumnChart.defaultProps = defaultProps;

exports.default = ColumnChart;

},{"../../services/Util":77,"./DefaultChartOption":38,"classnames":2,"react":34}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DefaultChartOption = function () {
	function DefaultChartOption() {
		_classCallCheck(this, DefaultChartOption);
	}

	_createClass(DefaultChartOption, null, [{
		key: 'getDefaultChartOption',
		value: function getDefaultChartOption(tickInterval, tickCount) {
			return {
				credits: {
					enabled: false
				},
				chart: {
					zoomType: 'x',
					animation: true,
					resetZoomButton: {
						position: {
							align: 'right',
							x: -50,
							y: 0
						},
						relativeTo: 'chart' //or 'chart'
					},
					events: {}
				},
				title: {
					text: ''
				},
				subtitle: {
					text: ''
				},
				legend: {
					enabled: false,
					layout: 'horizontal',
					align: 'top',
					verticalAlign: 'top',
					y: -27,
					x: -10,
					itemMarginTop: 0,
					itemMarginBottom: 5,
					symbolPadding: 2,
					symbolWidth: 10,
					itemStyle: {
						color: '#3E4454',
						fontWeight: 'normal',
						fontSize: '12'
					}
				},

				xAxis: {
					tickInterval: tickInterval,
					events: {
						setExtremes: function setExtremes(event) {
							var min = event.min == undefined ? 0 : event.min;
							var max = event.max == undefined ? this.dataMax : event.max;
							tickInterval = Math.round((max - min) / tickCount);
							this.options.tickInterval = tickInterval;
						}
					}
				},
				yAxis: {
					min: 0,
					minRange: 1,
					title: {
						text: ''
					},
					stackLabels: {
						enabled: false,
						style: {
							fontWeight: 'bold',
							color: Highcharts.theme && Highcharts.theme.textColor || 'gray'
						}
					}
				},
				tooltip: {
					shared: true,
					crosshairs: {
						color: 'red',
						width: 1
					},
					useHTML: true,
					backgroundColor: {
						linearGradient: [0, 0, 0, 60],
						stops: [[0, '#FFFFFF'], [1, '#f3f3f3']]
					},
					borderWidth: 1,
					borderColor: '#52b2ea'
				},
				plotOptions: {
					column: {
						//stacking: 'normal',
						dataLabels: {
							enabled: false,
							color: Highcharts.theme && Highcharts.theme.dataLabelsColor || 'white',
							style: {
								textShadow: '0 0 3px black'
							}
						},
						pointPadding: 0.2,
						borderWidth: 0,
						states: {
							hover: {
								enabled: true
							}
						}
					},
					area: {
						lineWidth: 1,
						marker: {
							enabled: false
						},
						shadow: false,
						states: {
							hover: {
								lineWidth: 1
							}
						},
						enableMouseTracking: true
					},
					line: {
						lineWidth: 1,
						marker: {
							enabled: true,
							symbol: 'circle',
							radius: 0.5
						}
					},
					spline: {
						lineWidth: 1,
						marker: {
							enabled: true,
							symbol: 'circle',
							radius: 0.5
						}
					},
					arearange: {
						turboThreshold: 2000
					},
					series: {
						connectNulls: true,
						point: {
							events: {}
						}
					}
				}
			};
		}
	}, {
		key: 'getScatterChartOption',
		value: function getScatterChartOption(tickInterval, step) {
			return {
				loading: {
					labelStyle: {
						color: 'white',
						fontWeight: "bold"
					},
					style: {
						backgroundColor: 'gray'
					}
				},
				credits: {
					enabled: false
				},
				exporting: {
					enabled: false
				},
				chart: {
					type: 'scatter',
					zoomType: 'xy',
					animation: false,
					spacingRight: 10,
					resetZoomButton: {
						position: {
							align: 'right',
							x: -50,
							y: 0
						},
						relativeTo: 'chart' //or 'chart'
					},
					events: {}
				},
				title: {
					text: ''
				},
				subtitle: {
					text: ''
				},
				legend: {
					enabled: false,
					layout: 'vertical',
					align: 'left',
					verticalAlign: 'top',
					maxHeight: 100,
					x: 50,
					y: -27,
					floating: true,
					backgroundColor: Highcharts.theme && Highcharts.theme.legendBackgroundColor || '#FFFFFF',
					borderWidth: 1,
					borderColor: '#D8D8D8',
					borderRadius: 5,
					itemMarginTop: 0,
					itemMarginBottom: 5,
					symbolPadding: 2,
					symbolWidth: 20,
					symbolRadius: 6,
					itemStyle: {
						color: '#3E4454',
						fontWeight: 'normal',
						fontSize: '12'
					},
					title: {
						text: ''
					}
				},
				xAxis: {
					tickmarkPlacement: 'on',
					allowDecimals: false,
					type: 'datetime',
					startOnTick: true,
					endOnTick: true,
					tickInterval: tickInterval,
					dateTimeLabelFormats: {
						second: '%H:%M:%S',
						minute: '%H:%M'
					},
					labels: {
						step: step,
						staggerLines: 1
					},
					tickWidth: 0
				},
				yAxis: {
					ordinal: false,
					showLastLabel: true,
					title: { text: '' },
					tickLength: 8,
					tickPixelInterval: 100,
					min: 0,
					minRange: 1
				},
				tooltip: {
					shared: true,
					useHTML: true,
					backgroundColor: {
						linearGradient: [0, 0, 0, 60],
						stops: [[0, '#FFFFFF'], [1, '#f3f3f3']]
					},
					borderWidth: 1,
					borderColor: '#52b2ea',
					animation: false
				},
				plotOptions: {
					scatter: {
						marker: {
							radius: 1.5
						},
						events: {}
					}
				}
			};
		}
	}, {
		key: 'convertYAixUnit',
		value: function convertYAixUnit(unitStr, value) {
			var result = value;
			if (unitStr) {
				var label = value;
				var seed = 1000; // decimal(1000) or bytes(1024)
				var u = '';
				var lowCaseUnit = unitStr.toLowerCase();
				var unitConst = ['k', 'M', 'G', 'T', 'P'];
				var timeConst = ['ms', 'sec', 'min', 'hour', 'day'];
				var timeSeed = [1, 1000, 1000 * 60, 1000 * 60 * 60, 1000 * 60 * 60 * 24];

				// seed 값 설정(1000 or 1024)
				if (lowCaseUnit.indexOf("bps") > -1 || lowCaseUnit.indexOf("bit") > -1 || lowCaseUnit.indexOf("kb") > -1 || lowCaseUnit.indexOf("mb") > -1 || lowCaseUnit.indexOf("gb") > -1 || lowCaseUnit.indexOf("tb") > -1 || lowCaseUnit.indexOf("pb") > -1) {
					seed = 1024;
				} else if (lowCaseUnit.indexOf("us") > -1 || lowCaseUnit.indexOf("ms") > -1 || lowCaseUnit.indexOf("sec") > -1 || lowCaseUnit.indexOf("min") > -1 || lowCaseUnit.indexOf("hour") > -1 || lowCaseUnit.indexOf("day") > -1) {
					seed = -1;
				} else if (lowCaseUnit.indexOf("b") > -1) {
					seed = 1000;
				} else {
					return value + unitStr;
				}

				// 단위를 하나로 일정하게 맞춘다.
				if (lowCaseUnit.indexOf("kb") > -1) label *= seed;else if (lowCaseUnit.indexOf("mb") > -1) label *= Math.pow(seed, 2);else if (lowCaseUnit.indexOf("gb") > -1) label *= Math.pow(seed, 3);else if (lowCaseUnit.indexOf("tb") > -1) label *= Math.pow(seed, 4);else if (lowCaseUnit.indexOf("pb") > -1) label *= Math.pow(seed, 5);else if (lowCaseUnit.indexOf("ms") > -1) {
					label *= timeSeed[0];
				} else if (lowCaseUnit.indexOf("sec") > -1 && lowCaseUnit != "count_per_sec") {
					label *= timeSeed[1];
				} else if (lowCaseUnit.indexOf("min") > -1) {
					label *= timeSeed[2];
				} else if (lowCaseUnit.indexOf("hour") > -1) {
					label *= timeSeed[3];
				} else if (lowCaseUnit.indexOf("day") > -1) {
					label *= timeSeed[4];
				}

				//단위가 일정해진 값(decimal)을 가지고 읽기 쉬운 값과 단위로 변환한다.
				if (seed != -1) {
					// seed 가 -1일 아니면 용량 관련 단위
					for (var i = 1; i < unitConst.length; i++) {
						if (label > Math.pow(seed, i) - 1 && label < Math.pow(seed, i + 1)) {
							label = label / Math.pow(seed, i);
							u = unitConst[i - 1];
						}
					}
				} else {
					// seed 가 -1 이면 무조건 시간 관련 단위
					for (var i = 0; i < timeConst.length; i++) {
						if (label > timeSeed[i] - 1 && label < timeSeed[i + 1]) {
							label = label / timeSeed[i];
							u = timeConst[i];
						}
					}
				}

				// numberFormat (Number number, [Number decimals], [String decimalPoint], [String thousandsSep])
				var numberDecimals = 0;
				if (label < 10) {
					numberDecimals = 1;
				}
				result = Highcharts.numberFormat(label, numberDecimals, '.', ',') + u;
			}
			return result;
		}
	}, {
		key: 'tooltipFormatter',
		value: function tooltipFormatter(valueKey, unitStr, convertYAixUnit) {
			if (convertYAixUnit == undefined) {
				convertYAixUnit = this.convertYAixUnit;
			}
			return function () {
				var s = '<span style="color:#333;">&nbsp;<b>' + this.points[0].key + '</b></span><table width=200>';
				s += '<tr ><td colspan="2" height="1"  style="border-top: 1px solid #ccc" ></td></tr>';
				$.each(this.points, function (i, point) {
					var data;
					for (var x in point.series.data) {
						var key = eval("point.series.data[x]." + valueKey);
						if (point.key == key) {
							data = point.series.data[x].y;
							break;
						}
					}
					var c;
					if (point.series.color.stops != undefined) {
						// Gradient color
						c = point.series.color.stops[1][1];
					} else {
						// not Gradient color
						c = point.series.color;
					}
					s += '<tr><td style="color:' + c + '">' + '●&nbsp;' + point.series.name + ": </td>";
					s += '<td style="text-align: right; color:#444; line-heiht:1.2em;"><b>' + convertYAixUnit(unitStr, data) + '</b></td></tr>';
				});
				s += '</table>';

				return s;
			};
		}
	}]);

	return DefaultChartOption;
}();

exports.default = DefaultChartOption;

},{}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var HighchartsOption = function () {
	function HighchartsOption() {
		_classCallCheck(this, HighchartsOption);
	}

	_createClass(HighchartsOption, null, [{
		key: 'setUseUTC',
		value: function setUseUTC(useUTC) {
			if (useUTC == undefined) {
				useUTC = false;
			}

			Highcharts.setOptions({
				global: {
					useUTC: useUTC
				}
			});
		}
	}]);

	return HighchartsOption;
}();

exports.default = HighchartsOption;

},{}],40:[function(require,module,exports){
/**
 * LineChart component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/03/03
 * author <a href="mailto:kjuhwa@nkia.co.kr">kjuhwa</a>
 *
 * example:
 * <Puf.LineChart options={options} />
 *
 * Highcharts 라이브러리에 종속적이다.
 * 
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../../services/Util');

var _Util2 = _interopRequireDefault(_Util);

var _DefaultChartOption = require('./DefaultChartOption');

var _DefaultChartOption2 = _interopRequireDefault(_DefaultChartOption);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    options: _react.PropTypes.object,
    autoInit: _react.PropTypes.bool,

    colors: _react.PropTypes.array,
    width: _react.PropTypes.number,
    height: _react.PropTypes.number,

    categories: _react.PropTypes.array,
    series: _react.PropTypes.array,
    tickInterval: _react.PropTypes.number,
    tickCount: _react.PropTypes.number,
    liveInterval: _react.PropTypes.number,
    units: _react.PropTypes.string,

    onLoad: _react.PropTypes.func,
    // 실시간 데이타 추가 Func
    onLive: _react.PropTypes.func,
    // Tooltip
    tooltipFormatter: _react.PropTypes.func
};

// 클래스가 생성될 때 한번 호출되고 캐시된다.
// 부모 컴포넌트에서 prop이 넘어오지 않은 경우 (in 연산자로 확인) 매핑의 값이 this.props에 설정된다.
var defaultProps = {
    width: null,
    height: null,
    tickCount: 5,
    tickInterval: 1,
    liveInterval: 1000,
    autoInit: true
};

var LineChart = function (_Component) {
    _inherits(LineChart, _Component);

    function LineChart(props) {
        _classCallCheck(this, LineChart);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(LineChart).call(this, props));

        var id = props.id;
        if (typeof id === 'undefined') {
            id = _Util2.default.getUUID();
        }

        _this.id = id;
        _this.lineChart = null;

        // Manually bind this method to the component instance...
        //this.onLoad = this.onLoad.bind(this);
        return _this;
    }

    _createClass(LineChart, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.autoInit) {
                this.lineChart = new Highcharts.Chart(this.options());
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            // props 값이 변경 될 때마다 호출한다.
            // 수동 생성으로 설정되어 있을때에만 차트를 생성해 준다.
            // series에 값이 있으면서 차트가 생성되어 있지 않을때에...
            if (!this.props.autoInit && this.lineChart == null) {
                this.lineChart = new Highcharts.Chart(this.options());
            }
        }

        //-----------------------------
        // private
        /**
         * @private
         */

    }, {
        key: 'options',
        value: function options() {
            var _props = this.props;
            var width = _props.width;
            var height = _props.height;
            var colors = _props.colors;
            var categories = _props.categories;
            var series = _props.series;
            var onLoad = _props.onLoad;
            var tickCount = _props.tickCount;
            var tickInterval = _props.tickInterval;
            var units = _props.units;
            var tooltipFormatter = _props.tooltipFormatter;


            var options = _DefaultChartOption2.default.getDefaultChartOption(tickInterval, tickCount);

            $.extend(true, options, {
                chart: {
                    type: 'line',
                    width: width,
                    height: height,
                    renderTo: this.id
                }
            });

            if (typeof colors !== 'undefined') {
                $.extend(true, options, { colors: colors });
            }

            if (typeof categories !== 'undefined') {
                $.extend(true, options, { xAxis: { categories: categories } });
            }

            if (typeof series !== 'undefined') {
                $.extend(true, options, { series: series });
            }

            if (typeof onLoad !== 'undefined') {
                $.extend(true, options, {
                    chart: {
                        events: {
                            load: onLoad
                        }
                    }
                });
            }

            if (typeof units !== 'undefined') {
                $.extend(true, options, {
                    yAxis: {
                        labels: {
                            formatter: function formatter() {
                                return _DefaultChartOption2.default.convertYAixUnit(units, this.value);
                            }
                        }
                    }
                });
            }

            if (typeof tooltipFormatter !== 'undefined') {
                $.extend(true, options, {
                    tooltip: {
                        formatter: tooltipFormatter
                    }
                });
            }

            if (typeof this.props.options !== 'undefined') {
                $.extend(true, options, this.props.options);
            }

            return options;
        }
    }, {
        key: 'chartId',
        value: function chartId() {
            return this.id;
        }
    }, {
        key: 'update',
        value: function update(series) {
            // Highcharts 5.0.0
            this.lineChart.update({
                series: series
            });
        }
    }, {
        key: 'reflow',
        value: function reflow() {
            this.lineChart.reflow();
        }
    }, {
        key: 'startLive',
        value: function startLive() {
            var _this2 = this;

            var _props2 = this.props;
            var onLive = _props2.onLive;
            var liveInterval = _props2.liveInterval;


            if (typeof onLive !== 'undefined') {
                (function () {

                    var lineChart = _this2.lineChart;
                    var id = _this2.id;
                    (function appendData() {
                        onLive(lineChart);
                        window.basicChartTimeoutMap[id] = setTimeout(appendData, liveInterval);
                    }).bind(_this2)();
                })();
            }
        }
    }, {
        key: 'stopLive',
        value: function stopLive() {
            var onLive = this.props.onLive;


            if (typeof onLive !== 'undefined') {
                if (window.basicChartTimeoutMap[this.id]) {
                    clearTimeout(window.basicChartTimeoutMap[this.id]);
                }
            }
        }
    }, {
        key: 'componentWillMount',
        value: function componentWillMount() {
            // Timer 객체 공간이 구성되지 않았다면 초기화를 시켜준다.
            // cygnus에서 사용 중이기 때문에 크게 문제 될건 없을 듯 하다.
            if (window.basicChartTimeoutMap == undefined) {
                window.basicChartTimeoutMap = {};
            }
        }

        // 차트 삭제시 메모리에 올라와 있는 Highcharts 객체와 Timer를 지운다.

    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            var chartId = this.id;
            $.each(Highcharts.charts, function (i, chart) {
                if (chart && chartId == chart.container.parentNode.id) {
                    chart.destroy();
                }
            });

            if (!window.basicChartTimeoutMap) {
                window.basicChartTimeoutMap = {};
                window.basicChartTimeoutMap[chartId] = null;
            } else if (window.basicChartTimeoutMap[chartId]) {
                clearTimeout(window.basicChartTimeoutMap[chartId]);
            }

            this.lineChart = null;
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props3 = this.props;
            var className = _props3.className;
            var height = _props3.height;


            return _react2.default.createElement(
                'div',
                { id: this.id, className: className, style: { height: height } },
                _react2.default.createElement(
                    'div',
                    { className: 'chart-loading' },
                    _react2.default.createElement('i', { className: 'fa fa-refresh fa-spin fa-lg fa-fw' })
                )
            );
        }
    }]);

    return LineChart;
}(_react.Component);

LineChart.propTypes = propTypes;
LineChart.defaultProps = defaultProps;

exports.default = LineChart;

},{"../../services/Util":77,"./DefaultChartOption":38,"classnames":2,"react":34}],41:[function(require,module,exports){
/**
 * PieChart component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/03/03
 * author <a href="mailto:kjuhwa@nkia.co.kr">kjuhwa</a>
 *
 * example:
 * <Puf.PieChart options={options} />
 *
 * Highcharts 라이브러리에 종속적이다.
 * 
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../../services/Util');

var _Util2 = _interopRequireDefault(_Util);

var _DefaultChartOption = require('./DefaultChartOption');

var _DefaultChartOption2 = _interopRequireDefault(_DefaultChartOption);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    options: _react.PropTypes.object,
    autoInit: _react.PropTypes.bool,

    colors: _react.PropTypes.array,
    width: _react.PropTypes.number,
    height: _react.PropTypes.number,

    series: _react.PropTypes.array,

    liveInterval: _react.PropTypes.number,

    onLoad: _react.PropTypes.func,
    // 실시간 데이타 추가 Func
    onLive: _react.PropTypes.func
};

// 클래스가 생성될 때 한번 호출되고 캐시된다.
// 부모 컴포넌트에서 prop이 넘어오지 않은 경우 (in 연산자로 확인) 매핑의 값이 this.props에 설정된다.
var defaultProps = {
    width: null,
    height: null,
    liveInterval: 1000,
    autoInit: true
};

var PieChart = function (_Component) {
    _inherits(PieChart, _Component);

    function PieChart(props) {
        _classCallCheck(this, PieChart);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PieChart).call(this, props));

        var id = props.id;
        if (typeof id === 'undefined') {
            id = _Util2.default.getUUID();
        }

        _this.id = id;
        _this.pieChart = null;

        // Manually bind this method to the component instance...
        //this.onLoad = this.onLoad.bind(this);
        return _this;
    }

    _createClass(PieChart, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            if (this.props.autoInit) {
                this.pieChart = new Highcharts.Chart(this.options());
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            // props 값이 변경 될 때마다 호출한다.
            // 수동 생성으로 설정되어 있을때에만 차트를 생성해 준다.
            // series에 값이 있으면서 차트가 생성되어 있지 않을때에...
            if (!this.props.autoInit && this.pieChart == null) {
                this.pieChart = new Highcharts.Chart(this.options());
            }
        }

        //-----------------------------
        // private
        /**
         * @private
         */

    }, {
        key: 'options',
        value: function options() {
            var _props = this.props;
            var width = _props.width;
            var height = _props.height;
            var colors = _props.colors;
            var series = _props.series;
            var onLoad = _props.onLoad;


            var options = _DefaultChartOption2.default.getDefaultChartOption();

            $.extend(true, options, {
                chart: {
                    type: 'pie',
                    width: width,
                    height: height,
                    renderTo: this.id
                }
            });

            if (typeof colors !== 'undefined') {
                $.extend(true, options, { colors: colors });
            }

            if (typeof series !== 'undefined') {
                $.extend(true, options, { series: series });
            }

            if (typeof onLoad !== 'undefined') {
                $.extend(true, options, {
                    chart: {
                        events: {
                            load: onLoad
                        }
                    }
                });
            }

            if (typeof this.props.options !== 'undefined') {
                $.extend(true, options, this.props.options);
            }

            return options;
        }
    }, {
        key: 'chartId',
        value: function chartId() {
            return this.id;
        }
    }, {
        key: 'update',
        value: function update(series) {
            // Highcharts 5.0.0
            this.pieChart.update({
                series: series
            });
        }
    }, {
        key: 'reflow',
        value: function reflow() {
            this.pieChart.reflow();
        }
    }, {
        key: 'startLive',
        value: function startLive() {
            var _this2 = this;

            var _props2 = this.props;
            var onLive = _props2.onLive;
            var liveInterval = _props2.liveInterval;


            if (typeof onLive !== 'undefined') {
                (function () {

                    var pieChart = _this2.pieChart;
                    var id = _this2.id;
                    (function appendData() {
                        onLive(pieChart);
                        window.basicChartTimeoutMap[id] = setTimeout(appendData, liveInterval);
                    }).bind(_this2)();
                })();
            }
        }
    }, {
        key: 'stopLive',
        value: function stopLive() {
            var onLive = this.props.onLive;


            if (typeof onLive !== 'undefined') {
                if (window.basicChartTimeoutMap[this.id]) {
                    clearTimeout(window.basicChartTimeoutMap[this.id]);
                }
            }
        }
    }, {
        key: 'componentWillMount',
        value: function componentWillMount() {
            // Timer 객체 공간이 구성되지 않았다면 초기화를 시켜준다.
            // cygnus에서 사용 중이기 때문에 크게 문제 될건 없을 듯 하다.
            if (window.basicChartTimeoutMap == undefined) {
                window.basicChartTimeoutMap = {};
            }
        }

        // 차트 삭제시 메모리에 올라와 있는 Highcharts 객체와 Timer를 지운다.

    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            var chartId = this.id;
            $.each(Highcharts.charts, function (i, chart) {
                if (chart && chartId == chart.container.parentNode.id) {
                    chart.destroy();
                }
            });

            if (!window.basicChartTimeoutMap) {
                window.basicChartTimeoutMap = {};
                window.basicChartTimeoutMap[chartId] = null;
            } else if (window.basicChartTimeoutMap[chartId]) {
                clearTimeout(window.basicChartTimeoutMap[chartId]);
            }

            this.pieChart = null;
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props3 = this.props;
            var className = _props3.className;
            var height = _props3.height;


            return _react2.default.createElement(
                'div',
                { id: this.id, className: className, style: { height: height } },
                _react2.default.createElement(
                    'div',
                    { className: 'chart-loading' },
                    _react2.default.createElement('i', { className: 'fa fa-refresh fa-spin fa-lg fa-fw' })
                )
            );
        }
    }]);

    return PieChart;
}(_react.Component);

PieChart.propTypes = propTypes;
PieChart.defaultProps = defaultProps;

exports.default = PieChart;

},{"../../services/Util":77,"./DefaultChartOption":38,"classnames":2,"react":34}],42:[function(require,module,exports){
/**
 * ScatterChart component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/03/03
 * author <a href="mailto:kjuhwa@nkia.co.kr">kjuhwa</a>
 *
 * example:
 * <Puf.ScatterChart options={options} />
 *
 * Highcharts 라이브러리에 종속적이다.
 * 
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../../services/Util');

var _Util2 = _interopRequireDefault(_Util);

var _DefaultChartOption = require('./DefaultChartOption');

var _DefaultChartOption2 = _interopRequireDefault(_DefaultChartOption);

var _HighchartsOption = require('./HighchartsOption');

var _HighchartsOption2 = _interopRequireDefault(_HighchartsOption);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    options: _react.PropTypes.object,
    autoInit: _react.PropTypes.bool,

    colors: _react.PropTypes.array,
    width: _react.PropTypes.number,
    height: _react.PropTypes.number,
    useUTC: _react.PropTypes.bool,

    series: _react.PropTypes.array,
    tickInterval: _react.PropTypes.number,
    tickCount: _react.PropTypes.number,
    liveInterval: _react.PropTypes.number,
    units: _react.PropTypes.string,

    onLoad: _react.PropTypes.func,
    // 실시간 데이타 추가 Func
    onLive: _react.PropTypes.func,
    // Tooltip
    tooltipFormatter: _react.PropTypes.func
};

// 클래스가 생성될 때 한번 호출되고 캐시된다.
// 부모 컴포넌트에서 prop이 넘어오지 않은 경우 (in 연산자로 확인) 매핑의 값이 this.props에 설정된다.
var defaultProps = {
    width: null,
    height: null,
    useUTC: false,
    tickCount: 5,
    tickInterval: 1000,
    liveInterval: 1000,
    autoInit: true
};

var ScatterChart = function (_Component) {
    _inherits(ScatterChart, _Component);

    function ScatterChart(props) {
        _classCallCheck(this, ScatterChart);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ScatterChart).call(this, props));

        var id = props.id;
        if (typeof id === 'undefined') {
            id = _Util2.default.getUUID();
        }

        _this.id = id;
        _this.scatterChart = null;

        // Manually bind this method to the component instance...
        //this.onLoad = this.onLoad.bind(this);
        return _this;
    }

    _createClass(ScatterChart, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            // Global options
            _HighchartsOption2.default.setUseUTC(this.props.useUTC);

            if (this.props.autoInit) {
                this.scatterChart = new Highcharts.Chart(this.options());
            }
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            // props 값이 변경 될 때마다 호출한다.
            // 수동 생성으로 설정되어 있을때에만 차트를 생성해 준다.
            // series에 값이 있으면서 차트가 생성되어 있지 않을때에...
            if (!this.props.autoInit && this.scatterChart == null) {
                this.scatterChart = new Highcharts.Chart(this.options());
            }
        }

        //-----------------------------
        // private
        /**
         * @private
         */

    }, {
        key: 'options',
        value: function options() {
            var _props = this.props;
            var width = _props.width;
            var height = _props.height;
            var colors = _props.colors;
            var series = _props.series;
            var onLoad = _props.onLoad;
            var tickInterval = _props.tickInterval;
            var tickCount = _props.tickCount;
            var units = _props.units;
            var tooltipFormatter = _props.tooltipFormatter;


            var options = _DefaultChartOption2.default.getScatterChartOption(tickInterval, tickCount);

            $.extend(true, options, {
                chart: {
                    type: 'scatter',
                    width: width,
                    height: height,
                    renderTo: this.id
                }
            });

            if (typeof colors !== 'undefined') {
                $.extend(true, options, { colors: colors });
            }

            if (typeof series !== 'undefined') {
                $.extend(true, options, { series: series });
            }

            if (typeof onLoad !== 'undefined') {
                $.extend(true, options, {
                    chart: {
                        events: {
                            load: onLoad
                        }
                    }
                });
            }

            if (typeof units !== 'undefined') {
                $.extend(true, options, {
                    yAxis: {
                        labels: {
                            formatter: function formatter() {
                                return _DefaultChartOption2.default.convertYAixUnit(units, this.value);
                            }
                        }
                    }
                });
            }

            if (typeof tooltipFormatter !== 'undefined') {
                $.extend(true, options, {
                    tooltip: {
                        formatter: tooltipFormatter
                    }
                });
            }

            if (typeof this.props.options !== 'undefined') {
                $.extend(true, options, this.props.options);
            }

            return options;
        }
    }, {
        key: 'chartId',
        value: function chartId() {
            return this.id;
        }
    }, {
        key: 'update',
        value: function update(series) {
            // Highcharts 5.0.0
            this.scatterChart.update({
                series: series
            });
        }
    }, {
        key: 'reflow',
        value: function reflow() {
            this.scatterChart.reflow();
        }
    }, {
        key: 'startLive',
        value: function startLive() {
            var _this2 = this;

            var _props2 = this.props;
            var onLive = _props2.onLive;
            var liveInterval = _props2.liveInterval;


            if (typeof onLive !== 'undefined') {
                (function () {

                    var scatterChart = _this2.scatterChart;
                    var id = _this2.id;
                    (function appendData() {
                        onLive(scatterChart);
                        window.basicChartTimeoutMap[id] = setTimeout(appendData, liveInterval);
                    }).bind(_this2)();
                })();
            }
        }
    }, {
        key: 'stopLive',
        value: function stopLive() {
            var onLive = this.props.onLive;


            if (typeof onLive !== 'undefined') {
                if (window.basicChartTimeoutMap[this.id]) {
                    clearTimeout(window.basicChartTimeoutMap[this.id]);
                }
            }
        }
    }, {
        key: 'componentWillMount',
        value: function componentWillMount() {
            // Timer 객체 공간이 구성되지 않았다면 초기화를 시켜준다.
            // cygnus에서 사용 중이기 때문에 크게 문제 될건 없을 듯 하다.
            if (window.basicChartTimeoutMap == undefined) {
                window.basicChartTimeoutMap = {};
            }
        }

        // 차트 삭제시 메모리에 올라와 있는 Highcharts 객체와 Timer를 지운다.

    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            var chartId = this.id;
            $.each(Highcharts.charts, function (i, chart) {
                if (chart && chartId == chart.container.parentNode.id) {
                    chart.destroy();
                }
            });

            if (!window.basicChartTimeoutMap) {
                window.basicChartTimeoutMap = {};
                window.basicChartTimeoutMap[chartId] = null;
            } else if (window.basicChartTimeoutMap[chartId]) {
                clearTimeout(window.basicChartTimeoutMap[chartId]);
            }

            this.scatterChart = null;
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props3 = this.props;
            var className = _props3.className;
            var height = _props3.height;


            return _react2.default.createElement(
                'div',
                { id: this.id, className: className, style: { height: height } },
                _react2.default.createElement(
                    'div',
                    { className: 'chart-loading' },
                    _react2.default.createElement('i', { className: 'fa fa-refresh fa-spin fa-lg fa-fw' })
                )
            );
        }
    }]);

    return ScatterChart;
}(_react.Component);

ScatterChart.propTypes = propTypes;
ScatterChart.defaultProps = defaultProps;

exports.default = ScatterChart;

},{"../../services/Util":77,"./DefaultChartOption":38,"./HighchartsOption":39,"classnames":2,"react":34}],43:[function(require,module,exports){
/**
 * Alert component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/03/24
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Pum.Alert ref="alert" title="타이틀" message="메시지" onOk={this.onOk} />
 * <Pum.Alert ref="confirm" type="confirm" title="타이틀" message="메시지" onOk={this.onConfirm} onCancel={this.onCancel}/>
 *
 * bootstrap component
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    type: _react.PropTypes.string, // null/confirm (default: null)
    title: _react.PropTypes.string,
    titleIconClassName: _react.PropTypes.string,
    message: _react.PropTypes.string,
    okLabel: _react.PropTypes.string,
    cancelLabel: _react.PropTypes.string,
    okClassName: _react.PropTypes.string,
    cancelClassName: _react.PropTypes.string,
    onOk: _react.PropTypes.func,
    onCancel: _react.PropTypes.func,
    width: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number])
};

var defaultProps = {
    title: 'Title',
    okLabel: $ps_locale.confirm,
    cancelLabel: $ps_locale.cancel
};

/** Class representing a Alert. */

var Alert = function (_Component) {
    _inherits(Alert, _Component);

    function Alert(props) {
        _classCallCheck(this, Alert);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Alert).call(this, props));

        _this.state = {
            title: props.title,
            message: props.message
        };

        // Operations usually carried out in componentWillMount go here
        var id = props.id;
        if (typeof id === 'undefined') {
            id = _Util2.default.getUUID();
        }

        _this.id = id;

        // Manually bind this method to the component instance...
        _this.onOk = _this.onOk.bind(_this);
        _this.onCancel = _this.onCancel.bind(_this);
        return _this;
    }

    _createClass(Alert, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            // 컴포넌트가 새로운 props를 받을 때 호출(최초 렌더링 시에는 호출되지 않음)
            this.setState({ title: nextProps.title, message: nextProps.message });
        }

        //-----------------------------
        // events

    }, {
        key: 'onOk',
        value: function onOk(event) {
            // custom event emit 에 대해서 연구 필요
            this.hide();

            // okFunc
            if (typeof this.okFunc === 'function') {
                this.okFunc();
            }

            // onOk
            if (typeof this.props.onOk === 'function') {
                this.props.onOk();
            }
        }
    }, {
        key: 'onCancel',
        value: function onCancel(event) {
            // custom event emit 에 대해서 연구 필요
            this.hide();

            // cancelFunc
            if (typeof this.cancelFunc === 'function') {
                this.cancelFunc();
            }

            // onCancel
            if (typeof this.props.onCancel === 'function') {
                this.props.onCancel();
            }
        }

        //-----------------------------
        // methods

    }, {
        key: 'show',
        value: function show(okFunc, cancelFunc) {
            var alert = $('#' + this.id);
            alert.modal('show');

            this.okFunc = okFunc;
            this.cancelFunc = cancelFunc;
        }
    }, {
        key: 'hide',
        value: function hide() {
            var alert = $('#' + this.id);
            alert.modal('hide');
        }
    }, {
        key: 'setMessage',
        value: function setMessage(message) {
            if (typeof message === 'string') {
                this.setState({ message: message });
            }
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props = this.props;
            var className = _props.className;
            var type = _props.type;
            var okLabel = _props.okLabel;
            var cancelLabel = _props.cancelLabel;
            var okClassName = _props.okClassName;
            var cancelClassName = _props.cancelClassName;
            var titleIconClassName = _props.titleIconClassName;
            var width = _props.width;


            var cancelButton;
            if (type === 'confirm') {
                cancelButton = _react2.default.createElement(
                    'button',
                    { type: 'button', className: (0, _classnames2.default)('btn', 'btn-cancel', cancelClassName), onClick: this.onCancel, 'data-dismiss': 'modal' },
                    cancelLabel
                );
            }

            return _react2.default.createElement(
                'div',
                { id: this.id, className: (0, _classnames2.default)('modal', 'modal-alert', className), role: 'dialog', 'aria-labelledby': '', 'aria-hidden': 'true', 'data-backdrop': 'static', 'data-keyboard': 'false' },
                _react2.default.createElement(
                    'div',
                    { className: 'modal-dialog modal-sm', style: { width: width } },
                    _react2.default.createElement(
                        'div',
                        { className: 'modal-content' },
                        _react2.default.createElement(
                            'div',
                            { className: 'modal-header' },
                            _react2.default.createElement('span', { className: (0, _classnames2.default)('title-icon', titleIconClassName) }),
                            _react2.default.createElement(
                                'span',
                                { className: 'modal-title' },
                                this.state.title
                            )
                        ),
                        _react2.default.createElement(
                            'div',
                            { className: 'modal-body' },
                            this.state.message
                        ),
                        _react2.default.createElement(
                            'div',
                            { className: 'modal-footer' },
                            _react2.default.createElement(
                                'button',
                                { type: 'button', className: (0, _classnames2.default)('btn', 'btn-ok', okClassName), onClick: this.onOk },
                                okLabel
                            ),
                            cancelButton
                        )
                    )
                )
            );
        }
    }]);

    return Alert;
}(_react.Component);

Alert.propTypes = propTypes;
Alert.defaultProps = defaultProps;

exports.default = Alert;

},{"../services/Util":77,"classnames":2,"react":34}],44:[function(require,module,exports){
/**
 * Temp component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/10/29
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.Button options={options} />
 *
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    type: _react.PropTypes.oneOf(['button', 'a']).isRequired,
    className: _react.PropTypes.string,
    iconClassName: _react.PropTypes.string,
    tooltip: _react.PropTypes.string,
    tooltipPosition: _react.PropTypes.oneOf(['bottom', 'top', 'left', 'right', 'center']),
    size: _react.PropTypes.oneOf(['sm', 'md', 'lg']),
    disabled: _react.PropTypes.bool,
    hidden: _react.PropTypes.bool,
    onClick: _react.PropTypes.func
};

var defaultProps = {
    type: 'button',
    className: 'btn-default',
    tooltipPosition: 'bottom'
};

/** Class representing a Button. */

var Button = function (_Component) {
    _inherits(Button, _Component);

    function Button(props) {
        _classCallCheck(this, Button);

        // Manually bind this method to the component instance...

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Button).call(this, props));

        _this.onClick = _this.onClick.bind(_this);
        return _this;
    }

    _createClass(Button, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            // 최초 렌더링이 일어나기 직전(한번 호출)
            var id = this.props.id;
            if (typeof id === 'undefined') {
                id = _Util2.default.getUUID();
            }

            this.id = id;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$button = $('#' + this.id);

            // tooltip
            if (typeof this.props.tooltip !== 'undefined') {

                this.tooltip = this.$button.kendoTooltip({
                    position: this.props.tooltipPosition
                }).data('kendoTooltip');
            }
        }

        // shouldComponentUpdate(nextProps, nextState) {
        //     // 새로운 props나 state를 받았을 때 렌더링 전에 호출(최초 렌더링 시에는 호출되지 않음)
        //     // false 면 render 호출하지 않음(componentWillUpdate 와 componentDidUpdate 역시 호출되지 않음)
        //     return false;    // default true
        // }

        //-----------------------------
        // events

    }, {
        key: 'onClick',
        value: function onClick(e) {
            // console.log(this.$button.attr('disabled'));
            // IE에서는 disabled 속성이 있어도 클릭이벤트가 발생한다.
            if (this.$button.attr('disabled') === 'disabled') return;
            if (typeof this.props.onClick !== 'undefined') {
                this.props.onClick(e);
            }
        }

        //-----------------------------
        // methods

    }, {
        key: 'enable',
        value: function enable(isBool) {
            if (typeof isBool === 'boolean') {
                this.$button.attr('disabled', !isBool);
            }
        }
    }, {
        key: 'show',
        value: function show(isBool) {
            if (typeof isBool === 'boolean') {
                if (isBool === true) {
                    this.$button.show();
                } else {
                    this.$button.hide();
                }
            }
        }

        /**
         * @private
         * render function
         */

    }, {
        key: 'renderButton',
        value: function renderButton() {}
    }, {
        key: 'renderA',
        value: function renderA() {
            var _props = this.props;
            var children = _props.children;
            var className = _props.className;
            var tooltip = _props.tooltip;
            var size = _props.size;
            var disabled = _props.disabled;


            var optional = {},
                sizeClassName;
            if (typeof size === 'string') {
                sizeClassName = 'btn-' + size;
            }

            // if(hidden === true) {
            //     optional.style = { display: 'none' };
            // }

            return _react2.default.createElement(
                'a',
                _extends({ href: '#', className: (0, _classnames2.default)('btn', className, sizeClassName, { disabled: this.state.disabled }), role: 'button'
                }, optional),
                this.renderIcon(),
                children
            );
        }
    }, {
        key: 'renderIcon',
        value: function renderIcon() {
            var iconClassName = this.props.iconClassName;

            if (iconClassName) {
                return _react2.default.createElement('i', { className: (0, _classnames2.default)('fa', iconClassName) });
            }
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props2 = this.props;
            var children = _props2.children;
            var className = _props2.className;
            var tooltip = _props2.tooltip;
            var size = _props2.size;
            var disabled = _props2.disabled;
            var hidden = _props2.hidden;


            var optional = {},
                sizeClassName;
            if (typeof size === 'string') {
                sizeClassName = 'btn-' + size;
            }

            // disabled
            if (typeof disabled === 'boolean') {
                optional.disabled = disabled;
            }

            // hidden
            if (typeof hidden === 'boolean') {
                if (hidden === true) {
                    optional.style = { display: 'none' };
                } else {
                    optional.style = { display: 'inline-block' };
                }
            }

            // {'\u00A0'}
            return _react2.default.createElement(
                'button',
                _extends({ id: this.id, type: 'button', className: (0, _classnames2.default)('btn', className, sizeClassName), onClick: this.onClick,
                    title: tooltip
                }, optional),
                this.renderIcon(),
                children
            );
        }
    }]);

    return Button;
}(_react.Component);

Button.propTypes = propTypes;
Button.defaultProps = defaultProps;

exports.default = Button;

},{"../services/Util":77,"classnames":2,"react":34}],45:[function(require,module,exports){
/**
 * ButtonDropdown component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/10/07
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.ButtonDropdown options={options} />
 *
 * Bootstrap 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    label: _react.PropTypes.string,
    dropdownTemplate: _react.PropTypes.string,
    split: _react.PropTypes.bool
};

var defaultProps = {
    className: 'btn btn-default',
    label: 'button',
    split: false
};

/** Class representing a ButtonDropdown. */

var ButtonDropdown = function (_Component) {
    _inherits(ButtonDropdown, _Component);

    function ButtonDropdown(props) {
        _classCallCheck(this, ButtonDropdown);

        // Operations usually carried out in componentWillMount go here

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ButtonDropdown).call(this, props));

        var id = props.id;
        if (typeof id === 'undefined') {
            id = _Util2.default.getUUID();
        }

        _this.id = id;
        return _this;
    }

    /**
     * @private
     */


    _createClass(ButtonDropdown, [{
        key: 'renderChildren',
        value: function renderChildren() {
            var children = this.props.children;
            // children 이 존재 하지 않는다면 데이터를 받아서 li 생성하는 것 만들어줌
            // li 태그안의 content는 template 형태로 받아서 처리 (default template은 a tag)
            // 각 아이템 클릭시 이벤트 처리도 해야 함

            return children;
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props = this.props;
            var className = _props.className;
            var label = _props.label;
            var split = _props.split;


            var btn, splitBtn;
            if (split === true) {
                btn = _react2.default.createElement(
                    'button',
                    { type: 'button', className: (0, _classnames2.default)(className) },
                    label
                );
                splitBtn = _react2.default.createElement(
                    'button',
                    { type: 'button', className: (0, _classnames2.default)(className, 'dropdown-toggle'), 'data-toggle': 'dropdown', 'aria-haspopup': 'true', 'aria-expanded': 'false' },
                    _react2.default.createElement('span', { className: 'caret' }),
                    _react2.default.createElement(
                        'span',
                        { className: 'sr-only' },
                        'Toggle Dropdown'
                    )
                );
            } else {
                btn = _react2.default.createElement(
                    'button',
                    { type: 'button', className: (0, _classnames2.default)(className, 'dropdown-toggle'), 'data-toggle': 'dropdown', 'aria-haspopup': 'true', 'aria-expanded': 'false' },
                    label,
                    ' ',
                    _react2.default.createElement('span', { className: 'caret' })
                );
            }

            return _react2.default.createElement(
                'div',
                { id: this.id, className: 'btn-group' },
                btn,
                splitBtn,
                _react2.default.createElement(
                    'ul',
                    { className: 'dropdown-menu' },
                    this.renderChildren()
                )
            );
        }
    }]);

    return ButtonDropdown;
}(_react.Component);

ButtonDropdown.propTypes = propTypes;
ButtonDropdown.defaultProps = defaultProps;

exports.default = ButtonDropdown;

},{"../services/Util":77,"classnames":2,"react":34}],46:[function(require,module,exports){
/**
 * CheckBox component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/03/14
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Pum.CheckBox name="name1" value="value1" onChange={this.onChange} checked={true}> 체크박스</Pum.CheckBox>
 *
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    name: _react.PropTypes.string,
    value: _react.PropTypes.string,
    checked: _react.PropTypes.bool,
    direction: _react.PropTypes.oneOf(['h', 'v']),
    onChange: _react.PropTypes.func
};

var defaultProps = {
    direction: 'v'
};

/** Class representing a Checkbox. */

var Checkbox = function (_Component) {
    _inherits(Checkbox, _Component);

    function Checkbox(props) {
        _classCallCheck(this, Checkbox);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Checkbox).call(this, props));

        _this.state = _this.__setStateObject(props);

        // Operations usually carried out in componentWillMount go here
        var id = props.id;
        if (typeof id === 'undefined') {
            id = _Util2.default.getUUID();
        }

        _this.id = id;

        // Manually bind this method to the component instance...
        _this.onChange = _this.onChange.bind(_this);
        return _this;
    }

    _createClass(Checkbox, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$checkbox = $('input:checkbox[name="' + this.props.name + '"]');

            if (this.props.direction === 'h') {
                var $div = $('#' + this.id),
                    $label = $div.children();
                $label.addClass('checkbox-inline');
                $div.replaceWith($label);
            }

            this.__setValue();
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            // 컴포넌트가 새로운 props를 받을 때 호출(최초 렌더링 시에는 호출되지 않음)
            this.setState(this.__setStateObject(nextProps));
        }
    }, {
        key: 'componentDidUpdate',
        value: function componentDidUpdate(prevProps, prevState) {
            // 컴포넌트의 업데이트가 DOM에 반영된 직후에 호출(최초 렌더링 시에는 호출되지 않음)
            //console.log(prevProps);
            //console.log(prevState);
            //console.log(this.state);
            this.__setValue();
        }

        /**
         * @private
         */

    }, {
        key: '__setStateObject',
        value: function __setStateObject(props) {
            //let value = props.value;
            //if(typeof value === 'undefined') {
            //    value = null;
            //}

            var checked = props.checked;
            if (typeof checked === 'undefined') {
                checked = false;
            }

            return {
                //value: value,
                checked: checked
            };
        }

        /**
         * @private
         */

    }, {
        key: '__setValue',
        value: function __setValue() {
            var checked = this.state.checked; /*,
                                              $checkbox = $('input:checkbox[name="' + this.props.name + '"]');*/
            if (typeof this.props.value === 'undefined') {
                // true/false 설정
                this.$checkbox.val(checked);
            } else {
                if (checked === true) {
                    this.$checkbox.val(this.props.value);
                } else {
                    this.$checkbox.val(null);
                }
            }
        }

        //-----------------------------
        // events

    }, {
        key: 'onChange',
        value: function onChange(e) {
            //console.log(e);
            var checked = !this.state.checked;
            //console.log(checked);
            this.setState({ checked: checked });
            if (typeof this.props.onChange === 'function') {
                this.props.onChange(e, checked, this.$checkbox.val());
            }
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props = this.props;
            var className = _props.className;
            var name = _props.name;
            var children = _props.children;

            return _react2.default.createElement(
                'div',
                { className: 'checkbox', id: this.id },
                _react2.default.createElement(
                    'label',
                    null,
                    _react2.default.createElement('input', { type: 'checkbox', className: className, name: name, checked: this.state.checked,
                        onChange: this.onChange }),
                    _react2.default.createElement(
                        'span',
                        { className: 'lbl' },
                        children
                    )
                )
            );
        }
    }]);

    return Checkbox;
}(_react.Component);

Checkbox.propTypes = propTypes;
Checkbox.defaultProps = defaultProps;

exports.default = Checkbox;

},{"../services/Util":77,"classnames":2,"react":34}],47:[function(require,module,exports){
/**
 * Fieldset component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/03/30
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Pum.Fieldset />
 *
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    legend: _react.PropTypes.string,
    expand: _react.PropTypes.bool,
    collapsible: _react.PropTypes.bool,
    onToggle: _react.PropTypes.func,
    onInit: _react.PropTypes.func
};

var defaultProps = {
    legend: 'Title',
    collapsible: true,
    expand: true
};

/** Class representing a Fieldset. */

var Fieldset = function (_Component) {
    _inherits(Fieldset, _Component);

    function Fieldset(props) {
        _classCallCheck(this, Fieldset);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Fieldset).call(this, props));

        _this.state = {
            expand: props.expand
        };

        // Operations usually carried out in componentWillMount go here
        var id = props.id;
        if (typeof id === 'undefined') {
            id = _Util2.default.getUUID();
        }

        _this.id = id;

        // Manually bind this method to the component instance...
        _this.onToggle = _this.onToggle.bind(_this);
        return _this;
    }

    // componentDidMount() {
    //     // 최초 렌더링이 일어난 다음(한번 호출)
    //     if(typeof this.props.onInit === 'function') {
    //         var data = {};
    //         data.expand = this.state.expand;
    //         this.props.onInit(data);
    //     }
    // }

    _createClass(Fieldset, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            // 컴포넌트가 새로운 props를 받을 때 호출(최초 렌더링 시에는 호출되지 않음)
            this.toggle(nextProps);
        }

        /**
         * @private
         */

    }, {
        key: 'toggle',
        value: function toggle(props) {
            if (this.props.collapsible === true) {
                if (typeof props.expand !== 'undefined') {
                    this.setState({ expand: props.expand });
                } else {
                    this.setState({ expand: true });
                }
            }
        }

        //-----------------------------
        // events

    }, {
        key: 'onToggle',
        value: function onToggle(event) {
            var expand = !this.state.expand;
            this.toggle({ expand: expand });

            if (typeof this.props.onToggle === 'function') {
                this.props.onToggle(expand);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props = this.props;
            var className = _props.className;
            var legend = _props.legend;
            var collapsible = _props.collapsible;


            var display,
                collapsed = false;
            if (this.state.expand === true) {
                display = 'block';
            } else {
                display = 'none';
                if (collapsible === true) {
                    collapsed = true;
                }
            }

            return _react2.default.createElement(
                'fieldset',
                { className: (0, _classnames2.default)('fieldset', className, { collapsible: collapsible, collapsed: collapsed }) },
                _react2.default.createElement(
                    'legend',
                    { onClick: this.onToggle, name: this.id },
                    ' ',
                    legend
                ),
                _react2.default.createElement(
                    'div',
                    { style: { display: display } },
                    _react2.default.createElement(
                        'div',
                        { id: this.id },
                        this.props.children
                    )
                )
            );
        }
    }]);

    return Fieldset;
}(_react.Component);

Fieldset.propTypes = propTypes;
Fieldset.defaultProps = defaultProps;

exports.default = Fieldset;

},{"../services/Util":77,"classnames":2,"react":34}],48:[function(require,module,exports){
/**
 * FineUploader component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/09/27
 * author <a href="mailto:jyt@nkia.co.kr">Jung Young-Tai</a>
 *
 * example:
 * <Puf.FineUploader options={options} />
 *
 * FineUploader 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    host: _react.PropTypes.string, // 서버 정보(Cross Browser Access)
    sessionUrl: _react.PropTypes.string, // 업로드된 초기 파일 Get Url
    uploadUrl: _react.PropTypes.string, // 파일 업로드 URL
    deleteUrl: _react.PropTypes.string, // 파일 삭제 URL
    params: _react.PropTypes.object, // 파일 업로드 파라미터
    sessionParams: _react.PropTypes.object, // 업로드된 초기 파일 Session Parameter
    autoUpload: _react.PropTypes.bool, // Auto Upload
    multiple: _react.PropTypes.bool, // 첨부파일 여러개 등록(선택) 가능 여부
    uploadedFileList: _react.PropTypes.array, // 업로드 파일 목록
    allowedExtensions: _react.PropTypes.array, // 첨부파일 허용확장자
    itemLimit: _react.PropTypes.number, // 첨부파일 수 제한
    sizeLimit: _react.PropTypes.number, // 첨부파일 사이즈 제한
    emptyError: _react.PropTypes.string,
    noFilesError: _react.PropTypes.string,
    sizeError: _react.PropTypes.string,
    tooManyItemsError: _react.PropTypes.string,
    typeError: _react.PropTypes.string,
    onDelete: _react.PropTypes.func,
    onDeleteComplete: _react.PropTypes.func,
    onComplete: _react.PropTypes.func,
    onError: _react.PropTypes.func,
    onSessionRequestComplete: _react.PropTypes.func
};

var defaultProps = {
    autoUpload: true,
    multiple: true,
    params: {},
    uploadedFileList: [],
    allowedExtensions: [],
    itemLimit: 0,
    sizeLimit: 0,
    emptyError: '0kb의 잘못된 파일입니다.',
    noFilesError: '첨부된 파일이 없습니다.',
    sizeError: '{file} is too large, maximum file size is {sizeLimit}!!.',
    tooManyItemsError: 'Too many items ({netItems}) would be uploaded. Item limit is {itemLimit}!!.',
    typeError: '{file} has an invalid extension. Valid extension(s): {extensions}.!!'
};

/** Class representing a FineUploader. */

var FineUploader = function (_Component) {
    _inherits(FineUploader, _Component);

    function FineUploader(props) {
        _classCallCheck(this, FineUploader);

        // Operations usually carried out in componentWillMount go here

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(FineUploader).call(this, props));

        var id = props.id;
        if (typeof id === 'undefined') {
            id = _Util2.default.getUUID();
        }

        _this2.id = id;
        return _this2;
    }

    _createClass(FineUploader, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$fineUploader = $('#' + this.id)[0];
            var settings = {
                element: this.$fineUploader
            };
            $.extend(settings, this.options(this.props));
            this.fineUploader = new qq.FineUploader(settings);
        }
    }, {
        key: 'options',
        value: function options(props) {
            var _this = this;
            var host = props.host;
            var sessionUrl = props.sessionUrl;
            var uploadUrl = props.uploadUrl;
            var deleteUrl = props.deleteUrl;
            var autoUpload = props.autoUpload;
            var multiple = props.multiple;
            var params = props.params;
            var sessionParams = props.sessionParams;
            var uploadedFileList = props.uploadedFileList;
            var allowedExtensions = props.allowedExtensions;
            var itemLimit = props.itemLimit;
            var sizeLimit = props.sizeLimit;
            var emptyError = props.emptyError;
            var noFilesError = props.noFilesError;
            var sizeError = props.sizeError;
            var tooManyItemsError = props.tooManyItemsError;
            var typeError = props.typeError;
            var _onDelete = props.onDelete;
            var _onDeleteComplete = props.onDeleteComplete;
            var _onComplete = props.onComplete;
            var _onError = props.onError;
            var _onSessionRequestComplete = props.onSessionRequestComplete;

            var options = {
                autoUpload: autoUpload,
                multiple: multiple,
                request: {
                    endpoint: host && host !== null && host.length > 0 ? host + uploadUrl : uploadUrl,
                    params: params
                },
                validation: {
                    allowedExtensions: allowedExtensions,
                    itemLimit: itemLimit,
                    sizeLimit: sizeLimit,
                    tooManyItemsError: tooManyItemsError,
                    typeError: typeError
                },
                messages: {
                    emptyError: emptyError,
                    noFilesError: noFilesError,
                    sizeError: sizeError
                },
                session: {
                    endpoint: host && host !== null && host.length > 0 ? host + sessionUrl : sessionUrl,
                    refreshOnRequest: true
                },
                deleteFile: {
                    enabled: true,
                    method: 'POST',
                    endpoint: host && host !== null && host.length > 0 ? host + deleteUrl : deleteUrl
                },
                callbacks: {
                    onDelete: function onDelete(id) {
                        if (typeof _onDelete === 'function') {
                            _onDelete(id);
                        }
                    },
                    // 삭제 버튼 클릭시 Event
                    onSubmitDelete: function onSubmitDelete(id) {
                        _this.fineUploader.setDeleteFileParams({ filename: _this.fineUploader.getName(id) }, id);
                    },
                    // 삭제 완료시 Event
                    onDeleteComplete: function onDeleteComplete(id, xhr, isError) {
                        if (xhr.responseText) {
                            (function () {
                                var response = JSON.parse(xhr.responseText);
                                if ("file_name" in response) {
                                    uploadedFileList.some(function (fileName, idx) {
                                        if (fileName == response.file_name) {
                                            return uploadedFileList.splice(idx, 1);
                                        }
                                    });
                                }
                            })();
                        }
                        if (typeof _onDeleteComplete === 'function') {
                            _onDeleteComplete(id, xhr, isError);
                        }
                    },
                    // 업로드 완료시 Event
                    onComplete: function onComplete(id, name, response, xhr) {
                        if ("file_name" in response) {
                            _this.fineUploader.setUuid(id, response.file_name);
                            uploadedFileList.push(response.file_name);
                        }
                        if (typeof _onComplete === 'function') {
                            _onComplete(id, name, response, xhr);
                        }
                    },
                    // Error 발생 이벤트
                    onError: function onError(id, name, errorReason, xhr) {
                        if (typeof _onError === 'function') {
                            _onError(id, name, errorReason, xhr);
                        }
                    },
                    // 초기 File 목록 요청 완료시
                    onSessionRequestComplete: function onSessionRequestComplete(response, success, xhr) {
                        if (typeof _onSessionRequestComplete === 'function') {
                            _onSessionRequestComplete(response, success, xhr, this);
                        }
                    }
                }
            };

            if (host && host !== null && host.length > 0) {
                $.extend(options, { cors: {
                        //all requests are expected to be cross-domain requests
                        expected: true
                        //if you want cookies to be sent along with the request
                        //sendCredentials: true
                    } });
            }

            return options;
        }

        //-----------------------------
        // methods
        // 첨부파일 업로드 Function

    }, {
        key: 'uploadFiles',
        value: function uploadFiles() {
            this.fineUploader.uploadStoredFiles();
        }

        // 첨부파일 초기화 및 데이터 로드

    }, {
        key: 'refreshSession',
        value: function refreshSession(sessionParams) {
            this.fineUploader.clearStoredFiles();
            this.fineUploader._session = null;
            this.fineUploader._options.session.params = sessionParams;
            this.fineUploader.reset();
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            return _react2.default.createElement(
                'div',
                null,
                _react2.default.createElement('div', { id: this.id })
            );
        }
    }]);

    return FineUploader;
}(_react.Component);

FineUploader.propTypes = propTypes;
FineUploader.defaultProps = defaultProps;

exports.default = FineUploader;

},{"../services/Util":77,"classnames":2,"react":34}],49:[function(require,module,exports){
/**
 * HiddenContent component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/03/10
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Pum.HiddenContent id={id} />
 *
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    expandLabel: _react.PropTypes.string,
    collapseLabel: _react.PropTypes.string,
    expandIcon: _react.PropTypes.string,
    collapseIcon: _react.PropTypes.string,
    isBottom: _react.PropTypes.bool
};

var defaultProps = {};

/** Class representing a HiddenContent. */

var HiddenContent = function (_Component) {
    _inherits(HiddenContent, _Component);

    function HiddenContent(props) {
        _classCallCheck(this, HiddenContent);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(HiddenContent).call(this, props));

        var label = props.expandLabel;
        if (typeof label === 'undefined') {
            label = 'Expand';
        }
        var icon = props.expandIcon;
        _this.state = {
            label: label,
            icon: icon
        };

        // Operations usually carried out in componentWillMount go here
        var id = props.id;
        if (typeof id === 'undefined') {
            id = _Util2.default.getUUID();
        }

        _this.id = id;

        // Manually bind this method to the component instance...
        _this.onExpandCollapse = _this.onExpandCollapse.bind(_this);
        _this.onBottomCollapse = _this.onBottomCollapse.bind(_this);
        return _this;
    }

    //-----------------------------
    // events


    _createClass(HiddenContent, [{
        key: 'onExpandCollapse',
        value: function onExpandCollapse(e) {
            //var node = e.target,
            //    aTag = node.parentNode;
            var aTag = e.target;
            if ($(aTag).next().css('display') === 'none') {
                this.setState({ label: this.props.collapseLabel, icon: this.props.collapseIcon });
                $(aTag).next().css('display', 'block');
            } else {
                this.setState({ label: this.props.expandLabel, icon: this.props.expandIcon });
                $(aTag).next().css('display', 'none');
            }
        }
    }, {
        key: 'onBottomCollapse',
        value: function onBottomCollapse(e) {
            var node = e.target,
                div = node.parentNode; //.parentNode;
            $(div).css('display', 'none');
            this.setState({ label: this.props.expandLabel, icon: this.props.expandIcon });
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var Icon;
            if (typeof this.state.icon === 'string') {
                Icon = _react2.default.createElement(
                    'i',
                    { className: this.state.icon },
                    ' '
                );
            }

            // 맨 아래 접기버튼 처리
            var BottomButton;
            if (this.props.isBottom === true) {
                var CollapseIcon = void 0;
                if (typeof this.props.collapseIcon === 'string') {
                    CollapseIcon = _react2.default.createElement(
                        'i',
                        { className: this.props.collapseIcon },
                        ' '
                    );
                }

                // # 와 react-router 충돌문제 해결해야 함
                BottomButton = _react2.default.createElement(
                    'a',
                    { href: '#' + this.id, onClick: this.onBottomCollapse },
                    CollapseIcon,
                    this.props.collapseLabel
                );
            }

            return _react2.default.createElement(
                'div',
                { className: (0, _classnames2.default)('hidden-content', this.props.className) },
                _react2.default.createElement(
                    'a',
                    { href: 'javascript:void(0)', onClick: this.onExpandCollapse, name: this.id },
                    Icon,
                    this.state.label
                ),
                _react2.default.createElement(
                    'div',
                    { style: { display: 'none' } },
                    _react2.default.createElement(
                        'div',
                        { id: this.id },
                        this.props.children
                    ),
                    BottomButton
                )
            );
        }
    }]);

    return HiddenContent;
}(_react.Component);

HiddenContent.propTypes = propTypes;
HiddenContent.defaultProps = defaultProps;

exports.default = HiddenContent;

},{"../services/Util":77,"classnames":2,"react":34}],50:[function(require,module,exports){
/**
 * Splitter component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/03/03
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.Splitter />
 *
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    type: _react.PropTypes.oneOf(['h', 'v']).isRequired,
    position: _react.PropTypes.oneOf(['left', 'right', 'top', 'bottom']).isRequired,
    //leftPane: PropTypes.string,
    //rightPane: PropTypes.string,
    minLeft: _react.PropTypes.number.isRequired,
    minRight: _react.PropTypes.number.isRequired,
    maxLeft: _react.PropTypes.number.isRequired,
    maxRight: _react.PropTypes.number.isRequired,
    resizable: _react.PropTypes.bool,
    hidden: _react.PropTypes.bool,
    onResize: _react.PropTypes.func
};

var defaultProps = {
    type: 'h',
    position: 'left',
    minLeft: 50,
    minRight: 50,
    maxLeft: 500,
    maxRight: 500,
    resizable: true
};

/** Class representing a MainFrameSplitter. */

var MainFrameSplitter = function (_Component) {
    _inherits(MainFrameSplitter, _Component);

    function MainFrameSplitter(props) {
        _classCallCheck(this, MainFrameSplitter);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(MainFrameSplitter).call(this, props));

        _this2.state = {
            expand: true
        };

        _this2.splitterActiveFlag = false;
        _this2.splitterObj = false;

        // Manually bind this method to the component instance...
        _this2.onResize = _this2.onResize.bind(_this2);

        _this2.splitterMouseUp = _this2.splitterMouseUp.bind(_this2);
        _this2.splitterMouseDown = _this2.splitterMouseDown.bind(_this2);
        _this2.splitterMouseMove = _this2.splitterMouseMove.bind(_this2);
        _this2.expandCollapse = _this2.expandCollapse.bind(_this2);
        _this2.resizeSplitterPos = _this2.resizeSplitterPos.bind(_this2);
        return _this2;
    }

    _createClass(MainFrameSplitter, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            // 최초 렌더링이 일어나기 직전(한번 호출)
            var id = this.props.id;
            if (typeof id === 'undefined') {
                id = _Util2.default.getUUID();
            }

            this.id = id;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$splitter = $('#' + this.id);

            if (this.props.resizable === false) {
                this.$splitter.css('cursor', 'default');
            }

            if (typeof this.props.hidden === 'boolean') {
                this.visible(!this.props.hidden);
            }

            // Events
            this.$splitter.on('resize', this.onResize);

            var _this = this;
            $(window).on('resize', function (e) {
                // splitter에서 발생시키는 resize 이벤트와 구별
                if (e.target === this) {
                    //_this.resizeSplitterPos();
                    // splitterOpen/splitterClose 함수 실행과 시간차를 두어야 적용됨
                    setTimeout(_this.resizeSplitterPos, 1);
                }
            });
        }

        //-----------------------------
        // events

    }, {
        key: 'onResize',
        value: function onResize(e) {
            if (this.props.onResize) {
                this.props.onResize(e);
            }
        }

        //-----------------------------
        // methods

    }, {
        key: 'open',
        value: function open() {
            this.splitterOpen();
        }
    }, {
        key: 'close',
        value: function close() {
            var _props = this.props;
            var type = _props.type;
            var position = _props.position;


            this.splitterClose();
            if (type === 'h') {

                if (position === 'left') {
                    this.$splitter.next().offset({ left: 0 });
                } else if (position === 'right') {
                    this.$splitter.prev().css('right', 0);
                }
            }
        }
    }, {
        key: 'visible',
        value: function visible(isBool) {
            if (isBool === false) {
                this.$splitter.css('display', 'none');
            } else {
                this.$splitter.css('display', '');
            }
        }

        //-----------------------------
        // private
        // splitterActiveFlag: false,
        // splitterObj: false,

    }, {
        key: 'splitterMouseDown',
        value: function splitterMouseDown(e) {
            if (!this.splitterActiveFlag && this.state.expand === true && this.props.resizable === true) {
                // document.getElementById(this.id)
                if (this.$splitter[0].setCapture) {
                    this.$splitter[0].setCapture();
                } else {
                    document.addEventListener('mouseup', this.splitterMouseUp, true);
                    document.addEventListener('mousemove', this.splitterMouseMove, true);
                    e.preventDefault();
                }
                this.splitterActiveFlag = true;
                this.splitterObj = this.$splitter[0];

                //leftsidebarCollapseWidth = $('.leftsidebar-collapse').outerWidth(true);
                this.splitterWidth = this.$splitter.outerWidth(true);

                /*splitterParentObj = b.parentElement;
                 console.log(splitterObj.offsetLeft);
                 console.log(splitterObj.parentElement.offsetLeft);*/
            }
        }
    }, {
        key: 'splitterMouseUp',
        value: function splitterMouseUp(e) {
            if (this.splitterActiveFlag) {
                //        var a = document.getElementById("toc");
                //        var c = document.getElementById("content");
                //        changeQSearchboxWidth();
                //        a.style.width = (splitterObj.offsetLeft - 20) + "px";
                //        c.style.left = (splitterObj.offsetLeft + 10) + "px";

                var _props2 = this.props;
                var type = _props2.type;
                var position = _props2.position;


                if (type === 'h') {
                    if (position === 'left') {
                        this.$splitter.prev().outerWidth(this.splitterObj.offsetLeft);
                        this.$splitter.next().offset({ left: this.splitterObj.offsetLeft + this.splitterWidth });
                    } else if (position === 'right') {
                        this.hRightSplitterOffsetRight = this.$splitter.parent().outerWidth(true) - this.splitterObj.offsetLeft;
                        this.$splitter.prev().css('right', this.hRightSplitterOffsetRight);
                        this.$splitter.next().outerWidth(this.hRightSplitterOffsetRight - this.splitterWidth);

                        //this.$splitter.prev().offset({ right: this.splitterObj.offsetRight });
                        //this.$splitter.next().outerWidth(this.splitterObj.offsetRight - this.splitterWidth);
                    }
                }

                if (this.splitterObj.releaseCapture) {
                    this.splitterObj.releaseCapture();
                } else {
                    document.removeEventListener('mouseup', this.splitterMouseUp, true);
                    document.removeEventListener('mousemove', this.splitterMouseMove, true);
                    e.preventDefault();
                }
                this.splitterActiveFlag = false;
                this.saveSplitterPos();
                //this.onResize();
                this.$splitter.trigger('resize');
            }
        }
    }, {
        key: 'splitterMouseMove',
        value: function splitterMouseMove(e) {
            var _props3 = this.props;
            var type = _props3.type;
            var position = _props3.position;
            var minLeft = _props3.minLeft;
            var minRight = _props3.minRight;
            var maxLeft = _props3.maxLeft;
            var maxRight = _props3.maxRight;


            if (this.splitterActiveFlag) {
                if (type === 'h') {
                    if (position === 'left') {
                        if (e.clientX >= minLeft && e.clientX <= maxLeft) {
                            this.splitterObj.style.left = e.clientX + 'px';
                            if (!this.splitterObj.releaseCapture) {
                                e.preventDefault();
                            }
                        }
                    } else if (position === 'right') {
                        if (e.clientX <= document.documentElement.clientWidth - minRight && e.clientX >= document.documentElement.clientWidth - maxRight) {
                            this.splitterObj.style.left = e.clientX + 'px';
                            if (!this.splitterObj.releaseCapture) {
                                e.preventDefault();
                            }
                        }
                    }
                }
                /*
                if (e.clientX >= this.props.minLeft && e.clientX <= document.documentElement.clientWidth - this.props.minRight) {
                    this.splitterObj.style.left = e.clientX + 'px';
                    if(!this.splitterObj.releaseCapture) {
                        e.preventDefault();
                    }
                }
                */
            }
        }
    }, {
        key: 'splitterOpen',
        value: function splitterOpen() {
            var _props4 = this.props;
            var type = _props4.type;
            var position = _props4.position;


            if (type === 'h') {
                if (position === 'left') {
                    this.$splitter.prev().offset({ left: 0 });
                    this.$splitter.offset({ left: this.leftFrameWidth });
                    this.$splitter.next().offset({ left: this.leftFrameWidth + this.splitterWidth });
                } else if (position === 'right') {
                    this.$splitter.prev().css('right', this.rightFrameWidth + this.splitterWidth);
                    this.$splitter.offset({ left: this.$splitter.parent().outerWidth(true) - this.rightFrameWidth - this.splitterWidth });
                    this.$splitter.next().outerWidth(this.rightFrameWidth);
                }
            }

            this.$splitter.css('cursor', 'e-resize');

            /*
             this.$splitter.prev().on('webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend', function(e) {
                this.$splitter.css('display', 'block');
            });
            */
            this.setState({ expand: true });
            this.$splitter.trigger('resize');
        }
    }, {
        key: 'splitterClose',
        value: function splitterClose() {
            var _props5 = this.props;
            var type = _props5.type;
            var position = _props5.position;


            if (type === 'h') {
                this.splitterWidth = this.$splitter.outerWidth(true);

                if (position === 'left') {
                    this.leftFrameWidth = this.$splitter.prev().outerWidth(true);

                    this.$splitter.prev().offset({ left: this.leftFrameWidth * -1 });
                    this.$splitter.offset({ left: 0 });
                    this.$splitter.next().offset({ left: this.splitterWidth });
                } else if (position === 'right') {
                    this.rightFrameWidth = this.$splitter.next().outerWidth(true);

                    this.$splitter.prev().css('right', this.splitterWidth);
                    this.$splitter.offset({ left: this.$splitter.parent().outerWidth(true) - this.splitterWidth });
                    this.$splitter.next().outerWidth(0);
                }
            }

            this.$splitter.css('cursor', 'default');
            //this.$splitter.prev().off('webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend');
            this.setState({ expand: false });
            this.$splitter.trigger('resize');
        }
    }, {
        key: 'expandCollapse',
        value: function expandCollapse(e) {

            if (this.state.expand === true) {
                this.splitterClose();
            } else {
                this.splitterOpen();
            }
        }
    }, {
        key: 'saveSplitterPos',
        value: function saveSplitterPos() {
            var _props6 = this.props;
            var type = _props6.type;
            var position = _props6.position;

            var a = this.$splitter[0]; //document.getElementById(this.id);
            if (a) {
                if (type === 'h') {
                    if (position === 'left') {
                        _Util2.default.setCookie('hsplitterLeftPosition', a.offsetLeft, 365);
                    } else if (position === 'right') {
                        _Util2.default.setCookie('hsplitterRightPosition', this.hRightSplitterOffsetRight, 365);
                    }
                }
            }
        }
    }, {
        key: 'resizeSplitterPos',
        value: function resizeSplitterPos() {
            var _props7 = this.props;
            var type = _props7.type;
            var position = _props7.position;

            if (type === 'h') {
                if (position === 'right') {
                    var rightFrameWidth = 0;
                    if (this.state.expand === true) {
                        rightFrameWidth = this.$splitter.next().outerWidth(true);
                    }
                    this.$splitter.offset({ left: this.$splitter.parent().outerWidth(true) - rightFrameWidth - this.splitterWidth });
                }
            }
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props8 = this.props;
            var className = _props8.className;
            var type = _props8.type;
            var position = _props8.position;
            var resizable = _props8.resizable;


            var h = true;
            if (type !== 'h') {
                h = false;
            }

            var l = true;
            if (position !== 'left') {
                l = false;
            }

            var display = 'block';
            if (!this.state.expand || !resizable) {
                display = 'none';
            }

            return _react2.default.createElement(
                'div',
                { id: this.id, className: (0, _classnames2.default)({ 'mainframe-splitter': true, 'h-splitter': h, 'v-splitter': !h, 'left-splitter': l, 'right-splitter': !l }, className),
                    onMouseDown: this.splitterMouseDown, onMouseUp: this.splitterMouseUp, onMouseMove: this.splitterMouseMove },
                _react2.default.createElement('div', { className: (0, _classnames2.default)({ 'splitter-collapse': this.state.expand, 'splitter-expand': !this.state.expand }), onClick: this.expandCollapse }),
                _react2.default.createElement('div', { className: 'splitter-resize-handle', style: { display: display } })
            );
        }
    }]);

    return MainFrameSplitter;
}(_react.Component);

MainFrameSplitter.propTypes = propTypes;
MainFrameSplitter.defaultProps = defaultProps;

exports.default = MainFrameSplitter;

},{"../services/Util":77,"classnames":2,"react":34}],51:[function(require,module,exports){
/**
 * Modal component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/03/25
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.Modal ref="modal" width="700px">
 *   <Puf.ModalHeader>Modal Title</Puf.ModalHeader>
 *   <Puf.ModalBody>Modal Body</Puf.ModalBody>
 *   <Puf.ModalFooter>Modal Footer</Puf.ModalFooter>
 * </Puf.Modal>
 *
 * bootstrap component
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ModalFooter = exports.ModalBody = exports.ModalHeader = exports.Modal = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypesModalHeader = {
    className: _react.PropTypes.string
};

/** Class representing a ModalHeader. */

var ModalHeader = function (_Component) {
    _inherits(ModalHeader, _Component);

    function ModalHeader(props) {
        _classCallCheck(this, ModalHeader);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(ModalHeader).call(this, props));
    }

    _createClass(ModalHeader, [{
        key: 'render',
        value: function render() {
            // 필수 항목
            return _react2.default.createElement(
                'div',
                { className: (0, _classnames2.default)('modal-header', this.props.className) },
                _react2.default.createElement(
                    'button',
                    { type: 'button', className: 'close', 'data-dismiss': 'modal' },
                    _react2.default.createElement(
                        'span',
                        { 'aria-hidden': 'true' },
                        '×'
                    ),
                    _react2.default.createElement(
                        'span',
                        { className: 'sr-only' },
                        'Close'
                    )
                ),
                _react2.default.createElement(
                    'span',
                    { className: 'modal-title' },
                    this.props.children
                )
            );
        }
    }]);

    return ModalHeader;
}(_react.Component);

var propTypesModalBody = {
    className: _react.PropTypes.string
};

/** Class representing a ModalBody. */

var ModalBody = function (_Component2) {
    _inherits(ModalBody, _Component2);

    function ModalBody(props) {
        _classCallCheck(this, ModalBody);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(ModalBody).call(this, props));
    }

    _createClass(ModalBody, [{
        key: 'render',
        value: function render() {
            // 필수 항목
            return _react2.default.createElement(
                'div',
                { className: (0, _classnames2.default)('modal-body', this.props.className) },
                this.props.children
            );
        }
    }]);

    return ModalBody;
}(_react.Component);

var propTypesModalFooter = {
    className: _react.PropTypes.string
};

/** Class representing a ModalFooter. */

var ModalFooter = function (_Component3) {
    _inherits(ModalFooter, _Component3);

    function ModalFooter(props) {
        _classCallCheck(this, ModalFooter);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(ModalFooter).call(this, props));
    }

    _createClass(ModalFooter, [{
        key: 'render',
        value: function render() {
            // 필수 항목
            return _react2.default.createElement(
                'div',
                { className: (0, _classnames2.default)('modal-footer', this.props.className) },
                this.props.children
            );
        }
    }]);

    return ModalFooter;
}(_react.Component);

var propTypesModal = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    width: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
    backdrop: _react.PropTypes.bool,
    onShow: _react.PropTypes.func,
    onHide: _react.PropTypes.func
};

var defaultPropsModal = {
    backdrop: false
};

/** Class representing a Modal. */

var Modal = function (_Component4) {
    _inherits(Modal, _Component4);

    function Modal(props) {
        _classCallCheck(this, Modal);

        // Manually bind this method to the component instance...

        var _this4 = _possibleConstructorReturn(this, Object.getPrototypeOf(Modal).call(this, props));

        _this4.onShow = _this4.onShow.bind(_this4);
        _this4.onHide = _this4.onHide.bind(_this4);
        return _this4;
    }

    _createClass(Modal, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            // 최초 렌더링이 일어나기 직전(한번 호출)
            var id = this.props.id;
            if (typeof id === 'undefined') {
                id = _Util2.default.getUUID();
            }

            this.id = id;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$modal = $('#' + this.id);
            if (this.props.backdrop === false) {
                this.$modal.attr('data-backdrop', 'static');
                this.$modal.attr('data-keyboard', false);
            }

            // Events
            this.$modal.on('shown.bs.modal', this.onShow);
            this.$modal.on('hidden.bs.modal', this.onHide);
        }

        //-----------------------------
        // events

    }, {
        key: 'onShow',
        value: function onShow(event) {
            if (typeof this.props.onShow === 'function') {
                this.props.onShow(event);
                //event.stopImmediatePropagation();
            }
        }
    }, {
        key: 'onHide',
        value: function onHide(event) {
            if (typeof this.props.onHide === 'function') {
                this.props.onHide(event);
                //event.stopImmediatePropagation();
            }
        }

        //-----------------------------
        // methods

    }, {
        key: 'show',
        value: function show() {
            this.$modal.modal('show');
            /*
            if(this.props.backdrop === true) {
                alert.modal('show');
            }else {
                alert.modal({
                    backdrop: 'static',
                    keyboard: false
                });
            }
            */
        }
    }, {
        key: 'hide',
        value: function hide() {
            this.$modal.modal('hide');
        }

        /**
         * @private
         * render function
         */

    }, {
        key: 'renderChildren',
        value: function renderChildren() {
            var children = this.props.children;

            return _react2.default.Children.map(children, function (child) {
                if (child === null) {
                    return null;
                }

                return _react2.default.cloneElement(child, {});
            });
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props = this.props;
            var className = _props.className;
            var width = _props.width;


            return _react2.default.createElement(
                'div',
                { id: this.id, className: (0, _classnames2.default)('modal', 'fade', className), role: 'dialog', 'aria-labelledby': '', 'aria-hidden': 'true' },
                _react2.default.createElement(
                    'div',
                    { className: 'modal-dialog', style: { width: width } },
                    _react2.default.createElement(
                        'div',
                        { className: 'modal-content' },
                        this.renderChildren()
                    )
                )
            );
        }
    }]);

    return Modal;
}(_react.Component);

ModalHeader.propTypes = propTypesModalHeader;
ModalBody.propTypes = propTypesModalBody;
ModalFooter.propTypes = propTypesModalFooter;
Modal.propTypes = propTypesModal;
Modal.defaultProps = defaultPropsModal;

exports.Modal = Modal;
exports.ModalHeader = ModalHeader;
exports.ModalBody = ModalBody;
exports.ModalFooter = ModalFooter;

},{"../services/Util":77,"classnames":2,"react":34}],52:[function(require,module,exports){
/**
 * Panel component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/03/30
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Pum.Panel  />
 *
 * bootstrap component
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PanelFooter = exports.PanelBody = exports.PanelHeader = exports.Panel = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypesPanelHeader = {
    width: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
    height: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number])
};

/** Class representing a PanelHeader. */

var PanelHeader = function (_Component) {
    _inherits(PanelHeader, _Component);

    function PanelHeader(props) {
        _classCallCheck(this, PanelHeader);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PanelHeader).call(this, props));

        _this.state = {
            width: props.width,
            height: props.height
        };
        return _this;
    }

    _createClass(PanelHeader, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            // 컴포넌트가 새로운 props를 받을 때 호출(최초 렌더링 시에는 호출되지 않음)
            var width = nextProps.width;
            var height = nextProps.height;

            this.setState({ width: width, height: height });
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            return _react2.default.createElement(
                'div',
                { className: 'panel-heading', style: { width: this.state.width, height: this.state.height } },
                _react2.default.createElement(
                    'div',
                    { className: 'panel-title' },
                    this.props.children
                )
            );
        }
    }]);

    return PanelHeader;
}(_react.Component);

var propTypesPanelBody = {
    width: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
    height: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number])
};

/** Class representing a PanelBody. */

var PanelBody = function (_Component2) {
    _inherits(PanelBody, _Component2);

    function PanelBody(props) {
        _classCallCheck(this, PanelBody);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(PanelBody).call(this, props));

        _this2.state = {
            width: props.width,
            height: props.height
        };
        return _this2;
    }

    _createClass(PanelBody, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            // 컴포넌트가 새로운 props를 받을 때 호출(최초 렌더링 시에는 호출되지 않음)
            var width = nextProps.width;
            var height = nextProps.height;

            this.setState({ width: width, height: height });
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            return _react2.default.createElement(
                'div',
                { className: 'panel-body', style: { width: this.state.width, height: this.state.height } },
                this.props.children
            );
        }
    }]);

    return PanelBody;
}(_react.Component);

var propTypesPanelFooter = {
    width: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
    height: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number])
};

/** Class representing a PanelFooter. */

var PanelFooter = function (_Component3) {
    _inherits(PanelFooter, _Component3);

    function PanelFooter(props) {
        _classCallCheck(this, PanelFooter);

        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(PanelFooter).call(this, props));

        _this3.state = {
            width: props.width,
            height: props.height
        };
        return _this3;
    }

    _createClass(PanelFooter, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            // 컴포넌트가 새로운 props를 받을 때 호출(최초 렌더링 시에는 호출되지 않음)
            var width = nextProps.width;
            var height = nextProps.height;

            this.setState({ width: width, height: height });
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            return _react2.default.createElement(
                'div',
                { className: 'panel-footer', style: { width: this.state.width, height: this.state.height } },
                this.props.children
            );
        }
    }]);

    return PanelFooter;
}(_react.Component);

var propTypesPanel = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string
};

var defaultPropsPanel = {
    className: 'panel-default'
};

/** Class representing a Panel. */

var Panel = function (_Component4) {
    _inherits(Panel, _Component4);

    function Panel(props) {
        _classCallCheck(this, Panel);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(Panel).call(this, props));
    }

    _createClass(Panel, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            // 최초 렌더링이 일어나기 직전(한번 호출)
            var id = this.props.id;
            if (typeof id === 'undefined') {
                id = _Util2.default.getUUID();
            }

            this.id = id;
        }

        /**
         * @private
         * render function
         */

    }, {
        key: 'renderChildren',
        value: function renderChildren() {
            var children = this.props.children;

            return _react2.default.Children.map(children, function (child) {
                if (child === null) {
                    return null;
                }

                return _react2.default.cloneElement(child, {});
            });
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var className = this.props.className;


            return _react2.default.createElement(
                'div',
                { className: (0, _classnames2.default)('panel', className) },
                this.renderChildren()
            );
        }
    }]);

    return Panel;
}(_react.Component);

PanelHeader.propTypes = propTypesPanelHeader;
PanelBody.propTypes = propTypesPanelBody;
PanelFooter.propTypes = propTypesPanelFooter;
Panel.propTypes = propTypesPanel;
Panel.defaultProps = defaultPropsPanel;

exports.Panel = Panel;
exports.PanelHeader = PanelHeader;
exports.PanelBody = PanelBody;
exports.PanelFooter = PanelFooter;

},{"../services/Util":77,"classnames":2,"react":34}],53:[function(require,module,exports){
/**
 * Temp component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/10/29
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.Button options={options} />
 *
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    className: _react.PropTypes.string,
    iconClassName: _react.PropTypes.string,
    tooltip: _react.PropTypes.string,
    tooltipPosition: _react.PropTypes.oneOf(['bottom', 'top', 'left', 'right', 'center']),
    size: _react.PropTypes.oneOf(['sm', 'md', 'lg']),
    toggled: _react.PropTypes.bool,
    disabled: _react.PropTypes.bool,
    hidden: _react.PropTypes.bool,
    value: _react.PropTypes.object,
    onClick: _react.PropTypes.func
};

var defaultProps = {
    type: 'button',
    className: 'btn-default',
    toggled: false,
    value: null,
    tooltipPosition: 'bottom'
};

/** Class representing a ToggleButton. */

var ToggleButton = function (_Component) {
    _inherits(ToggleButton, _Component);

    function ToggleButton(props) {
        _classCallCheck(this, ToggleButton);

        // toggled 설정은 init 시에만 가능

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ToggleButton).call(this, props));

        _this.state = {
            toggled: props.toggled
        };

        // this.value = props.value;

        // Manually bind this method to the component instance...
        _this.onClick = _this.onClick.bind(_this);
        return _this;
    }

    _createClass(ToggleButton, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            // 최초 렌더링이 일어나기 직전(한번 호출)
            var id = this.props.id;
            if (typeof id === 'undefined') {
                id = _Util2.default.getUUID();
            }

            this.id = id;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$toggleButton = $('#' + this.id);

            // tooltip
            // if(typeof this.props.tooltip !== 'undefined') {

            //     this.tooltip = this.$toggleButton.kendoTooltip({
            //         position: this.props.tooltipPosition
            //     }).data('kendoTooltip');

            // }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {}
        // 컴포넌트가 새로운 props를 받을 때 호출(최초 렌더링 시에는 호출되지 않음)
        // toggled 설정은 init 시에만 가능
        //this.setState({ toggled: nextProps.toggled });


        //-----------------------------
        // events

    }, {
        key: 'onClick',
        value: function onClick(e) {

            var toggled = this.toggle(),
                value = this.getValue();

            if (typeof this.props.onClick !== 'undefined') {
                this.props.onClick(e, toggled, value);
            }
        }

        //-----------------------------
        // methods

    }, {
        key: 'toggle',
        value: function toggle(isBool) {
            var toggled;
            if (arguments.length == 0) {
                toggled = !this.state.toggled;
            } else {
                toggled = isBool;
            }
            this.setState({ toggled: toggled });
            return toggled;
        }
    }, {
        key: 'isToggled',
        value: function isToggled() {
            return this.state.toggled;
        }
    }, {
        key: 'setValue',
        value: function setValue(val) {
            this.value = val;
        }
    }, {
        key: 'getValue',
        value: function getValue() {
            return this.value;
        }

        /**
         * @private
         * render function
         */

    }, {
        key: 'renderIcon',
        value: function renderIcon() {
            var iconClassName = this.props.iconClassName;

            if (iconClassName) {
                return _react2.default.createElement('i', { className: (0, _classnames2.default)('fa', iconClassName) });
            }
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props = this.props;
            var children = _props.children;
            var className = _props.className;
            var tooltip = _props.tooltip;
            var size = _props.size;
            var disabled = _props.disabled;
            var hidden = _props.hidden;
            var value = _props.value;

            // 다시 그릴때는 생성자가 호출이 안되므로

            this.value = value;

            var optional = {},
                sizeClassName;

            // size 처리
            if (typeof size === 'string') {
                sizeClassName = 'btn-' + size;
            }

            // disabled 처리
            if (disabled === true) {
                optional.disabled = true;
            }

            // hidden 처리
            if (hidden === true) {
                optional.style = { display: 'none' };
            }

            // {'\u00A0'}
            return _react2.default.createElement(
                'button',
                _extends({ id: this.id, type: 'button', className: (0, _classnames2.default)('btn', className, { toggle: this.state.toggled }, sizeClassName), onClick: this.onClick,
                    title: tooltip
                }, optional),
                this.renderIcon(),
                children
            );
        }
    }]);

    return ToggleButton;
}(_react.Component);

ToggleButton.propTypes = propTypes;
ToggleButton.defaultProps = defaultProps;

exports.default = ToggleButton;

},{"../services/Util":77,"classnames":2,"react":34}],54:[function(require,module,exports){
/**
 * Radio component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/03/17
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.Radio options="{options}" />
 *
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    name: _react.PropTypes.string,
    selectedValue: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number, _react.PropTypes.bool]),
    direction: _react.PropTypes.oneOf(['h', 'v']),
    onChange: _react.PropTypes.func,
    value: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number, _react.PropTypes.bool])
};

/** Class representing a Radio. */

var Radio = function (_Component) {
    _inherits(Radio, _Component);

    function Radio(props) {
        _classCallCheck(this, Radio);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(Radio).call(this, props));
    }

    _createClass(Radio, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            // 최초 렌더링이 일어나기 직전(한번 호출)
            var id = this.props.id;
            if (typeof id === 'undefined') {
                id = _Util2.default.getUUID();
            }

            this.id = id;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            if (this.props.direction === 'h') {
                var $div = $('#' + this.id),
                    $label = $div.children();
                $label.addClass('radio-inline');
                $div.replaceWith($label);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props = this.props;
            var className = _props.className;
            var name = _props.name;
            var selectedValue = _props.selectedValue;
            var onChange = _props.onChange;
            var value = _props.value;
            var children = _props.children;

            var optional = {};
            if (selectedValue !== undefined) {
                optional.checked = this.props.value === selectedValue;
            }
            /*
            if(typeof onChange === 'function') {
                optional.onChange = onChange.bind(null, this.props.value);
            }
            */
            optional.onChange = onChange.bind(null, this.props.value);

            return _react2.default.createElement(
                'div',
                { className: 'radio', id: this.id },
                _react2.default.createElement(
                    'label',
                    null,
                    _react2.default.createElement('input', _extends({ type: 'radio', className: className, name: name, value: value
                    }, optional)),
                    _react2.default.createElement(
                        'span',
                        { className: 'lbl' },
                        children
                    )
                )
            );
        }
    }]);

    return Radio;
}(_react.Component);

Radio.propTypes = propTypes;
// Radio.defaultProps = defaultProps;

exports.default = Radio;

},{"../../services/Util":77,"classnames":2,"react":34}],55:[function(require,module,exports){
/**
 * RadioDivider component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2017/01/05
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.RadioDivider className="radio-divider" />
 *
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// 타입체크 하는지 확인 필요
var propTypes = {
    className: _react.PropTypes.string
};

var defaultProps = {
    type: 'RadioDivider'
};

/** Class representing a RadioDivider. */
var RadioDivider = function RadioDivider(_ref) {
    var className = _ref.className;
    return _react2.default.createElement('div', { className: (0, _classnames2.default)('radio-divider', className) });
};

RadioDivider.propTypes = propTypes;
RadioDivider.defaultProps = defaultProps;

exports.default = RadioDivider;

},{"classnames":2,"react":34}],56:[function(require,module,exports){
/**
 * RadioGroup component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/03/17
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.RadioGroup options="{options}" />
 *
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    className: _react.PropTypes.string,
    name: _react.PropTypes.string,
    selectedValue: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number, _react.PropTypes.bool]),
    direction: _react.PropTypes.oneOf(['h', 'v']),
    onChange: _react.PropTypes.func
};

var defaultProps = {
    direction: 'v'
};

/** Class representing a RadioGroup. */

var RadioGroup = function (_Component) {
    _inherits(RadioGroup, _Component);

    function RadioGroup(props) {
        _classCallCheck(this, RadioGroup);

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(RadioGroup).call(this, props));

        _this.state = _this.setStateObject(props);

        // Manually bind this method to the component instance...
        _this.onChange = _this.onChange.bind(_this);
        return _this;
    }

    _createClass(RadioGroup, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            //console.log('componentDidMount');
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            // 컴포넌트가 새로운 props를 받을 때 호출(최초 렌더링 시에는 호출되지 않음)
            this.setState(this.setStateObject(nextProps));
        }

        //-----------------------------
        // events

    }, {
        key: 'onChange',
        value: function onChange(value, event) {
            this.setState({ selectedValue: value });
            if (typeof this.props.onChange === 'function') {
                this.props.onChange(event, value);
            }
        }

        /**
         * @private
         */

    }, {
        key: 'setStateObject',
        value: function setStateObject(props) {
            var selectedValue = props.selectedValue;
            if (typeof selectedValue === 'undefined') {
                selectedValue = null;
            }

            return {
                selectedValue: selectedValue
            };
        }

        /**
         * @private
         * render function
         */

    }, {
        key: 'renderChildren',
        value: function renderChildren() {
            var _props = this.props;
            var className = _props.className;
            var name = _props.name;
            var direction = _props.direction;
            var children = _props.children;
            var selectedValue = this.state.selectedValue;
            var onChange = this.onChange;

            return _react2.default.Children.map(children, function (radio) {
                if (radio === null) {
                    return null;
                }

                var _className = '',
                    props = {};
                if (radio.props.type === 'RadioDivider') {

                    if (typeof radio.props.className !== 'undefined') {
                        _className = radio.props.className;
                    }

                    props = {
                        className: _className
                    };
                } else {

                    if (typeof radio.props.className !== 'undefined') {
                        _className = className + ' ' + radio.props.className;
                    } else {
                        _className = className;
                    }

                    props = {
                        className: _className,
                        name: name,
                        selectedValue: selectedValue,
                        direction: direction,
                        onChange: onChange
                    };
                }

                return _react2.default.cloneElement(radio, props);
            });
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var className = this.props.className;


            return _react2.default.createElement(
                'div',
                { className: (0, _classnames2.default)('radio-group', className) },
                this.renderChildren()
            );
        }
    }]);

    return RadioGroup;
}(_react.Component);

RadioGroup.propTypes = propTypes;
RadioGroup.defaultProps = defaultProps;

exports.default = RadioGroup;

},{"classnames":2,"react":34}],57:[function(require,module,exports){
/**
 * AutoComplete component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/09/09
 * author <a href="mailto:jyt@nkia.co.kr">Jung Young-Tai</a>
 *
 * example:
 * <Puf.AutoComplete options={options} />
 *
 * Kendo AutoComplete 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    name: _react.PropTypes.string,
    host: _react.PropTypes.string, // 서버 정보(Cross Browser Access)
    url: _react.PropTypes.string,
    method: _react.PropTypes.string,
    data: _react.PropTypes.object,
    placeholder: _react.PropTypes.string,
    dataSource: _react.PropTypes.oneOfType([_react.PropTypes.array, _react.PropTypes.object]),
    template: _react.PropTypes.string,
    filter: _react.PropTypes.string,
    separator: _react.PropTypes.string,
    minLength: _react.PropTypes.number,
    dataTextField: _react.PropTypes.string,
    parameterMapField: _react.PropTypes.object // Parameter Control 객체(필터처리)
};

var defaultProps = {
    method: 'POST',
    listField: 'resultValue.list',
    totalField: 'resultValue.totalCount',
    placeholder: $ps_locale.autoComplete,
    filter: "startswith",
    separator: ", ",
    template: null,
    dataTextField: null,
    minLength: 1
};

/** Class representing a AutoComplete. */

var AutoComplete = function (_Component) {
    _inherits(AutoComplete, _Component);

    function AutoComplete(props) {
        _classCallCheck(this, AutoComplete);

        // Operations usually carried out in componentWillMount go here

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AutoComplete).call(this, props));

        var id = props.id;
        if (typeof id === 'undefined') {
            id = _Util2.default.getUUID();
        }

        _this.id = id;
        return _this;
    }

    _createClass(AutoComplete, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$autoComplete = $('#' + this.id);
            //console.log(this.options(this.props));
            this.autoComplete = this.$autoComplete.kendoAutoComplete(this.options(this.props));
        }

        /**
         * @private
         */

    }, {
        key: 'options',
        value: function options(props) {
            var placeholder = props.placeholder;
            var template = props.template;
            var dataTextField = props.dataTextField;
            var minLength = props.minLength;
            var separator = props.separator;

            var dataSource = this.getDataSource(props);

            var options = {
                placeholder: placeholder,
                template: template,
                dataSource: dataSource,
                dataTextField: dataTextField,
                minLength: minLength,
                separator: separator
            };
            return options;
        }

        /**
         * @private
         */

    }, {
        key: 'getDataSource',
        value: function getDataSource(props) {
            var host = props.host;
            var url = props.url;
            var method = props.method;
            var data = props.data;
            var listField = props.listField;
            var totalField = props.totalField;
            var parameterMapField = props.parameterMapField;


            var dataSource = new kendo.data.DataSource({
                transport: {
                    read: {
                        url: host && host !== null && host.length > 0 ? host + url : url,
                        type: method,
                        dataType: 'json',
                        data: data, // search (@RequestBody GridParam gridParam 로 받는다.)
                        contentType: 'application/json; charset=utf-8'
                    },
                    parameterMap: function parameterMap(data, type) {
                        if (type == "read" && parameterMapField !== null) {
                            // Filter Array => Json Object Copy
                            if (parameterMapField.filtersToJson && data.filter && data.filter.filters) {
                                var filters = data.filter.filters;
                                filters.map(function (filter) {
                                    data[parameterMapField.searchField] = filter.value;
                                });
                            }
                        }
                        return JSON.stringify(data);
                    }
                },
                schema: {
                    // returned in the "listField" field of the response
                    data: function data(response) {
                        var arr = [],
                            gridList = response;

                        if (listField && listField.length > 0 && listField != 'null') {
                            arr = listField.split('.');
                        }
                        for (var i in arr) {
                            //console.log(arr[i]);
                            if (!gridList) {
                                gridList = [];
                                break;
                            }
                            gridList = gridList[arr[i]];
                        }
                        return gridList;
                    },
                    // returned in the "totalField" field of the response
                    total: function total(response) {
                        //console.log(response);
                        var arr = [],
                            total = response;
                        if (totalField && totalField.length > 0 && totalField != 'null') {
                            arr = totalField.split('.');
                        }
                        for (var i in arr) {
                            //console.log(arr[i]);
                            if (!total) {
                                total = 0;
                                break;
                            }
                            total = total[arr[i]];
                        }
                        return total;
                    }
                },
                serverFiltering: true
            });
            return dataSource;
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var inputStyle = {
                width: "100%"
            };
            var _props = this.props;
            var name = _props.name;
            var className = _props.className;

            return _react2.default.createElement('input', { id: this.id, name: name, className: (0, _classnames2.default)(className), style: inputStyle });
        }
    }]);

    return AutoComplete;
}(_react.Component);

AutoComplete.propTypes = propTypes;
AutoComplete.defaultProps = defaultProps;

exports.default = AutoComplete;

},{"../services/Util":77,"classnames":2,"react":34}],58:[function(require,module,exports){
/**
 * DatePicker component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/06/05
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.DatePicker options={options} />
 *
 * Kendo DatePicker 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

var _DateUtil = require('../services/DateUtil');

var _DateUtil2 = _interopRequireDefault(_DateUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    name: _react.PropTypes.string,
    date: _react.PropTypes.oneOfType([_react.PropTypes.string, // YYYY-MM-DD HH:mm:ss format의 string
    _react.PropTypes.object // Date
    ]),
    min: _react.PropTypes.oneOfType([_react.PropTypes.string, // YYYY-MM-DD HH:mm:ss format의 string
    _react.PropTypes.object // Date
    ]),
    max: _react.PropTypes.oneOfType([_react.PropTypes.string, // YYYY-MM-DD HH:mm:ss format의 string
    _react.PropTypes.object // Date
    ]),
    timePicker: _react.PropTypes.bool,
    interval: _react.PropTypes.number,
    width: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
    disabled: _react.PropTypes.bool,
    readOnly: _react.PropTypes.bool,
    onChange: _react.PropTypes.func,
    onClose: _react.PropTypes.func,
    onOpen: _react.PropTypes.func,
    init: _react.PropTypes.func
};

var defaultProps = {
    disabled: false
};

/** Class representing a DatePicker. */

var DatePicker = function (_Component) {
    _inherits(DatePicker, _Component);

    function DatePicker(props) {
        _classCallCheck(this, DatePicker);

        // Operations usually carried out in componentWillMount go here

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(DatePicker).call(this, props));

        var id = props.id;
        if (typeof id === 'undefined') {
            id = _Util2.default.getUUID();
        }

        _this.id = id;

        // Manually bind this method to the component instance...
        _this.onChange = _this.onChange.bind(_this);
        _this.onClose = _this.onClose.bind(_this);
        _this.onOpen = _this.onOpen.bind(_this);
        return _this;
    }

    _createClass(DatePicker, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$datePicker = $('#' + this.id);

            if (this.props.timePicker === true) {
                this.datePicker = this.$datePicker.kendoDateTimePicker(this.options()).data('kendoDateTimePicker');
            } else {
                this.datePicker = this.$datePicker.kendoDatePicker(this.options()).data('kendoDatePicker');
            }

            // DateRangePicker 에서 data.datePicker 을 사용함
            if (typeof this.props.init === 'function') {
                var data = {};
                data.$datePicker = this.$datePicker;
                data.datePicker = this.datePicker;
                this.props.init(data);
            }

            // disabled
            if (typeof this.props.disabled !== 'undefined') {
                this.enable(!this.props.disabled);
            }

            // readOnly
            if (typeof this.props.readOnly !== 'undefined') {
                this.readOnly(this.props.readOnly);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            // 컴포넌트가 새로운 props를 받을 때 호출(최초 렌더링 시에는 호출되지 않음)
            //this.setState(this.setStateObject(nextProps));
            this.setDate(nextProps.date);

            // disabled
            if (typeof nextProps.disabled !== 'undefined') {
                this.enable(!nextProps.disabled);
            }

            // readOnly
            if (typeof nextProps.readOnly !== 'undefined') {
                this.readOnly(nextProps.readOnly);
            }
        }

        /**
         * @private
         */

    }, {
        key: 'options',
        value: function options() {
            var _props = this.props;
            var date = _props.date;
            var timePicker = _props.timePicker;
            var min = _props.min;
            var max = _props.max;


            var dateValue;
            if (typeof date === 'undefined') {
                dateValue = new Date();
            } else if (typeof date === 'string' || typeof date.getMonth === 'function') {
                dateValue = date;
            }

            var format = 'yyyy-MM-dd',
                timeOptions;
            if (timePicker === true) {
                format = 'yyyy-MM-dd HH:mm';
                timeOptions = this.getTimeOptions();
            }

            var options = {
                value: dateValue,
                format: format,
                culture: 'ko-KR', // http://docs.telerik.com/kendo-ui/framework/globalization/overview
                change: this.onChange,
                close: this.onClose,
                open: this.onOpen
            };

            $.extend(options, timeOptions);

            // min
            if (typeof min !== 'undefined') {
                $.extend(options, { min: min });
            }

            // max
            if (typeof max !== 'undefined') {
                $.extend(options, { max: max });
            }

            return options;
        }

        /**
         * @private
         */

    }, {
        key: 'getTimeOptions',
        value: function getTimeOptions() {
            var interval = this.props.interval;


            var intervalValue;
            if (typeof interval === 'undefined') {
                intervalValue = 5;
            } else {
                intervalValue = interval;
            }

            return {
                timeFormat: 'HH:mm',
                interval: intervalValue
            };
        }

        //-----------------------------
        // methods

    }, {
        key: 'open',
        value: function open() {
            this.datePicker.open();
        }
    }, {
        key: 'close',
        value: function close() {
            this.datePicker.close();
        }
    }, {
        key: 'getDate',
        value: function getDate() {
            var date = this.datePicker.value(); // Date 객체 리턴함
            //console.log(date);
            //console.log(typeof date);
            return _DateUtil2.default.getDateToString(date); // YYYY-MM-DD HH:mm:ss format의 string
        }
    }, {
        key: 'setDate',
        value: function setDate(date) {
            /*
            if(typeof date === 'undefined') {
                this.datePicker.value(new Date());
            }else if(typeof date === 'string' || typeof date.getMonth === 'function') {
                // YYYY-MM-DD HH:mm:ss format의 string
                this.datePicker.value(date);
            }
            */
            // YYYY-MM-DD HH:mm:ss format의 string
            if (typeof date === 'string' || typeof date.getMonth === 'function') {
                this.datePicker.value(date);
            }
        }
    }, {
        key: 'enable',
        value: function enable(isBool) {
            if (arguments.length == 0) {
                this.datePicker.enable();
            } else {
                this.datePicker.enable(isBool);
            }
        }
    }, {
        key: 'readOnly',
        value: function readOnly(isBool) {
            if (arguments.length == 0) {
                this.datePicker.readonly();
            } else {
                this.datePicker.readonly(isBool);
            }
        }
    }, {
        key: 'min',
        value: function min(date) {
            if (typeof date === 'string' || typeof date.getMonth === 'function') {
                this.datePicker.min(date);
            }
        }
    }, {
        key: 'max',
        value: function max(date) {
            if (typeof date === 'string' || typeof date.getMonth === 'function') {
                this.datePicker.max(date);
            }
        }

        //-----------------------------
        // events

    }, {
        key: 'onChange',
        value: function onChange(e) {
            //console.log('onChange');
            if (typeof this.props.onChange === 'function') {
                var date = this.getDate();
                this.props.onChange(date);

                //event.stopImmediatePropagation();
            }
        }
    }, {
        key: 'onClose',
        value: function onClose(e) {
            //console.log('onClose');
            //e.preventDefault(); //prevent popup closing
            if (typeof this.props.onClose === 'function') {
                this.props.onClose(e);

                //event.stopImmediatePropagation();
            }
        }
    }, {
        key: 'onOpen',
        value: function onOpen(e) {
            //console.log('onOpen');
            //e.preventDefault(); //prevent popup opening
            if (typeof this.props.onOpen === 'function') {
                this.props.onOpen(e);

                //event.stopImmediatePropagation();
            }
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props2 = this.props;
            var className = _props2.className;
            var name = _props2.name;
            var width = _props2.width;


            return _react2.default.createElement('input', { id: this.id, className: (0, _classnames2.default)(className), name: name, style: { width: width } });
        }
    }]);

    return DatePicker;
}(_react.Component);

DatePicker.propTypes = propTypes;
DatePicker.defaultProps = defaultProps;

exports.default = DatePicker;

},{"../services/DateUtil":73,"../services/Util":77,"classnames":2,"react":34}],59:[function(require,module,exports){
/**
 * DateRangePicker component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/06/05
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.DateRangePicker options={options} />
 *
 * Kendo DatePicker 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

var _DateUtil = require('../services/DateUtil');

var _DateUtil2 = _interopRequireDefault(_DateUtil);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    startName: _react.PropTypes.string,
    endName: _react.PropTypes.string,
    startDate: _react.PropTypes.oneOfType([_react.PropTypes.string, // YYYY-MM-DD HH:mm:ss format의 string
    _react.PropTypes.object // Date
    ]),
    endDate: _react.PropTypes.oneOfType([_react.PropTypes.string, // YYYY-MM-DD HH:mm:ss format의 string
    _react.PropTypes.object // Date
    ]),
    disabled: _react.PropTypes.bool,
    readOnly: _react.PropTypes.bool,
    timePicker: _react.PropTypes.bool,
    onChange: _react.PropTypes.func,
    init: _react.PropTypes.func
};

var defaultProps = {
    startName: 'startDate',
    endName: 'endDate',
    startDate: _DateUtil2.default.getLastDate(new Date(), 24),
    endDate: new Date()
};

/** Class representing a DateRangePicker. */

var DateRangePicker = function (_Component) {
    _inherits(DateRangePicker, _Component);

    function DateRangePicker(props) {
        _classCallCheck(this, DateRangePicker);

        // getInitialState (state 초기화)
        // this.state = this.setStateObject(this.props);

        // Manually bind this method to the component instance...

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(DateRangePicker).call(this, props));

        _this.onStartInit = _this.onStartInit.bind(_this);
        _this.onEndInit = _this.onEndInit.bind(_this);
        _this.onStartChange = _this.onStartChange.bind(_this);
        _this.onEndChange = _this.onEndChange.bind(_this);
        return _this;
    }

    _createClass(DateRangePicker, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            // 최초 렌더링이 일어나기 직전(한번 호출)
            var id = this.props.id;
            if (typeof id === 'undefined') {
                id = _Util2.default.getUUID();
            }

            this.id = id;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.startPicker.max(this.endPicker.value());
            this.endPicker.min(this.startPicker.value());

            if (typeof this.props.init === 'function') {
                var data = {};
                data.startPicker = this.startPicker;
                data.endPicker = this.endPicker;
                this.props.init(data);
            }
        }

        // componentWillReceiveProps(nextProps) {
        //     // 컴포넌트가 새로운 props를 받을 때 호출(최초 렌더링 시에는 호출되지 않음)
        //     this.setState(this.setStateObject(nextProps));
        // }

        // setStateObject(props) {

        //     // endDate 처리
        //     let endDate = props.endDate ? props.endDate : new Date();

        //     // startDate 처리
        //     let startDate = props.startDate ? props.startDate : DateUtil.getLastDate(endDate, 24);

        //     // disabled 처리
        //     let disabled = props.disabled;
        //     if(typeof disabled === 'undefined') {
        //         disabled = false;
        //     }

        //     return {
        //         startDate: startDate,
        //         endDate: endDate,
        //         disabled: disabled
        //     };
        // }

        //-----------------------------
        // methods

    }, {
        key: 'getStartDate',
        value: function getStartDate() {
            var isDate = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

            var date = this.startPicker.value(); // Date 객체 리턴함
            //console.log(date);
            //console.log(typeof date);
            if (isDate === true) {
                return date;
            } else {
                return _DateUtil2.default.getDateToString(date); // YYYY-MM-DD HH:mm:ss format의 string
            }
        }
    }, {
        key: 'getEndDate',
        value: function getEndDate() {
            var isDate = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];

            var date = this.endPicker.value(); // Date 객체 리턴함

            if (isDate === true) {
                return date;
            } else {
                return _DateUtil2.default.getDateToString(date); // YYYY-MM-DD HH:mm:ss format의 string
            }
        }
    }, {
        key: 'setStartDate',
        value: function setStartDate(date) {
            // YYYY-MM-DD HH:mm:ss format의 string
            if (typeof date === 'string' || typeof date.getMonth === 'function') {
                this.startPicker.value(date);
                this.onStartChange(date);
            }
        }
    }, {
        key: 'setEndDate',
        value: function setEndDate(date) {
            // YYYY-MM-DD HH:mm:ss format의 string
            if (typeof date === 'string' || typeof date.getMonth === 'function') {
                this.endPicker.value(date);
                this.onEndChange(date);
            }
        }
    }, {
        key: 'enable',
        value: function enable(isBool) {
            if (arguments.length == 0) {
                this.startPicker.enable();
                this.endPicker.enable();
            } else {
                this.startPicker.enable(isBool);
                this.endPicker.enable(isBool);
            }
        }
    }, {
        key: 'readOnly',
        value: function readOnly(isBool) {
            if (arguments.length == 0) {
                this.startPicker.readOnly();
                this.endPicker.readOnly();
            } else {
                this.startPicker.readOnly(isBool);
                this.endPicker.readOnly(isBool);
            }
        }

        //-----------------------------
        // events

    }, {
        key: 'onStartInit',
        value: function onStartInit(data) {
            this.startPicker = data.datePicker;
        }
    }, {
        key: 'onEndInit',
        value: function onEndInit(data) {
            this.endPicker = data.datePicker;
        }
    }, {
        key: 'onStartChange',
        value: function onStartChange(date) {
            this.endPicker.min(date);
            if (typeof this.props.onChange === 'function') {
                this.props.onChange(this.getStartDate(), this.getEndDate());
                //event.stopImmediatePropagation();
            }
            //var startDate = this.startPicker.value(),
            //    endDate = this.endPicker.value();
            //
            //if (startDate) {
            //    this.endPicker.min(startDate);
            //} else if (endDate) {
            //    this.startPicker.max(endDate);
            //} else {
            //    endDate = new Date();
            //    start.max(endDate);
            //    end.min(endDate);
            //}
        }
    }, {
        key: 'onEndChange',
        value: function onEndChange(date) {
            this.startPicker.max(date);
            if (typeof this.props.onChange === 'function') {
                this.props.onChange(this.getStartDate(), this.getEndDate());
                //event.stopImmediatePropagation();
            }
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props = this.props;
            var className = _props.className;
            var startName = _props.startName;
            var endName = _props.endName;
            var timePicker = _props.timePicker;
            var startDate = _props.startDate;
            var endDate = _props.endDate;
            var disabled = _props.disabled;
            var readOnly = _props.readOnly;
            // const {startDate, endDate, disabled} = this.state;

            return _react2.default.createElement(
                'div',
                { className: 'datepicker-group' },
                _react2.default.createElement(Puf.DatePicker, { className: className, name: startName, date: startDate, init: this.onStartInit, onChange: this.onStartChange,
                    timePicker: timePicker, disabled: disabled, readOnly: readOnly }),
                ' ',
                _react2.default.createElement(Puf.DatePicker, { className: className, name: endName, date: endDate, init: this.onEndInit, onChange: this.onEndChange,
                    timePicker: timePicker, disabled: disabled, readOnly: readOnly })
            );
        }
    }]);

    return DateRangePicker;
}(_react.Component);

DateRangePicker.propTypes = propTypes;
DateRangePicker.defaultProps = defaultProps;

exports.default = DateRangePicker;

},{"../services/DateUtil":73,"../services/Util":77,"classnames":2,"react":34}],60:[function(require,module,exports){
/**
 * DropDownList component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/05/03
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.DropDownList options={options} />
 *
 * Kendo DropDownList 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    name: _react.PropTypes.string,
    url: _react.PropTypes.string,
    method: _react.PropTypes.string,
    width: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
    optionLabel: _react.PropTypes.string,
    listField: _react.PropTypes.string,
    dataTextField: _react.PropTypes.string,
    dataValueField: _react.PropTypes.string,
    selectedItem: _react.PropTypes.object,
    selectedValue: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
    selectedIndex: _react.PropTypes.number,
    items: _react.PropTypes.array,
    headerTemplate: _react.PropTypes.string,
    valueTemplate: _react.PropTypes.string,
    template: _react.PropTypes.string,
    disabled: _react.PropTypes.bool,
    readOnly: _react.PropTypes.bool,
    serverFiltering: _react.PropTypes.bool,
    onSelect: _react.PropTypes.func,
    onChange: _react.PropTypes.func,
    onClose: _react.PropTypes.func,
    onOpen: _react.PropTypes.func,
    onFiltering: _react.PropTypes.func,
    onDataBound: _react.PropTypes.func,
    onLoadComplete: _react.PropTypes.func
};

var defaultProps = {
    method: 'POST',
    items: [],
    // listField: 'resultValue', listField의 초기값은 없는 것으로 한다.
    width: '100%',
    dataTextField: 'text',
    dataValueField: 'value',
    selectedIndex: 0,
    disabled: false,
    serverFiltering: false
};

/** Class representing a DropDownList. */

var DropDownList = function (_Component) {
    _inherits(DropDownList, _Component);

    function DropDownList(props) {
        _classCallCheck(this, DropDownList);

        // Operations usually carried out in componentWillMount go here
        // let id = props.id;
        // if(typeof id === 'undefined') {
        //     id = Util.getUUID();
        // }

        // this.id = id;

        // Manually bind this method to the component instance...

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(DropDownList).call(this, props));

        _this.onSelect = _this.onSelect.bind(_this);
        _this.onChange = _this.onChange.bind(_this);
        _this.onOpen = _this.onOpen.bind(_this);
        _this.onClose = _this.onClose.bind(_this);
        _this.onFiltering = _this.onFiltering.bind(_this);
        _this.onDataBound = _this.onDataBound.bind(_this);
        _this.onLoadComplete = _this.onLoadComplete.bind(_this);
        return _this;
    }

    _createClass(DropDownList, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            // 최초 렌더링이 일어나기 직전(한번 호출)
            var id = this.props.id;
            if (typeof id === 'undefined') {
                id = _Util2.default.getUUID();
            }

            this.id = id;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$dropDownList = $('#' + this.id);
            this.dropdownlist = this.$dropDownList.kendoDropDownList(this.options()).data('kendoDropDownList');

            // Events
            this.dropdownlist.bind('select', this.onSelect);
            this.dropdownlist.bind('change', this.onChange);
            this.dropdownlist.bind('open', this.onOpen);
            this.dropdownlist.bind('close', this.onClose);
            this.dropdownlist.bind('filtering', this.onFiltering);
            this.dropdownlist.bind('dataBound', this.onDataBound);

            // prevSelectedItem 설정(ajax 요청시 처리는 onLoadComplete)
            // init 시 dataItem 값을 읽어오는지 확인필요
            this.prevSelectedItem = this.dropdownlist.dataItem();

            // readOnly
            if (typeof this.props.readOnly !== 'undefined') {
                this.readOnly(this.props.readOnly);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            // 컴포넌트가 새로운 props를 받을 때 호출(최초 렌더링 시에는 호출되지 않음)
            if (typeof nextProps.selectedValue !== 'undefined') {
                this.value(nextProps.selectedValue);
            }

            if (typeof nextProps.disabled !== 'undefined') {
                this.enable(!nextProps.disabled);
            }

            if (typeof nextProps.readOnly !== 'undefined') {
                this.readOnly(nextProps.readOnly);
            }
        }
    }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps, nextState) {
            // 새로운 props나 state를 받았을 때 렌더링 전에 호출(최초 렌더링 시에는 호출되지 않음)
            // false 면 render 호출하지 않음(componentWillUpdate 와 componentDidUpdate 역시 호출되지 않음)
            return false; // default true
        }

        /**
         * @private
         */

    }, {
        key: 'options',
        value: function options() {
            var _props = this.props;
            var url = _props.url;
            var method = _props.method;
            var items = _props.items;
            var selectedIndex = _props.selectedIndex;
            var selectedValue = _props.selectedValue;
            var listField = _props.listField;
            var dataTextField = _props.dataTextField;
            var dataValueField = _props.dataValueField;
            var headerTemplate = _props.headerTemplate;
            var valueTemplate = _props.valueTemplate;
            var template = _props.template;
            var disabled = _props.disabled;
            var serverFiltering = _props.serverFiltering;


            var options = {
                index: selectedIndex,
                dataTextField: dataTextField,
                dataValueField: dataValueField,
                enable: !disabled
            };

            // dataSource
            // url
            if (typeof url !== 'undefined') {
                $.extend(options, { dataSource: {
                        transport: {
                            read: {
                                url: url,
                                type: method,
                                dataType: 'json',
                                contentType: 'application/json; charset=utf-8'
                            }
                        },
                        schema: {
                            // returned in the "listField" field of the response
                            data: function data(response) {
                                var listFields = [],
                                    dataList = response;
                                if (listField && listField.length > 0 && listField != 'null') {
                                    listFields = listField.split('.');
                                    listFields.map(function (field) {
                                        dataList = dataList[field];
                                    });
                                }
                                return dataList;
                            }
                        },
                        serverFiltering: serverFiltering,
                        requestEnd: function (e) {
                            var type = e.type,
                                response = e.response;
                            if (type === 'read' && response) {
                                this.onLoadComplete(e, response);
                            }
                        }.bind(this)
                    } });
            } else {
                $.extend(options, { dataSource: items });
            }

            // // selectedIndex
            // if(typeof selectedIndex !== 'undefined') {
            //     $.extend(options, { index: selectedIndex });
            // }

            // selectedValue
            if (typeof selectedValue !== 'undefined') {
                $.extend(options, { value: selectedValue });
            }

            // headerTemplate
            if (typeof headerTemplate !== 'undefined') {
                $.extend(options, { headerTemplate: headerTemplate });
            }

            // valueTemplate
            if (typeof valueTemplate !== 'undefined') {
                $.extend(options, { valueTemplate: valueTemplate });
            }

            // template
            if (typeof template !== 'undefined') {
                $.extend(options, { template: template });
            }

            return options;
        }

        //-----------------------------
        // methods

    }, {
        key: 'open',
        value: function open() {
            this.dropdownlist.open();
        }
    }, {
        key: 'close',
        value: function close() {
            this.dropdownlist.close();
        }
    }, {
        key: 'select',
        value: function select(index) {
            // index: li jQuery | Number | Function
            // return The index of the selected item
            return this.dropdownlist.select(index);
        }
    }, {
        key: 'value',
        value: function value(v) {
            if (arguments.length == 0) {
                return this.dropdownlist.value();
            } else {
                return this.dropdownlist.value(v);
            }
        }
    }, {
        key: 'enable',
        value: function enable(isBool) {
            if (arguments.length == 0) {
                this.dropdownlist.enable();
            } else {
                this.dropdownlist.enable(isBool);
            }
        }
    }, {
        key: 'readOnly',
        value: function readOnly(isBool) {
            if (arguments.length == 0) {
                this.dropdownlist.readonly();
            } else {
                this.dropdownlist.readonly(isBool);
            }
        }

        /**
         * Set the data items of the dropdownlist's data source.
         * @param {(Array|kendo.data.ObservableArray)} items - the data items of the dropdownlist's data source.
         * @return {kendo.data.ObservableArray} the data items of the dropdownlist's data source.
         */

    }, {
        key: 'setItems',
        value: function setItems(items) {
            return this.dropdownlist.dataSource.data(items);
        }

        /**
         * Get the data items of the dropdownlist's data source.
         * @return {kendo.data.ObservableArray} the data items of the dropdownlist's data source.
         */

    }, {
        key: 'getItems',
        value: function getItems() {
            return this.dropdownlist.dataSource.data();
        }

        //-----------------------------
        // events

    }, {
        key: 'onSelect',
        value: function onSelect(e) {
            // console.log('onSelect', e);
            var selectedItem = this.dropdownlist.dataItem(e.item);
            // selectedValue = selectedItem[this.props.dataValueField];
            //console.log(dataItem[this.props.dataValueField]);
            //$('[name=' + this.props.name + ']').val(dataItem.value);
            //$('input[name=displayData]').val(dataItem[this.props.dataValueField]);
            //this.$dropDownList.val(dataItem[this.props.dataValueField]);

            if (typeof this.props.onSelect === 'function') {
                this.props.onSelect(e, selectedItem, this.prevSelectedItem);
                //e.stopImmediatePropagation();
            }

            // onChange 에서만 처리
            // this.prevSelectedItem = selectedItem;
        }

        // change 발생하지 않음

    }, {
        key: 'onChange',
        value: function onChange(e) {
            // console.log('onChange', e);
            // console.log(this.dropdownlist.dataItem(e.sender.selectedIndex));
            var selectedItem = this.dropdownlist.dataItem(e.sender.selectedIndex);
            // selectedValue = selectedItem[this.props.dataValueField];

            if (typeof this.props.onChange === 'function') {
                this.props.onChange(e, selectedItem, this.prevSelectedItem);
                //e.stopImmediatePropagation();
            }

            this.prevSelectedItem = selectedItem;
        }
    }, {
        key: 'onOpen',
        value: function onOpen(e) {
            //console.log('onOpen');
            //console.log(event);

            if (typeof this.props.onOpen === 'function') {
                this.props.onOpen(e);

                //event.stopImmediatePropagation();
            }
        }
    }, {
        key: 'onClose',
        value: function onClose(e) {
            //console.log('onClose');
            //console.log(event);

            if (typeof this.props.onClose === 'function') {
                this.props.onClose(e);

                //event.stopImmediatePropagation();
            }
        }
    }, {
        key: 'onFiltering',
        value: function onFiltering(e) {

            if (typeof this.props.onFiltering !== 'undefined') {
                this.props.onFiltering(e);
            }
        }
    }, {
        key: 'onDataBound',
        value: function onDataBound(event) {
            //console.log('onDataBound');
            //console.log(event);

            if (typeof this.props.onDataBound === 'function') {
                this.props.onDataBound(event);

                //event.stopImmediatePropagation();
            }
        }
    }, {
        key: 'onLoadComplete',
        value: function onLoadComplete(e, response) {
            // console.log('onLoadComplete', e, response);
            this.prevSelectedItem = response[this.props.selectedIndex];

            // init 시에는 값을 읽어오지 못한다.
            // console.log('onLoadComplete', this.dropdownlist.dataItem());
            // console.log('onLoadComplete', this.value());

            if (typeof this.props.onLoadComplete !== 'undefined') {
                this.props.onLoadComplete(e, response);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목      
            var _props2 = this.props;
            var className = _props2.className;
            var name = _props2.name;
            var width = _props2.width;


            return _react2.default.createElement('input', { id: this.id, name: name, style: { width: width } });
        }
    }]);

    return DropDownList;
}(_react.Component);

DropDownList.propTypes = propTypes;
DropDownList.defaultProps = defaultProps;

exports.default = DropDownList;

},{"../services/Util":77,"classnames":2,"react":34}],61:[function(require,module,exports){
/**
 * Grid component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/04/17
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.Grid options={options} />
 *
 * Kendo Grid 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    host: _react.PropTypes.string, // 서버 정보(Cross Browser Access)
    url: _react.PropTypes.string,
    method: _react.PropTypes.string,
    dataType: _react.PropTypes.string,
    checkboxField: _react.PropTypes.string,
    data: _react.PropTypes.object,
    columns: _react.PropTypes.array,
    items: _react.PropTypes.array,
    selectedIds: _react.PropTypes.array,
    listField: _react.PropTypes.string,
    totalField: _react.PropTypes.string,
    checkField: _react.PropTypes.string,
    onSelectRow: _react.PropTypes.func,
    onChange: _react.PropTypes.func,
    editable: _react.PropTypes.bool,
    resizable: _react.PropTypes.bool,
    filterable: _react.PropTypes.oneOfType([_react.PropTypes.bool, _react.PropTypes.object]),
    sortable: _react.PropTypes.bool,
    sort: _react.PropTypes.object, // { field: 'name', dir: 'desc' } or [{ field: 'name', dir: 'desc' }, { field: 'name', dir: 'desc' }]
    pageable: _react.PropTypes.oneOfType([_react.PropTypes.bool, _react.PropTypes.object]),
    pageSize: _react.PropTypes.number,
    height: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),

    /*
        Grid selectable 설정값
        "row" - the user can select a single row.
        "cell" - the user can select a single cell.
        "multiple, row" - the user can select multiple rows.
        "multiple, cell" - the user can select multiple cells.
    */
    selectMode: _react.PropTypes.oneOf(['row', 'cell']), // Grid Select Row 또는 Cell 선택
    multiple: _react.PropTypes.bool, // 셀렉트 multiple 지원
    /*
        Grid parameterMapField 설정값
        skip: "start", - paging skip 변수 입력된 값(key)으로 복제
        take: "limit", - paging limit 변수 입력된 값(key)으로 복제
        convertSort: true, - sort parameter 복제 여부
        field:"property",  - sort field 변수 입력된 값(key)으로 복제
        dir: "direction",  - sort dir 변수 입력된 값(key)으로 복제
        filtersToJson: true,      - filter 정보를 json으로 변환해서 일반 파라미터 처럼 처리
        filterPrefix: "search_",  - filter json으로 변환시 prefix가 필요한 경우 prefix를 붙여서 반환
        filterFieldToLowerCase: true  - filter의 field를 lowerCase(소문자)로 반환
    */
    parameterMapField: _react.PropTypes.object, // Parameter Control 객체(데이터 복사, 필터처리, Sorting 파리미터 정의 등)
    scrollable: _react.PropTypes.bool, // 좌우 스크롤 생성
    // onChange: PropTypes.func,
    onDataBound: _react.PropTypes.func,
    onDataBinding: _react.PropTypes.func
};

var defaultProps = {
    method: 'POST',
    dataType: 'json',
    items: [],
    listField: 'resultValue.list',
    totalField: 'resultValue.totalCount',
    editable: false,
    resizable: true,
    filterable: false,
    sortable: true,
    pageable: true,
    pageSize: 20,
    selectMode: null,
    multiple: false,
    parameterMapField: null,
    scrollable: true
};

/** Class representing a Grid. */

var Grid = function (_Component) {
    _inherits(Grid, _Component);

    function Grid(props) {
        _classCallCheck(this, Grid);

        var _this2 = _possibleConstructorReturn(this, Object.getPrototypeOf(Grid).call(this, props));

        _this2.checkedIds = {};
        _this2.checkedItems = {};

        // Manually bind this method to the component instance...
        _this2.onDataBound = _this2.onDataBound.bind(_this2);
        _this2.onDataBinding = _this2.onDataBinding.bind(_this2);
        _this2.onChange = _this2.onChange.bind(_this2);
        _this2.onSelectRow = _this2.onSelectRow.bind(_this2);
        _this2.onCheckboxHeader = _this2.onCheckboxHeader.bind(_this2);
        _this2.onCheckboxRow = _this2.onCheckboxRow.bind(_this2);
        return _this2;
    }

    _createClass(Grid, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            // 최초 렌더링이 일어나기 직전(한번 호출)
            var id = this.props.id;
            if (typeof id === 'undefined') {
                id = _Util2.default.getUUID();
            }

            this.id = id;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$grid = $('#' + this.id);

            //console.log(this.options(this.props));
            this.grid = this.$grid.kendoGrid(this.options(this.props)).data('kendoGrid');

            /*
            var _this = this;
            $(window).resize(function(){
                //_this.$grid.data("kendoGrid").resize();
                _this.autoResizeGrid();
            });
            */
            // bind click event to the checkbox
            //console.log(grid);
            // Events
            this.grid.bind('change', this.onChange);
            this.grid.bind('dataBound', this.onDataBound);
            this.grid.bind('dataBinding', this.onDataBinding);

            this.grid.table.on('click', '.checkbox', this.onCheckboxRow); // checkbox
            this.grid.thead.on('click', '.checkbox', this.onCheckboxHeader); // header checkbox
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            // 컴포넌트가 새로운 props를 받을 때 호출(최초 렌더링 시에는 호출되지 않음)
            /* dataSource 에 관련된 값이 바뀌어야 다시 데이터 로딩하는 방식은 일단 보류
            화면에서 refresh 가 안됨
            const {url, method, data, listField} = this.props;
              var b = false;
            for(var key in data) {
                if(nextProps.data[key] != data[key]) {
                    b = true;
                    break;
                }
            }
              if(nextProps.url != url || b == true) {
                //console.log('setDataSource');
                var grid = $('#'+this.id).data("kendoGrid");
                grid.setDataSource(this.createDataSource(nextProps));
            }
            */
            //this.grid.setDataSource(this.createDataSource(nextProps));
            this.checkedIds = {};
            this.grid.thead.find('.checkbox').attr('checked', false);
            // setDataSource 가 일어나면 header checkbox click 이벤트 리스너가 사라져서 다시 설정
            this.grid.thead.on('click', '.checkbox', this.onCheckboxHeader); // header checkbox

            // selected check
            this.setSelectedIds(nextProps);
        }

        /**
         * @private
         */

    }, {
        key: 'options',
        value: function options(props) {
            var url = props.url;
            var items = props.items;
            var editable = props.editable;
            var resizable = props.resizable;
            var filterable = props.filterable;
            var sortable = props.sortable;
            var pageable = props.pageable;
            var height = props.height;
            var checkboxField = props.checkboxField;
            var selectMode = props.selectMode;
            var multiple = props.multiple;
            var scrollable = props.scrollable;


            var dataSource;
            if (url && url.length > 0) {
                dataSource = this.createDataSource(props);
            } else {
                dataSource = items;
            }

            var columns = props.columns;
            if (typeof checkboxField !== 'undefined') {
                var b = true;
                for (var i in columns) {
                    if (checkboxField == columns[i].field) {
                        b = false;
                        break;
                    }
                }
                if (b === true) {
                    columns.unshift(this.getCheckboxColumn(checkboxField));
                }
            }

            var filter;
            if (typeof filterable === 'boolean' && filterable === true) {
                filter = {
                    extra: false,
                    operators: {
                        string: {
                            contains: 'contains'
                        },
                        number: {
                            eq: 'eq' /*,
                                     neq: "Diverso da",
                                     gte: "Maggiore o uguale a",
                                     gt: "Maggiore di",
                                     lte: "Minore o uguale a",
                                     lt: "Minore di"*/
                        },
                        date: {
                            eq: 'eq' /*,
                                     neq: "Diverso da",
                                     gte: "Successiva o uguale al",
                                     gt: "Successiva al",
                                     lte: "Precedente o uguale al",
                                     lt: "Precedente al"*/
                        },
                        enums: {
                            contains: 'contains'
                        }
                    },
                    ui: function ui(element) {
                        var $parent = element.parent();
                        while ($parent.children().length > 1) {
                            $($parent.children()[0]).remove();
                        }$parent.prepend('<input type="text" data-bind="value:filters[0].value" class="k-textbox">');
                        $parent.find('button:submit.k-button.k-primary').html('필터');
                        $parent.find('button:reset.k-button').html('초기화');
                    }
                };
            } else {
                filter = filterable;
            }

            var _pageable;
            if (typeof pageable === 'boolean' && pageable === true) {
                _pageable = {
                    buttonCount: 5,
                    pageSizes: [10, 20, 30, 50, 100],
                    messages: {
                        display: $ps_locale.grid.recordtext, //'{0}-{1}/{2}',
                        empty: '',
                        //of: '/{0}',
                        itemsPerPage: $ps_locale.grid.rowsPerPage
                    }
                };
            } else {
                _pageable = pageable;
            }

            var options = {
                dataSource: dataSource,
                columns: columns,
                noRecords: {
                    template: $ps_locale.grid.emptyrecords
                },
                height: height,
                //dataBound: this.onDataBound,
                editable: editable,
                resizable: resizable,
                filterable: filter,
                sortable: sortable,
                scrollable: scrollable,
                pageable: _pageable,
                selectable: multiple ? "multiple ," + selectMode : selectMode
            };

            if (typeof height === 'number' || typeof height === 'string') {
                $.extend(options, { height: height });
            }

            return options;
        }

        /**
         * @private
         */

    }, {
        key: 'createDataSource',
        value: function createDataSource(props) {
            var host = props.host;
            var url = props.url;
            var method = props.method;
            var dataType = props.dataType;
            var data = props.data;
            var listField = props.listField;
            var totalField = props.totalField;
            var sort = props.sort;
            var pageable = props.pageable;
            var pageSize = props.pageSize;
            var parameterMapField = props.parameterMapField;

            // pageSize

            var _pageSize = 0,
                _pageable = false;
            if (pageable) {
                _pageSize = pageSize;
                _pageable = true;
            }

            // http://itq.nl/kendo-ui-grid-with-server-paging-filtering-and-sorting-with-mvc3/
            // https://blog.longle.net/2012/04/13/teleriks-html5-kendo-ui-grid-with-server-side-paging-sorting-filtering-with-mvc3-ef4-dynamic-linq/
            var dataSource = new kendo.data.DataSource({
                transport: {
                    /*
                    read: function(options) {
                        $.ajax({
                            type: method,
                            url: url,
                            //contentType: "application/json; charset=utf-8", 이것 설정하면 data 전송 안됨
                            dataType: 'json',
                            data: data,//JSON.stringify({key: "value"}),
                            success: function(data) {
                                //console.log(data);
                                  var arr = [], gridList = data;
                                if(listField && listField.length > 0 && listField != 'null') {
                                    arr = listField.split('.');
                                }
                                for(var i in arr) {
                                    //console.log(arr[i]);
                                    gridList = gridList[arr[i]];
                                }
                                options.success(gridList);
                                //options.success(data.resultValue.list);
                            }
                        });
                    }
                    */
                    read: {
                        url: host && host !== null && host.length > 0 ? host + url : url,
                        type: method,
                        dataType: dataType,
                        data: data, // search (@RequestBody GridParam gridParam 로 받는다.)
                        contentType: 'application/json; charset=utf-8'
                    },
                    parameterMap: function parameterMap(data, type) {
                        if (type == "read" && parameterMapField !== null) {
                            // 데이터 읽어올때 필요한 데이터(ex:페이지관련)가 있으면 data를 copy한다.
                            for (var copy in parameterMapField) {
                                if (typeof parameterMapField[copy] === "string" && copy in data) {
                                    data[parameterMapField[copy]] = data[copy];
                                }
                            }
                            // Filter Array => Json Object Copy
                            if (parameterMapField.filtersToJson && data.filter && data.filter.filters) {
                                var filters = data.filter.filters;
                                filters.map(function (filter) {
                                    var field = parameterMapField.filterPrefix ? parameterMapField.filterPrefix + filter.field : filter.field;
                                    if (parameterMapField.filterFieldToLowerCase) {
                                        data[field.toLowerCase()] = filter.value;
                                    } else {
                                        data[field] = filter.value;
                                    }
                                });
                            }
                            // Sort Array => Field, Dir Convert
                            if (parameterMapField.convertSort && data.sort) {
                                data.sort.map(function (sortData) {
                                    if ("field" in parameterMapField) {
                                        sortData[parameterMapField.field] = sortData.field;
                                    }
                                    if ("dir" in parameterMapField) {
                                        sortData[parameterMapField.dir] = sortData.dir;
                                    }
                                });
                            }
                        }

                        //console.log(data);
                        // paging 처리시 서버로 보내지는 그리드 관련 데이터 {take: 20, skip: 0, page: 1, pageSize: 20}
                        // no paging 처리시에는 {} 을 서버로 보낸다.
                        // @RequestBody GridParam gridParam 로 받는다.
                        return JSON.stringify(data);
                    }
                },
                schema: {
                    // returned in the "listField" field of the response
                    data: function data(response) {
                        //console.log(response);
                        var arr = [],
                            gridList = response;

                        if (listField && listField.length > 0 && listField != 'null') {
                            arr = listField.split('.');
                        }
                        for (var i in arr) {
                            //console.log(arr[i]);
                            if (!gridList) {
                                gridList = [];
                                break;
                            }
                            gridList = gridList[arr[i]];
                        }
                        return gridList;
                    },
                    // returned in the "totalField" field of the response
                    total: function total(response) {
                        //console.log(response);
                        var arr = [],
                            total = response;
                        if (totalField && totalField.length > 0 && totalField != 'null') {
                            arr = totalField.split('.');
                        }
                        for (var i in arr) {
                            //console.log(arr[i]);
                            if (!total) {
                                total = 0;
                                break;
                            }
                            total = total[arr[i]];
                        }
                        return total;
                    }
                },
                pageSize: _pageSize,
                serverPaging: _pageable,
                serverFiltering: _pageable,
                serverSorting: _pageable,
                sort: sort
            });

            return dataSource;
        }

        /**
         * @private
         */

    }, {
        key: 'setSelectedIds',
        value: function setSelectedIds(props) {
            var checkField = props.checkField;
            var selectedIds = props.selectedIds;


            var _selectedIds;
            if (typeof selectedIds !== 'undefined' && selectedIds !== null && selectedIds.length > 0) {
                _selectedIds = selectedIds;
            } else {
                _selectedIds = this.selectedIds;
            }

            if (typeof _selectedIds === 'undefined' || _selectedIds === null) return;

            var rows = this.grid.table.find('tr').find('td:first input').closest('tr'),
                _this = this;

            rows.each(function (index, row) {
                var $checkbox = $(row).find('input:checkbox.checkbox'),
                    dataItem = _this.grid.dataItem(row),
                    checked = false;

                for (var i = 0; i < _selectedIds.length; i++) {

                    if (checkField !== null && typeof checkField !== 'undefined') {
                        if (dataItem[checkField] == _selectedIds[i]) {
                            checked = true;
                            break;
                        }
                    } else {
                        if ($checkbox.val() == _selectedIds[i]) {
                            checked = true;
                            break;
                        }
                    }
                }

                $checkbox.attr('checked', checked);
                _this.selectCheckbox($checkbox, checked, $(row));
            });
        }

        /**
         * @private
         */

    }, {
        key: 'selectCheckbox',
        value: function selectCheckbox($checkbox, checked, $row) {

            var dataItem = this.grid.dataItem($row);

            if (this.props.checkField !== null && typeof this.props.checkField !== 'undefined') {
                this.checkedIds[dataItem[this.props.checkField]] = checked;
                this.checkedItems[dataItem[this.props.checkField]] = dataItem;
            } else {
                this.checkedIds[$checkbox.val()] = checked;
                this.checkedItems[$checkbox.val()] = dataItem;
            }

            if (checked) {
                //-select the row
                $row.addClass("k-state-selected");
            } else {
                //-remove selection
                $row.removeClass("k-state-selected");
            }
        }

        /**
         * @private
         */

    }, {
        key: 'getCheckboxColumn',
        value: function getCheckboxColumn(checkboxField) {
            return {
                field: checkboxField,
                headerTemplate: '<input type="checkbox" class="checkbox" />',
                //headerTemplate: '<div class="checkbox"><label><input type="checkbox" /></label></div>',
                //headerAttributes: {
                //    'class': 'table-header-cell',
                //    style: 'text-align: center'
                //},
                template: '<input type="checkbox" class="checkbox" value="#=' + checkboxField + '#" />',
                attributes: {
                    align: 'center'
                },
                width: 40,
                sortable: false,
                filterable: false,
                resizable: false
            };
        }

        //-----------------------------
        // methods
        /**
         * Refresh
         * @param {boolean} [server=true] - server refresh or not.
         */

    }, {
        key: 'refresh',
        value: function refresh() {
            var server = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

            //this.grid.refresh();
            if (server === true) {
                this.grid.setDataSource(this.createDataSource(this.props));
            } else {
                this.grid.refresh();
            }
        }

        /**
         * Get dataSource.
         * @return {kendo.data.DataSource} Grid data source.
         */

    }, {
        key: 'getDataSource',
        value: function getDataSource() {
            return this.grid.dataSource;
        }

        /**
         * The jQuery object which represents the grid content element, which holds the scrollable content. Available only in a grid with locked columns.
         * @return {jQuery} Grid content.
         */

    }, {
        key: 'getContent',
        value: function getContent() {
            return this.grid.content;
        }

        /**
         * Get selected ids.
         * @return {Array} Grid selected ids.
         */

    }, {
        key: 'getSelectedIds',
        value: function getSelectedIds() {
            return this.selectedIds;
        }

        /**
         * Get selected items.
         * @return {Array} Grid selected items.
         */

    }, {
        key: 'getSelectedItems',
        value: function getSelectedItems() {
            return this.selectedItems;
        }

        /**
         * Get or Set Grid Content Height
         * @param {(string|number)} height - Grid Content Height
         * @return {number} Grid Content Height
         */

    }, {
        key: 'contentHeight',
        value: function contentHeight(height) {
            if (arguments.length == 0) {
                return this.$grid.find('.k-grid-content').height();
            } else {
                return this.$grid.find('.k-grid-content').height(height);
            }
        }

        /**
         * Get or Set Grid Header Height
         * @param {(string|number)} height - Grid Header Height
         * @return {number} Grid Header Height
         */

    }, {
        key: 'headerHeight',
        value: function headerHeight(height) {
            if (arguments.length == 0) {
                return this.$grid.find('.k-grid-header').height();
            } else {
                return this.$grid.find('.k-grid-header').height(height);
            }
        }

        /**
         * Appends a data item to the data source.
         * @param {(object|kendo.data.Model)} dataItem - the data item to which the specified table row is bound. The data item is a Kendo UI Model instance.
         * @return {kendo.data.Model} the data item which is inserted.
         */

    }, {
        key: 'addItem',
        value: function addItem(dataItem) {
            return this.grid.dataSource.add(dataItem);
        }

        /**
         * Removes the specified data item from the data source.
         * @param {(object|kendo.data.Model)} dataItem - the data item to which the specified table row is bound. The data item is a Kendo UI Model instance.
         */

    }, {
        key: 'removeItem',
        value: function removeItem(dataItem) {
            this.grid.dataSource.remove(dataItem);

            if (typeof this.props.checkField === 'undefined' || !this.props.checkField) return;
            this.checkedIds[dataItem[this.props.checkField]] = false;

            if (typeof this.selectedIds === 'undefined' || !this.selectedIds) return;
            for (var i = 0; i < this.selectedIds.length; i++) {
                if (this.selectedIds[i] === dataItem[this.props.checkField]) {
                    this.selectedIds.splice(i, 1);
                    this.selectedItems.splice(i, 1);
                    return;
                }
            }
        }

        /**
         * Set the data items of the grid's data source.
         * @param {(Array|kendo.data.ObservableArray)} items - the data items of the grid's data source.
         * @return {kendo.data.ObservableArray} the data items of the grid's data source.
         */

    }, {
        key: 'setItems',
        value: function setItems(items) {
            return this.grid.dataSource.data(items);
        }

        /**
         * Get the data items of the grid's data source.
         * @return {kendo.data.ObservableArray} the data items of the grid's data source.
         */

    }, {
        key: 'getItems',
        value: function getItems() {
            return this.grid.dataSource.data();
        }

        /**
         * draggable
         */

    }, {
        key: 'draggable',
        value: function draggable() {
            this.grid.content.kendoDraggable({
                filter: 'tr',
                hint: function hint(element) {
                    return element.clone();
                }
            });
        }

        /**
         * drop target
         * @param {(kendo.ui.Widget|function)} widget - Widget or function
         */

    }, {
        key: 'dropTarget',
        value: function dropTarget(widget) {
            var _this = this,
                dropFunc;

            // e.draggable/e.dropTarget (jQuery)/e.target Element
            //_dropFunc(e);

            if (typeof widget === 'function') {
                dropFunc = widget;
            } else {
                dropFunc = function dropFunc(e) {
                    var dataItem = widget.dataItem(e.draggable.currentTarget); //dragDataSource.getByUid(e.draggable.currentTarget.data('uid'));
                    if (typeof widget.remove === 'function') {
                        widget.remove(e.draggable.currentTarget);
                    }
                    _this.grid.dataSource.add(dataItem);

                    //e.draggable.destroy();
                    //e.draggable.element.css('opacity', 0.3);
                };
            }

            this.grid.content.kendoDropTarget({
                dragenter: function dragenter(e) {
                    e.draggable.hint.css('opacity', 0.7); //modify the draggable hint
                    e.dropTarget.addClass('droptarget-active'); //modify dropTarget element
                },
                dragleave: function dragleave(e) {
                    e.draggable.hint.css('opacity', 1); //modify the draggable hint
                    e.dropTarget.removeClass('droptarget-active'); //modify dropTarget element
                },
                drop: dropFunc
            });
        }

        /**
         * drag sortable
         */

    }, {
        key: 'dragSortable',
        value: function dragSortable() {
            this.grid.content.css('cursor', 'move');

            var _this = this;
            this.grid.table.kendoSortable({
                filter: '>tbody >tr',
                cursor: 'move',
                hint: function hint(element) {
                    //customize the hint
                    //var table = $('<table style="width: 600px;" class="k-grid k-widget"></table>'),
                    //    hint;
                    //
                    //table.append(element.clone()); //append the dragged element
                    //table.css('opacity', 0.7);
                    //
                    //return table; //return the hint element

                    var table = _this.grid.table.clone(),
                        // Clone Grid's table
                    wrapperWidth = _this.grid.wrapper.width(),
                        //get Grid's width
                    wrapper = $('<div class="k-grid k-widget"></div>').width(wrapperWidth),
                        hint;

                    table.find('thead').remove(); // Remove Grid's header from the hint
                    table.find('tbody').empty(); // Remove the existing rows from the hint
                    table.wrap(wrapper); // Wrap the table
                    table.append(element.clone().removeAttr('uid')); // Append the dragged element

                    hint = table.parent(); // Get the wrapper

                    return hint; // Return the hint element
                },
                placeholder: function placeholder(element) {
                    return element.clone().addClass('k-sortable-placeholder');
                },
                container: '#' + this.id + ' tbody',
                change: function change(e) {
                    var oldIndex = e.oldIndex,
                        newIndex = e.newIndex,
                        data = _this.grid.dataSource.data(),
                        dataItem = _this.grid.dataSource.getByUid(e.item.data('uid'));

                    _this.grid.dataSource.remove(dataItem);
                    _this.grid.dataSource.insert(newIndex, dataItem);
                }
            });
        }

        //-----------------------------
        // events
        /**
         * Fired when the widget is bound to data from its data source.
         * @param {Event} e - event, event data e.sender kendo.ui.Grid
         * @param {kendo.data.ObservableArray} data - the data items of the data source.
         */

    }, {
        key: 'onDataBound',
        value: function onDataBound(e) {
            //console.log('dataBound', e);

            // selected check
            this.setSelectedIds(this.props);

            if (typeof this.props.onDataBound === 'function') {
                var data = this.grid.dataSource.data(); //e.sender.dataSource.data();
                this.props.onDataBound(e, data);
                //event.stopImmediatePropagation();
            }
        }

        /**
         * Fired before the widget binds to its data source.
         * @param {Event} e - event, event data e.sender kendo.ui.Grid
         * @param {kendo.data.ObservableArray} data - the data items of the data source.
         */

    }, {
        key: 'onDataBinding',
        value: function onDataBinding(e) {
            //console.log('onDataBinding', e);
            if (typeof this.props.onDataBinding === 'function') {
                var data = this.grid.dataSource.data(); //e.sender.dataSource.data();
                this.props.onDataBinding(e, data);
                //event.stopImmediatePropagation();
            }
        }

        // kendo api는 있는데 실제 해보면 안됨
        //sort: function(field, dir) {
        //    var options = this.grid.options(),
        //        dataSource = options.dataSource;
        //    console.log(dataSource);
        //
        //    dataSource.sort({ field: field, dir: dir }); // dir: asc/desc
        //},
        /*
        * Grid Change Event(Select Event), dataSet으로 정의하여 받는다.
        * rowIndex
        * cellIndex
        * data
        * rows
        */

    }, {
        key: 'onChange',
        value: function onChange() {
            var grid = this.grid;
            if (typeof this.props.onChange === 'function') {
                //var data = event.node;
                var dataSet = {};
                if (this.props.selectMode === "cell") {
                    var row = $(grid.select()).closest("tr");
                    var cell = grid.select();
                    var cellText = $(cell).text();
                    dataSet.rowIndex = $("tr", grid.tbody).index(row);
                    dataSet.cellIndex = grid.cellIndex(cell);
                    dataSet.data = $(cell).text();
                } else {
                    var rows = grid.select();

                    if (rows.length > 1) {
                        (function () {
                            var rowsData = [];
                            rows.each(function () {
                                rowsData.push(grid.dataItem($(this)));
                            });
                            dataSet.rows = rows;
                            dataSet.data = rowsData;
                        })();
                    } else {
                        dataSet.rows = rows;
                        dataSet.data = grid.dataItem(rows);
                    }
                }
                this.props.onChange(dataSet);
            }
        }
    }, {
        key: 'onSelectRow',
        value: function onSelectRow(event) {

            var ids = [],
                items = [];
            for (var key in this.checkedIds) {
                if (this.checkedIds[key]) {
                    ids.push(key);
                    items.push(this.checkedItems[key]);
                }
            }

            this.selectedIds = ids;
            this.selectedItems = items;

            if (typeof this.props.onSelectRow === 'function') {
                this.props.onSelectRow(event, ids, items);
            }
        }

        /**
         * @private
         */

    }, {
        key: 'onCheckboxHeader',
        value: function onCheckboxHeader(event) {
            var checked = $(event.target).is(':checked');

            var rows = this.grid.table.find("tr").find("td:first input").closest("tr"),
                _this = this;

            rows.each(function (index, row) {
                var $checkbox = $(row).find('input:checkbox.checkbox');
                $checkbox.attr('checked', checked);

                _this.selectCheckbox($checkbox, checked, $(row));
            });

            this.onSelectRow(event);
        }

        /**
         * @private
         */

    }, {
        key: 'onCheckboxRow',
        value: function onCheckboxRow(event) {
            var checked = event.target.checked,
                $row = $(event.target).closest('tr');

            this.selectCheckbox($(event.target), checked, $row);
            this.onSelectRow(event);
        }

        //onDataBound: function(arg) {
        //    // selected check
        //    this.setSelectedIds(this.props);
        //},

    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var className = this.props.className;


            return _react2.default.createElement('div', { id: this.id, className: (0, _classnames2.default)(className) });
        }
    }]);

    return Grid;
}(_react.Component);

Grid.propTypes = propTypes;
Grid.defaultProps = defaultProps;

exports.default = Grid;

},{"../services/Util":77,"classnames":2,"react":34}],62:[function(require,module,exports){
/**
 * MultiSelect component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/08/23
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.MultiSelect options={options} />
 *
 * Kendo MultiSelect 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    name: _react.PropTypes.string,
    className: _react.PropTypes.string,
    host: _react.PropTypes.string, // 서버 정보(Cross Browser Access)
    url: _react.PropTypes.string,
    method: _react.PropTypes.string,
    data: _react.PropTypes.object,
    items: _react.PropTypes.array,
    selectedValues: _react.PropTypes.array,
    placeholder: _react.PropTypes.string,
    listField: _react.PropTypes.string,
    dataTextField: _react.PropTypes.string,
    dataValueField: _react.PropTypes.string,
    multiple: _react.PropTypes.bool, // 다중선택을 지원하며, 닫히지 않고 여러개를 선택할 수 있다.
    headerTemplate: _react.PropTypes.string,
    itemTemplate: _react.PropTypes.string,
    tagTemplate: _react.PropTypes.string,
    height: _react.PropTypes.number,
    disabled: _react.PropTypes.bool,
    readOnly: _react.PropTypes.bool,
    onSelect: _react.PropTypes.func,
    onDeselect: _react.PropTypes.func,
    onChange: _react.PropTypes.func,
    onOpen: _react.PropTypes.func,
    onClose: _react.PropTypes.func,
    onFiltering: _react.PropTypes.func,
    onDataBound: _react.PropTypes.func,
    onLoadComplete: _react.PropTypes.func,
    minLength: _react.PropTypes.number, // 검색시 필요한 최소 단어 길이
    maxSelectedItems: _react.PropTypes.number, // 최대 선택 수
    parameterMapField: _react.PropTypes.object, // Paging, FilterJson
    serverFiltering: _react.PropTypes.bool, // 서버 Filtering(검색조건에 따른 리스트업)
    filterFields: _react.PropTypes.array // 필터 필드 정의(or로 다중 검색시 제공)
};

var defaultProps = {
    method: 'POST',
    items: [],
    listField: 'resultValue',
    placeholder: $ps_locale.select,
    dataTextField: 'text',
    dataValueField: 'value',
    multiple: false,
    minLength: 0,
    maxSelectedItems: null,
    serverFiltering: false,
    filterFields: null,
    disabled: false
};

/** Class representing a MultiSelect. */

var MultiSelect = function (_Component) {
    _inherits(MultiSelect, _Component);

    function MultiSelect(props) {
        _classCallCheck(this, MultiSelect);

        // Manually bind this method to the component instance...

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MultiSelect).call(this, props));

        _this.onSelect = _this.onSelect.bind(_this);
        _this.onDeselect = _this.onDeselect.bind(_this);
        _this.onChange = _this.onChange.bind(_this);
        _this.onOpen = _this.onOpen.bind(_this);
        _this.onClose = _this.onClose.bind(_this);
        _this.onFiltering = _this.onFiltering.bind(_this);
        _this.onDataBound = _this.onDataBound.bind(_this);
        _this.onLoadComplete = _this.onLoadComplete.bind(_this);
        return _this;
    }

    _createClass(MultiSelect, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            // 최초 렌더링이 일어나기 직전(한번 호출)
            var id = this.props.id;
            if (typeof id === 'undefined') {
                id = _Util2.default.getUUID();
            }

            this.id = id;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$multiSelect = $('#' + this.id);
            this.multiSelect = this.$multiSelect.kendoMultiSelect(this.options()).data('kendoMultiSelect');

            // Events
            this.multiSelect.bind('select', this.onSelect);
            this.multiSelect.bind('deselect', this.onDeselect);
            this.multiSelect.bind('change', this.onChange);
            this.multiSelect.bind('open', this.onOpen);
            this.multiSelect.bind('close', this.onClose);
            this.multiSelect.bind('filtering', this.onFiltering);
            this.multiSelect.bind('dataBound', this.onDataBound);

            // readOnly
            if (typeof this.props.readOnly !== 'undefined') {
                this.readOnly(this.props.readOnly);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            // 컴포넌트가 새로운 props를 받을 때 호출(최초 렌더링 시에는 호출되지 않음)
            if (typeof nextProps.selectedValues !== 'undefined') {
                this.multiSelect.value(nextProps.selectedValues);
            }

            if (typeof nextProps.disabled !== 'undefined') {
                this.enable(!nextProps.disabled);
            }

            if (typeof nextProps.readOnly !== 'undefined') {
                this.readOnly(nextProps.readOnly);
            }
        }

        /**
         * @private
         */

    }, {
        key: 'options',
        value: function options() {
            var _props = this.props;
            var host = _props.host;
            var url = _props.url;
            var data = _props.data;
            var method = _props.method;
            var items = _props.items;
            var selectedValues = _props.selectedValues;
            var placeholder = _props.placeholder;
            var listField = _props.listField;
            var dataTextField = _props.dataTextField;
            var dataValueField = _props.dataValueField;
            var headerTemplate = _props.headerTemplate;
            var itemTemplate = _props.itemTemplate;
            var tagTemplate = _props.tagTemplate;
            var height = _props.height;
            var disabled = _props.disabled;
            var multiple = _props.multiple;
            var minLength = _props.minLength;
            var maxSelectedItems = _props.maxSelectedItems;
            var parameterMapField = _props.parameterMapField;
            var serverFiltering = _props.serverFiltering;
            var filterFields = _props.filterFields;


            var options = {
                placeholder: placeholder,
                dataTextField: dataTextField,
                dataValueField: dataValueField,
                enable: !disabled
            };

            // dataSource
            // url
            if (typeof url !== 'undefined') {
                $.extend(options, { dataSource: {
                        transport: {
                            read: {
                                url: host && host !== null && host.length > 0 ? host + url : url,
                                type: method,
                                dataType: 'json',
                                data: data, // search (@RequestBody GridParam gridParam 로 받는다.)
                                contentType: 'application/json; charset=utf-8'
                            } /*,
                              parameterMap: function(data, type) {
                                 if(type == "read" && parameterMapField !== null){
                                     // 데이터 읽어올때 필요한 데이터(ex:페이지관련)가 있으면 data를 copy한다.
                                     for(let copy in parameterMapField){
                                         if(typeof parameterMapField[copy] === "string" && ( copy in data )){
                                             data[parameterMapField[copy]] = data[copy];
                                         }
                                     }
                                       if(parameterMapField.filtersToJson && data.filter && data.filter.filters){
                                         // Filter Array => Json Object Copy
                                         let filters = data.filter.filters;
                                         filters.map((filter) => {
                                             let field = (parameterMapField.filterPrefix) ? parameterMapField.filterPrefix + filter.field : filter.field;
                                             if(parameterMapField.filterFieldToLowerCase){
                                                 data[field.toLowerCase()] = filter.value;
                                             }else{
                                                 data[field] = filter.value;
                                             }
                                         });
                                     }
                                 }
                                 return JSON.stringify(data);
                              }
                              */
                        },
                        schema: {
                            // returned in the "listField" field of the response
                            data: function data(response) {
                                var listFields = [],
                                    dataList = response;
                                if (listField && listField.length > 0 && listField != 'null') {
                                    listFields = listField.split('.');
                                    listFields.map(function (field) {
                                        dataList = dataList[field];
                                    });
                                }
                                return dataList;
                            }
                        },
                        serverFiltering: serverFiltering,
                        requestEnd: function (e) {
                            var type = e.type,
                                response = e.response;
                            if (type === 'read' && response) {
                                this.onLoadComplete(e, response);
                            }
                        }.bind(this)
                    } });
            } else {
                $.extend(options, { dataSource: items });
            }

            // selectedValues
            if (typeof selectedValues !== 'undefined') {
                $.extend(options, { value: selectedValues });
            }

            // headerTemplate
            if (typeof headerTemplate !== 'undefined') {
                $.extend(options, { headerTemplate: headerTemplate });
            }

            // itemTemplate
            if (typeof itemTemplate !== 'undefined') {
                $.extend(options, { itemTemplate: itemTemplate });
            }

            // tagTemplate
            if (typeof tagTemplate !== 'undefined') {
                $.extend(options, { tagTemplate: tagTemplate });
            }

            // height
            if (typeof height !== 'undefined') {
                $.extend(options, { height: height });
            }

            // autoClose
            if (multiple) {
                $.extend(options, { autoClose: false });
            }

            // minLength
            if (minLength > 0) {
                $.extend(options, { minLength: minLength });
            }

            // maxSelectedItems
            if (maxSelectedItems !== null) {
                $.extend(options, { maxSelectedItems: maxSelectedItems });
            }

            // filter
            if (filterFields !== null && Array.isArray(filterFields)) {
                $.extend(options, { filtering: function filtering(e) {
                        if (e.filter) {
                            var value;
                            var newFilter;

                            (function () {
                                var fields = filterFields;
                                value = e.filter.value;


                                var newFields = [];
                                fields.map(function (field) {
                                    newFields.push({
                                        field: field,
                                        operator: "contains",
                                        value: value
                                    });
                                });

                                newFilter = {
                                    filters: newFields,
                                    logic: "or"
                                };

                                e.sender.dataSource.filter(newFilter);
                                e.preventDefault();
                            })();
                        }
                        e.preventDefault();
                    } });
            }

            return options;
        }

        //-----------------------------
        // methods

    }, {
        key: 'value',
        value: function value(v) {
            if (arguments.length == 0) {
                return this.multiSelect.value();
            } else {
                return this.multiSelect.value(v);
            }
        }
    }, {
        key: 'enable',
        value: function enable(isBool) {
            if (arguments.length == 0) {
                this.multiSelect.enable();
            } else {
                this.multiSelect.enable(isBool);
            }
        }
    }, {
        key: 'readOnly',
        value: function readOnly(isBool) {
            if (arguments.length == 0) {
                this.multiSelect.readonly();
            } else {
                this.multiSelect.readonly(isBool);
            }
        }

        //-----------------------------
        // events

    }, {
        key: 'onSelect',
        value: function onSelect(e) {
            var dataItem = this.multiSelect.dataSource.view()[e.item.index()];

            if (typeof this.props.onSelect !== 'undefined') {
                this.props.onSelect(e, dataItem, this.value());
            }
        }
    }, {
        key: 'onDeselect',
        value: function onDeselect(e) {
            // console.log('multiselect deselect: ', e);
            if (typeof this.props.onDeselect !== 'undefined') {
                this.props.onDeselect(e, e.dataItem);
            }
        }
    }, {
        key: 'onChange',
        value: function onChange(e) {
            //var dataItem = this.multiSelect.dataSource.view()[e.item.index()];

            if (typeof this.props.onChange !== 'undefined') {
                this.props.onChange(e, this.value());
            }
        }
    }, {
        key: 'onOpen',
        value: function onOpen(e) {
            if (typeof this.props.onOpen !== 'undefined') {
                this.props.onOpen(e);
            }
        }
    }, {
        key: 'onClose',
        value: function onClose(e) {
            if (typeof this.props.onClose !== 'undefined') {
                this.props.onClose(e);
            }
        }
    }, {
        key: 'onFiltering',
        value: function onFiltering(e) {
            if (typeof this.props.onFiltering !== 'undefined') {
                this.props.onFiltering(e);
            }
        }
    }, {
        key: 'onDataBound',
        value: function onDataBound(e) {

            if (typeof this.props.onDataBound !== 'undefined') {
                this.props.onDataBound(e);
            }
        }
    }, {
        key: 'onLoadComplete',
        value: function onLoadComplete(e, response) {
            if (typeof this.props.onLoadComplete !== 'undefined') {
                this.props.onLoadComplete(e, response);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props2 = this.props;
            var className = _props2.className;
            var name = _props2.name;
            var multiple = _props2.multiple;


            return _react2.default.createElement('select', { id: this.id, name: name, multiple: multiple, className: (0, _classnames2.default)(className) });
        }
    }]);

    return MultiSelect;
}(_react.Component);

MultiSelect.propTypes = propTypes;
MultiSelect.defaultProps = defaultProps;

exports.default = MultiSelect;

},{"../services/Util":77,"classnames":2,"react":34}],63:[function(require,module,exports){
/**
 * NumericTextBox component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/08/31
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.NumericTextBox options={options} />
 *
 * Kendo NumericTextBox 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    name: _react.PropTypes.string,
    width: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
    format: _react.PropTypes.string,
    value: _react.PropTypes.number,
    step: _react.PropTypes.number,
    min: _react.PropTypes.number,
    max: _react.PropTypes.number,
    decimals: _react.PropTypes.number,
    placeholder: _react.PropTypes.string,
    downArrowText: _react.PropTypes.string,
    upArrowText: _react.PropTypes.string,
    disabled: _react.PropTypes.bool,
    readOnly: _react.PropTypes.bool,
    onChange: _react.PropTypes.func
};

var defaultProps = {
    format: 'n0',
    value: 1,
    downArrowText: '',
    upArrowText: '',
    disabled: false
};

/** Class representing a NumericTextBox. */

var NumericTextBox = function (_Component) {
    _inherits(NumericTextBox, _Component);

    function NumericTextBox(props) {
        _classCallCheck(this, NumericTextBox);

        // Manually bind this method to the component instance...

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(NumericTextBox).call(this, props));

        _this.onChange = _this.onChange.bind(_this);
        return _this;
    }

    _createClass(NumericTextBox, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            // 최초 렌더링이 일어나기 직전(한번 호출)
            var id = this.props.id;
            if (typeof id === 'undefined') {
                id = _Util2.default.getUUID();
            }

            this.id = id;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$numericTextBox = $('#' + this.id);
            this.numericTextBox = this.$numericTextBox.kendoNumericTextBox(this.options()).data('kendoNumericTextBox');

            // Events
            this.numericTextBox.bind('change', this.onChange);

            // disabled
            if (typeof this.props.disabled !== 'undefined') {
                this.enable(!this.props.disabled);
            }

            // readOnly
            if (typeof this.props.readOnly !== 'undefined') {
                this.readOnly(this.props.readOnly);
            }
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            // 컴포넌트가 새로운 props를 받을 때 호출(최초 렌더링 시에는 호출되지 않음)
            if (typeof nextProps.value !== 'undefined') {
                this.numericTextBox.value(nextProps.value);
            }

            // disabled
            if (typeof nextProps.disabled !== 'undefined') {
                this.enable(!nextProps.disabled);
            }

            // readOnly
            if (typeof nextProps.readOnly !== 'undefined') {
                this.readOnly(nextProps.readOnly);
            }
        }

        /**
         * @private
         */

    }, {
        key: 'options',
        value: function options() {
            var _props = this.props;
            var format = _props.format;
            var value = _props.value;
            var step = _props.step;
            var min = _props.min;
            var max = _props.max;
            var decimals = _props.decimals;
            var placeholder = _props.placeholder;
            var downArrowText = _props.downArrowText;
            var upArrowText = _props.upArrowText;


            var options = {
                format: format,
                value: value,
                downArrowText: downArrowText,
                upArrowText: upArrowText
            };

            // step
            if (typeof step !== 'undefined') {
                $.extend(options, { step: step });
            }

            // min
            if (typeof min !== 'undefined') {
                $.extend(options, { min: min });
            }

            // max
            if (typeof max !== 'undefined') {
                $.extend(options, { max: max });
            }

            // decimals
            if (typeof decimals !== 'undefined') {
                $.extend(options, { decimals: decimals });
            }

            // placeholder
            if (typeof placeholder !== 'undefined') {
                $.extend(options, { placeholder: placeholder });
            }

            return options;
        }

        //-----------------------------
        // methods

    }, {
        key: 'value',
        value: function value(v) {
            if (arguments.length == 0) {
                return this.numericTextBox.value();
            } else {
                return this.numericTextBox.value(v);
            }
        }
    }, {
        key: 'enable',
        value: function enable(isBool) {
            if (arguments.length == 0) {
                this.numericTextBox.enable();
            } else {
                this.numericTextBox.enable(isBool);
            }
        }
    }, {
        key: 'readOnly',
        value: function readOnly(isBool) {
            if (arguments.length == 0) {
                this.numericTextBox.readonly();
            } else {
                this.numericTextBox.readonly(isBool);
            }
        }

        //-----------------------------
        // events

    }, {
        key: 'onChange',
        value: function onChange(e) {
            if (typeof this.props.onChange !== 'undefined') {
                this.props.onChange(e, this.value());
            }
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props2 = this.props;
            var className = _props2.className;
            var name = _props2.name;
            var width = _props2.width;


            return _react2.default.createElement('input', { id: this.id, name: name, style: { width: width } });
        }
    }]);

    return NumericTextBox;
}(_react.Component);

NumericTextBox.propTypes = propTypes;
NumericTextBox.defaultProps = defaultProps;

exports.default = NumericTextBox;

},{"../services/Util":77,"classnames":2,"react":34}],64:[function(require,module,exports){
/**
 * PanelBar component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/08/18
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.PanelBar options={options} />
 *
 * Kendo PanelBar 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PanelBarPane = exports.PanelBar = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    contentUrls: _react.PropTypes.array
};

var defaultProps = {};

/** Class representing a PanelBar. */

var PanelBar = function (_Component) {
    _inherits(PanelBar, _Component);

    function PanelBar(props) {
        _classCallCheck(this, PanelBar);

        // Operations usually carried out in componentWillMount go here

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PanelBar).call(this, props));

        var id = props.id;
        if (typeof id === 'undefined') {
            id = _Util2.default.getUUID();
        }

        _this.id = id;

        // Manually bind this method to the component instance...
        _this.onSelect = _this.onSelect.bind(_this);
        return _this;
    }

    _createClass(PanelBar, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$panelBar = $('#' + this.id);
            this.panelBar = this.$panelBar.kendoPanelBar(this.options()).data('kendoPanelBar');

            // Events
            this.panelBar.bind('select', this.onSelect);

            // PanelBarPane 의 props id를 설정해야 Icon 설정을 할 수 있다.
            var panelBarPanes = [];
            if ($.isArray(this.props.children)) {
                panelBarPanes = this.props.children;
            } else {
                panelBarPanes = [this.props.children];
            }

            panelBarPanes.map(function (panelBarPane) {

                if (typeof panelBarPane.props.id !== 'undefined') {
                    var icon = void 0;
                    if (panelBarPane.props.iconClassName) {
                        icon = '<i class="' + panelBarPane.props.iconClassName + '"></i>';
                    }
                    if (panelBarPane.props.iconUrl) {
                        icon = '<img class="k-image" alt="" src="' + panelBarPane.props.iconUrl + '">';
                    }

                    $('#' + panelBarPane.props.id + ' > span.k-link.k-header').prepend(icon);
                }
            });
        }

        /**
         * @private
         */

    }, {
        key: 'options',
        value: function options() {
            return {};
        }

        //-----------------------------
        // methods

    }, {
        key: 'expand',
        value: function expand($item) {
            this.panelBar.expand($item);
        }

        //-----------------------------
        // events

    }, {
        key: 'onSelect',
        value: function onSelect(e) {}
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props = this.props;
            var className = _props.className;
            var children = _props.children;


            return _react2.default.createElement(
                'ul',
                { id: this.id, className: (0, _classnames2.default)(className) },
                children
            );
        }
    }]);

    return PanelBar;
}(_react.Component);

var propTypesPanelBarPane = {
    id: _react.PropTypes.string,
    title: _react.PropTypes.string,
    iconUrl: _react.PropTypes.string,
    iconClassName: _react.PropTypes.string,
    items: _react.PropTypes.array
};

/** Class representing a PanelBarPane. */

var PanelBarPane = function (_Component2) {
    _inherits(PanelBarPane, _Component2);

    function PanelBarPane(props) {
        _classCallCheck(this, PanelBarPane);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(PanelBarPane).call(this, props));
    }

    /**
     * @private
     */


    _createClass(PanelBarPane, [{
        key: 'renderPaneContent',
        value: function renderPaneContent() {
            var _props2 = this.props;
            var items = _props2.items;
            var children = _props2.children;
            var contentUrls = _props2.contentUrls;

            var content;

            if (items) {
                var _items = items.map(function (item) {
                    if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
                        var icon, text;
                        if (item.hasOwnProperty('spriteCssClass')) {
                            icon = _react2.default.createElement('span', { className: (0, _classnames2.default)(item.spriteCssClass) });
                        }
                        if (item.hasOwnProperty('imageUrl')) {
                            icon = _react2.default.createElement('img', { src: item.imageUrl });
                        }

                        if (item.hasOwnProperty('text')) {
                            text = item.text;
                        }

                        var data;
                        if (item.hasOwnProperty('data')) {
                            data = { data: JSON.stringify(item.data) };
                        }
                        //return (<li key={Util.uniqueID()}>{icon} {text}</li>);
                        return _react2.default.createElement(
                            'li',
                            data,
                            icon,
                            ' ',
                            text
                        );
                        //return <PanelBarPaneItem data={data}>{icon} {text}</PanelBarPaneItem>;
                    } else {
                            //return (<li key={Util.uniqueID()}>{item}</li>);
                            return _react2.default.createElement(
                                'li',
                                null,
                                item
                            );
                        }
                });
                content = _react2.default.createElement(
                    'ul',
                    null,
                    _items
                );
            } else if (children) {
                content = children;
            } else {
                // contentUrls 이라고 판단
                content = _react2.default.createElement('div', null);
            }

            return content;
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props3 = this.props;
            var id = _props3.id;
            var title = _props3.title;


            var _id;
            if (id) {
                _id = { id: id };
            }

            return _react2.default.createElement(
                'li',
                _id,
                title,
                this.renderPaneContent()
            );
        }
    }]);

    return PanelBarPane;
}(_react.Component);

/** Class representing a PanelBarPaneItem. */


var PanelBarPaneItem = function (_Component3) {
    _inherits(PanelBarPaneItem, _Component3);

    function PanelBarPaneItem(props) {
        _classCallCheck(this, PanelBarPaneItem);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(PanelBarPaneItem).call(this, props));
    }

    _createClass(PanelBarPaneItem, [{
        key: 'render',
        value: function render() {
            var data = this.props.data;

            return _react2.default.createElement(
                'li',
                data,
                this.props.children
            );
        }
    }]);

    return PanelBarPaneItem;
}(_react.Component);

PanelBar.propTypes = propTypes;
PanelBar.defaultProps = defaultProps;
PanelBarPane.propTypes = propTypesPanelBarPane;

exports.PanelBar = PanelBar;
exports.PanelBarPane = PanelBarPane;

},{"../services/Util":77,"classnames":2,"react":34}],65:[function(require,module,exports){
/**
 * ProgressBar component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/09/06
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.ProgressBar options={options} />
 *
 * Kendo ProgressBar 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    type: _react.PropTypes.oneOf(['value', 'percent', 'chunk']),
    value: _react.PropTypes.number,
    animation: _react.PropTypes.oneOfType([_react.PropTypes.number, _react.PropTypes.bool, _react.PropTypes.object]),
    min: _react.PropTypes.number,
    max: _react.PropTypes.number,
    enable: _react.PropTypes.bool,
    orientation: _react.PropTypes.oneOf(['horizontal', 'vertical']),
    onChange: _react.PropTypes.func,
    onComplete: _react.PropTypes.func
};

var defaultProps = {
    type: 'value',
    value: 0,
    animation: { duration: 600 },
    enable: true,
    orientation: 'horizontal'
};

/** Class representing a ProgressBar. */

var ProgressBar = function (_Component) {
    _inherits(ProgressBar, _Component);

    function ProgressBar(props) {
        _classCallCheck(this, ProgressBar);

        // Operations usually carried out in componentWillMount go here

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ProgressBar).call(this, props));

        var id = props.id;
        if (typeof id === 'undefined') {
            id = _Util2.default.getUUID();
        }

        _this.id = id;

        // Manually bind this method to the component instance...
        _this.onChange = _this.onChange.bind(_this);
        _this.onComplete = _this.onComplete.bind(_this);
        return _this;
    }

    _createClass(ProgressBar, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$progressBar = $('#' + this.id);
            this.progressBar = this.$progressBar.kendoProgressBar(this.options()).data('kendoProgressBar');

            // Events
            this.progressBar.bind('change', this.onChange);
            this.progressBar.bind('complete', this.onComplete);
        }

        /**
         * @private
         */

    }, {
        key: 'options',
        value: function options() {
            var _props = this.props;
            var type = _props.type;
            var value = _props.value;
            var animation = _props.animation;
            var enable = _props.enable;
            var orientation = _props.orientation;

            // animation

            var _animation;
            if (typeof animation === 'number') {
                _animation = { duration: animation };
            } else if (animation === true) {
                _animation = { duration: 600 };
            } else {
                _animation = animation;
            }

            var options = {
                type: type,
                value: value,
                animation: _animation,
                enable: enable,
                orientation: orientation
            };

            // min
            if (typeof min !== 'undefined') {
                $.extend(options, { min: min });
            }

            // max
            if (typeof max !== 'undefined') {
                $.extend(options, { max: max });
            }

            return options;
        }

        //-----------------------------
        // methods

    }, {
        key: 'value',
        value: function value(v) {
            if (arguments.length == 0) {
                return this.progressBar.value();
            } else {
                return this.progressBar.value(v);
            }
        }
    }, {
        key: 'enable',
        value: function enable(b) {
            if (arguments.length == 0) {
                this.progressBar.enable();
            } else {
                this.progressBar.enable(b);
            }
        }

        //-----------------------------
        // event

    }, {
        key: 'onChange',
        value: function onChange(e) {

            if (typeof this.props.onChange !== 'undefined') {
                this.props.onChange(e.value);
            }
        }
    }, {
        key: 'onComplete',
        value: function onComplete(e) {

            if (typeof this.props.onComplete !== 'undefined') {
                this.props.onComplete(e.value);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var className = this.props.className;


            return _react2.default.createElement('div', { id: this.id, className: (0, _classnames2.default)(className) });
        }
    }]);

    return ProgressBar;
}(_react.Component);

ProgressBar.propTypes = propTypes;
ProgressBar.defaultProps = defaultProps;

exports.default = ProgressBar;

},{"../services/Util":77,"classnames":2,"react":34}],66:[function(require,module,exports){
/**
 * Slider component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/11/24
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.Slider options={options} />
 *
 * Kendo Slider 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    width: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
    value: _react.PropTypes.number,
    min: _react.PropTypes.number,
    max: _react.PropTypes.number,
    orientation: _react.PropTypes.oneOf(['horizontal', 'vertical']).isRequired,
    dragHandleTitle: _react.PropTypes.string,
    showButtons: _react.PropTypes.bool,
    largeStep: _react.PropTypes.number,
    smallStep: _react.PropTypes.number,
    tickPlacement: _react.PropTypes.oneOf(['topLeft', 'bottomRight', 'both', 'none']).isRequired,
    tooltipEnabled: _react.PropTypes.bool,
    tooltipFormat: _react.PropTypes.string,
    tooltipTemplate: _react.PropTypes.string
};

var defaultProps = {
    value: 0,
    min: 0,
    max: 10,
    orientation: 'horizontal',
    dragHandleTitle: 'drag',
    showButtons: true,
    largeStep: 5,
    smallStep: 1,
    tickPlacement: 'both'
};

var Slider = function (_Component) {
    _inherits(Slider, _Component);

    function Slider(props) {
        _classCallCheck(this, Slider);

        // this.state = {
        //     data: [],
        //     count: props.initialCount
        // };

        // Manually bind this method to the component instance...

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Slider).call(this, props));

        _this.onChange = _this.onChange.bind(_this);
        _this.onSlide = _this.onSlide.bind(_this);
        return _this;
    }

    _createClass(Slider, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
            // 최초 렌더링이 일어나기 직전(한번 호출)
            var id = this.props.id;
            if (typeof id === 'undefined') {
                id = _Util2.default.getUUID();
            }

            this.id = id;
        }
    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$slider = $('#' + this.id);
            this.slider = this.$slider.kendoSlider(this.options(this.props)).data('kendoSlider');

            // Events
            this.slider.bind('change', this.onChange);
            this.slider.bind('slide', this.onSlide);
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {}
        // 컴포넌트가 새로운 props를 받을 때 호출(최초 렌더링 시에는 호출되지 않음)
        // if(this.props.min != nextProps.min || this.props.max != nextProps.max) {
        //     console.log('Slider componentWillReceiveProps', nextProps.max);
        //     this.slider.destroy();
        //     this.slider = this.$slider.kendoSlider(this.options(nextProps)).data('kendoSlider');

        //     // Events
        //     this.slider.bind('change', this.onChange);
        //     this.slider.bind('slide', this.onSlide);
        // }


        //-----------------------------
        // events

    }, {
        key: 'onChange',
        value: function onChange(e) {
            if (typeof this.props.onChange === 'function') {
                this.props.onChange(e, e.value);
                //e.stopImmediatePropagation();
            }
        }
    }, {
        key: 'onSlide',
        value: function onSlide(e) {
            if (typeof this.props.onSlide === 'function') {
                this.props.onSlide(e, e.value);
                //e.stopImmediatePropagation();
            }
        }

        //-----------------------------
        // methods

    }, {
        key: 'value',
        value: function value(val) {
            if (arguments.length == 0) {
                return this.slider.value();
            } else {
                return this.slider.value(val);
            }
        }
    }, {
        key: 'enable',
        value: function enable(isBool) {
            if (arguments.length == 0) {
                return this.slider.enable();
            } else {
                return this.slider.enable(isBool);
            }
        }
    }, {
        key: 'setWidth',
        value: function setWidth(val) {
            var w = 0;
            if (typeof val === 'number') {
                w = val;
            }
            this.slider.wrapper.css('width', w + 'px');
            this.slider.resize();
        }
    }, {
        key: 'destroy',
        value: function destroy() {
            var wrapper = this.slider.wrapper,
                element = this.slider.element;

            this.slider.destroy();
            wrapper.before(element.show());
            wrapper.remove();

            // this.slider.destroy();
            // this.$slider.closest('.k-slider').remove();
        }
    }, {
        key: 'create',
        value: function create(_options) {
            var options = this.options(this.props);
            $.extend(true, options, _options);
            this.slider = this.$slider.kendoSlider(options).data('kendoSlider');

            // Events
            this.slider.bind('change', this.onChange);
            this.slider.bind('slide', this.onSlide);
        }
    }, {
        key: 'setMax',
        value: function setMax(val) {
            this.$slider.prev().find('a').attr('aria-valuemax', val);
        }
    }, {
        key: 'setMin',
        value: function setMin(val) {
            this.$slider.prev().find('a').attr('aria-valuemin', val);
        }

        /**
         * @private
         */

    }, {
        key: 'options',
        value: function options(props) {
            var value = props.value;
            var min = props.min;
            var max = props.max;
            var orientation = props.orientation;
            var dragHandleTitle = props.dragHandleTitle;
            var showButtons = props.showButtons;
            var largeStep = props.largeStep;
            var smallStep = props.smallStep;
            var tickPlacement = props.tickPlacement;
            var tooltipEnabled = props.tooltipEnabled;
            var tooltipFormat = props.tooltipFormat;
            var tooltipTemplate = props.tooltipTemplate;


            var options = {
                value: value,
                min: min,
                max: max,
                orientation: orientation,
                dragHandleTitle: dragHandleTitle,
                showButtons: showButtons,
                largeStep: largeStep,
                smallStep: smallStep,
                tickPlacement: tickPlacement
            };

            // tooltip enabled
            if (typeof tooltipEnabled === 'boolean') {
                $.extend(options, { tooltip: { enabled: tooltipEnabled } });
            }

            // tooltip format
            if (typeof tooltipFormat === 'string') {
                $.extend(true, options, { tooltip: { format: tooltipFormat } });
            }

            // tooltip template
            if (typeof tooltipTemplate === 'string') {
                $.extend(true, options, { tooltip: { template: tooltipTemplate } });
            }

            return options;
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props = this.props;
            var className = _props.className;
            var width = _props.width;


            return _react2.default.createElement('input', { id: this.id, className: (0, _classnames2.default)(className), style: { width: width } });
        }
    }]);

    return Slider;
}(_react.Component);

Slider.propTypes = propTypes;
Slider.defaultProps = defaultProps;

exports.default = Slider;

},{"../services/Util":77,"classnames":2,"react":34}],67:[function(require,module,exports){
/**
 * TreeView component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/04/15
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.TreeView options={options} />
 *
 * Kendo TreeView 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    options: _react.PropTypes.object,
    host: _react.PropTypes.string,
    url: _react.PropTypes.string,
    method: _react.PropTypes.string,
    items: _react.PropTypes.array,
    data: _react.PropTypes.object,
    onDemand: _react.PropTypes.bool,
    dataTextField: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.array]),
    hasChildrenField: _react.PropTypes.string,
    childrenField: _react.PropTypes.string,
    checkboxes: _react.PropTypes.bool,
    dragAndDrop: _react.PropTypes.bool,
    template: _react.PropTypes.string,
    onSelect: _react.PropTypes.func,
    onChange: _react.PropTypes.func,
    onClick: _react.PropTypes.func,
    onDblclick: _react.PropTypes.func,
    onCollapse: _react.PropTypes.func,
    onExpand: _react.PropTypes.func
};

var defaultProps = {
    onDemand: false,
    method: 'POST',
    items: [],
    dataTextField: 'text',
    hasChildrenField: 'hasChildren',
    childrenField: 'items',
    dragAndDrop: false
};

/** Class representing a TreeView. */

var TreeView = function (_Component) {
    _inherits(TreeView, _Component);

    // static displayName = 'TreeView';

    function TreeView(props) {
        _classCallCheck(this, TreeView);

        // Operations usually carried out in componentWillMount go here

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TreeView).call(this, props));

        var id = props.id;
        if (typeof id === 'undefined') {
            id = _Util2.default.getUUID();
        }

        _this.id = id;

        // Manually bind this method to the component instance...
        _this.onSelect = _this.onSelect.bind(_this);
        _this.onCheck = _this.onCheck.bind(_this);
        _this.onChange = _this.onChange.bind(_this);
        _this.onCollapse = _this.onCollapse.bind(_this);
        _this.onExpand = _this.onExpand.bind(_this);

        _this.onDragStart = _this.onDragStart.bind(_this);
        _this.onDrag = _this.onDrag.bind(_this);
        _this.onDrop = _this.onDrop.bind(_this);
        _this.onDragEnd = _this.onDragEnd.bind(_this);
        _this.onNavigate = _this.onNavigate.bind(_this);

        _this.onClick = _this.onClick.bind(_this);
        _this.onDblclick = _this.onDblclick.bind(_this);

        // this._bind('_handleClick', '_handleFoo');
        return _this;
    }

    _createClass(TreeView, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$treeView = $('#' + this.id);
            this.treeView = this.$treeView.kendoTreeView(this.options()).data('kendoTreeView');

            // Events
            this.treeView.bind('select', this.onSelect);
            this.treeView.bind('check', this.onCheck);
            this.treeView.bind('change', this.onChange);
            this.treeView.bind('collapse', this.onCollapse);
            this.treeView.bind('expand', this.onExpand);

            /* drag & drop events */
            this.treeView.bind('dragstart', this.onDragStart);
            this.treeView.bind('drag', this.onDrag);
            this.treeView.bind('drop', this.onDrop);
            this.treeView.bind('dragend', this.onDragEnd);
            this.treeView.bind('navigate', this.onNavigate);

            //this.$treeView.find('.k-in').on('click', this.onClick);       // click이 select 보다 먼저 발생
            this.$treeView.on('click', '.k-in', this.onClick); // click이 select 보다 나중에 발생
            this.$treeView.find('.k-in').on('dblclick', this.onDblclick);
        }

        //-----------------------------
        // private
        /**
         * @private
         */

    }, {
        key: 'options',
        value: function options() {
            var _props = this.props;
            var host = _props.host;
            var url = _props.url;
            var method = _props.method;
            var data = _props.data;
            var items = _props.items;
            var onDemand = _props.onDemand;
            var dataTextField = _props.dataTextField;
            var hasChildrenField = _props.hasChildrenField;
            var childrenField = _props.childrenField;
            var checkboxes = _props.checkboxes;
            var dragAndDrop = _props.dragAndDrop;
            var template = _props.template;


            var options = {
                checkboxes: checkboxes, // true or false
                dataTextField: dataTextField,
                loadOnDemand: onDemand,
                dragAndDrop: dragAndDrop // true or false
            };

            //JSON.parse(JSON.stringify(data.treeVO).split('"children":').join('"items":')).items

            var model;
            // dataSource
            // url
            if (typeof url !== 'undefined' && childrenField != "children") {
                if (onDemand === true) {
                    model = {
                        id: 'id',
                        hasChildren: hasChildrenField,
                        children: childrenField
                    };
                } else {
                    model = {
                        children: childrenField
                    };
                }

                $.extend(options, { dataSource: new kendo.data.HierarchicalDataSource({
                        transport: {
                            read: {
                                url: host && host !== null && host.length > 0 ? host + url : url,
                                type: method,
                                dataType: 'json',
                                data: data,
                                contentType: 'application/json; charset=utf-8'
                            },
                            parameterMap: function parameterMap(data, type) {
                                // console.log(data, type);
                                return JSON.stringify(data);
                            }
                        },
                        schema: {
                            model: model
                        }
                    }) });
            } else if (typeof url !== 'undefined' && childrenField == 'children') {
                if (onDemand === true) {
                    model = {
                        hasChildren: hasChildrenField,
                        children: 'items'
                    };
                } else {
                    model = {
                        children: 'items'
                    };
                }

                $.extend(options, { dataSource: new kendo.data.HierarchicalDataSource({
                        transport: {
                            read: {
                                url: host && host !== null && host.length > 0 ? host + url : url,
                                type: method,
                                dataType: 'json',
                                data: data,
                                contentType: 'application/json; charset=utf-8'
                            },
                            parameterMap: function parameterMap(data, type) {
                                return JSON.stringify(data);
                            }
                        },
                        schema: {
                            model: model,
                            data: function data(response) {
                                response.treeVO = JSON.parse(JSON.stringify(response.treeVO).split('"children":').join('"items":')).items;
                                return response.treeVO;
                            }
                        }
                    }) });
            } else {
                $.extend(options, { dataSource: new kendo.data.HierarchicalDataSource({
                        data: items,
                        schema: {
                            model: {
                                children: childrenField
                            }
                        }
                    }) });
            }

            // template
            if (typeof template !== 'undefined') {
                $.extend(options, { template: template });
            }

            return options;
        }

        //-----------------------------
        // methods
        /**
         * Returns the data item to which the specified node is bound.
         * @param {(jQuery|Element|String)} node - A string, DOM element or jQuery object which represents the node. A string is treated as a jQuery selector.
         * @return  {kendo.data.Node} The model of the item that was passed as a parameter.
         */

    }, {
        key: 'dataItem',
        value: function dataItem(node) {
            return this.treeView.dataItem(node);
        }
    }, {
        key: 'parent',
        value: function parent(node) {
            return this.treeView.parent(node);
        }
    }, {
        key: 'select',
        value: function select(node) {
            if (arguments.length === 0) {
                return this.treeView.select();
            } else {
                return this.treeView.select(node);
            }
        }
    }, {
        key: 'append',
        value: function append(nodeData, parentNode, success) {
            return this.treeView.append(nodeData, parentNode, success);
        }
    }, {
        key: 'remove',
        value: function remove(node) {
            this.treeView.remove(node);
        }
    }, {
        key: 'expand',
        value: function expand(node) {
            this.treeView.expand(node);
        }
    }, {
        key: 'expandAll',
        value: function expandAll() {
            this.treeView.expand('.k-item');
        }
    }, {
        key: 'collapse',
        value: function collapse(node) {
            this.treeView.collapse(node);
        }
    }, {
        key: 'collapseAll',
        value: function collapseAll() {
            this.treeView.collapse('.k-item');
        }
    }, {
        key: 'enable',
        value: function enable(node) {
            this.treeView.enable(node);
        }
    }, {
        key: 'disable',
        value: function disable(node) {
            this.treeView.enable(node, false);
        }
    }, {
        key: 'enableAll',
        value: function enableAll() {
            this.treeView.enable('.k-item');
        }
    }, {
        key: 'disableAll',
        value: function disableAll() {
            this.treeView.enable('.k-item', false);
        }
    }, {
        key: 'filter',
        value: function filter(value) {
            if (value !== "") {
                this.treeView.dataSource.filter({
                    field: this.props.dataTextField,
                    operator: 'contains',
                    value: value
                });
            } else {
                this.treeView.dataSource.filter({});
            }
        }
    }, {
        key: 'sort',
        value: function sort(dir) {
            // dir은 'asc' or 'desc'
            this.treeView.dataSource.sort({
                field: this.props.dataTextField,
                dir: dir
            });
        }

        /**
         * Get dataSource.
         * @return {kendo.data.DataSource} TreeView data source.
         */

    }, {
        key: 'getDataSource',
        value: function getDataSource() {
            return this.treeView.dataSource;
        }

        /**
         * draggable
         */

    }, {
        key: 'draggable',
        value: function draggable() {
            this.$treeView.kendoDraggable({
                hint: function hint(element) {
                    return element.clone();
                }
            });
        }

        //-----------------------------
        // events

    }, {
        key: 'onSelect',
        value: function onSelect(event) {
            // 같은 노드를 select 할 경우 이벤트 발생하도록 하기 위해
            // click 이벤트시 k-state-selected 제거하고
            // select 이벤트시 추가한다.
            //console.log('treeview select');

            //$(event.node).find('span.k-in').addClass('k-state-selected');
            var node, selectedItem;

            if (typeof event.node === 'undefined') {
                //console.log('dispatch click');
                node = event;
                //$(node).find('span.k-in').addClass('k-state-selected');
                $(node).children(':first').find('span.k-in').addClass('k-state-selected');
                this.onSelectCall = false;
            } else {
                //console.log('click');
                node = event.node;
                this.onSelectCall = true;
            }
            selectedItem = this.treeView.dataItem(node);
            //var selectedItem = this.treeView.dataItem(event.node);
            //console.log(selectedItem);

            if (typeof this.props.onSelect === 'function') {
                this.props.onSelect(event, selectedItem);

                //event.stopImmediatePropagation();
            }
        }
    }, {
        key: 'onCheck',
        value: function onCheck(event) {
            //console.log("Checkbox changed: ");
            //console.log(event.node);
        }
    }, {
        key: 'onChange',
        value: function onChange(event) {
            //console.log("Selection changed");
            //console.log(event);

            if (typeof this.props.onChange === 'function') {
                //var data = event.node;
                this.props.onChange(event);
                //event.stopImmediatePropagation();
            }
        }
    }, {
        key: 'onCollapse',
        value: function onCollapse(e) {
            //console.log("Collapsing ");
            //console.log(event.node);
            var selectedItem = this.treeView.dataItem(e.node);
            //console.log(selectedItem);
            if (typeof this.props.onCollapse === 'function') {
                this.props.onCollapse(e, selectedItem);

                //e.stopImmediatePropagation();
            }
        }
    }, {
        key: 'onExpand',
        value: function onExpand(e) {
            //console.log("Expanding ");
            //console.log(event.node);
            // e.preventDefault();
            var _props2 = this.props;
            var url = _props2.url;
            var method = _props2.method;
            var data = _props2.data;
            var onDemand = _props2.onDemand;
            var hasChildrenField = _props2.hasChildrenField;
            var childrenField = _props2.childrenField;


            var node = e.node,
                selectedItem = this.treeView.dataItem(node),
                hasChildren = selectedItem[hasChildrenField],
                appended = selectedItem['appended'];

            if (onDemand === true && (hasChildren === true || hasChildren === 'true') && !appended) {
                console.log('onDemand');
                $.ajax({
                    type: method,
                    url: url,
                    dataType: 'json',
                    data: JSON.stringify(selectedItem),
                    contentType: 'application/json; charset=utf-8',
                    success: function (data) {
                        // console.log(data);
                        this.treeView.append(data, $(node));
                        selectedItem['appended'] = true;
                    }.bind(this)
                });
            }

            if (typeof this.props.onExpand === 'function') {
                this.props.onExpand(e, selectedItem);

                //e.stopImmediatePropagation();
            }
        }
    }, {
        key: 'onDragStart',
        value: function onDragStart(e) {
            //console.log("Started dragging ");
            //console.log(event.sourceNode);
            var selectedItem = this.treeView.dataItem(e.sourceNode);
            if (typeof this.props.onDragStart === 'function') {
                var item = selectedItem;
                this.props.onDragStart(e, item);

                //e.stopImmediatePropagation();
            }
        }
    }, {
        key: 'onDrag',
        value: function onDrag(e) {
            //console.log("Dragging ");
            //console.log(event.sourceNode);
            var selectedItem = this.treeView.dataItem(e.sourceNode),
                parentNode,
                parentItem;

            // treeview outside 로 drag하면 className of null 에러 처리
            // treeview 안에서 drag 할때만 부모 찾는다.
            if (this.$treeView.find(e.dropTarget).length > 0) {
                parentNode = this.treeView.parent(e.dropTarget);
                parentItem = this.treeView.dataItem(parentNode);
            }

            //console.log(parentItem);
            if (typeof this.props.onDrag === 'function') {
                this.props.onDrag(e, selectedItem, parentItem);

                //e.stopImmediatePropagation();
            }
        }
    }, {
        key: 'onDrop',
        value: function onDrop(e) {
            //console.log('TreeView Dropped');
            //console.log(e.valid);
            //console.log(e.sourceNode);
            //console.log(e.destinationNode);
            var selectedItem = this.treeView.dataItem(e.sourceNode),
                parentNode,
                parentItem;

            // treeview outside 로 drag하면 e.destinationNode 값이 undefined가 된다.
            if (typeof e.destinationNode !== 'undefined') {
                parentNode = this.treeView.parent(e.destinationNode);
                parentItem = this.treeView.dataItem(parentNode);
            }

            //console.log(parentItem);
            if (typeof this.props.onDrop === 'function') {
                this.props.onDrop(e, selectedItem, parentItem);

                //e.stopImmediatePropagation();
            }
        }
    }, {
        key: 'onDragEnd',
        value: function onDragEnd(e) {
            console.log('TreeView Finished dragging');
            //console.log(event.sourceNode);
            var selectedItem = this.treeView.dataItem(e.sourceNode),
                parentNode = this.treeView.parent(e.destinationNode),
                parentItem = this.treeView.dataItem(parentNode);

            if (typeof this.props.onDragEnd === 'function') {
                this.props.onDragEnd(e, selectedItem, parentItem);

                //event.stopImmediatePropagation();
            }
        }
    }, {
        key: 'onNavigate',
        value: function onNavigate(e) {
            //console.log("Navigate ");
            //console.log(event.node);
        }
    }, {
        key: 'onDataBound',
        value: function onDataBound(e) {
            console.log('onDataBound');
        }
    }, {
        key: 'onClick',
        value: function onClick(e) {
            /*
            var node = $(event.target).closest(".k-item"),
                selectedItem = this.treeView.dataItem(node);
            console.log('treeview click');
            //console.log(selectedItem);
            if(typeof this.props.onClick === 'function') {
                this.props.onClick(event, selectedItem);
                  //event.stopImmediatePropagation();
            }
            */
            // 같은 노드를 select 할 경우 이벤트 발생하도록 하기 위해
            // click 이벤트시 k-state-selected 제거하고
            // select 이벤트시 추가한다.
            //console.log($(event.target).hasClass('k-state-selected'));
            //console.log('treeview onclick');
            if (this.onSelectCall === false) {
                var node = $(e.target).closest(".k-item");
                $(e.target).removeClass('k-state-selected');
                this.treeView.trigger('select', node);
            }
            this.onSelectCall = false;
        }
    }, {
        key: 'onDblclick',
        value: function onDblclick(event) {
            var node = $(event.target).closest(".k-item"),
                selectedItem = this.treeView.dataItem(node);
            //console.log('onDblclick');
            //console.log(selectedItem);

            if (typeof this.props.onDblclick === 'function') {
                this.props.onDblclick(event, selectedItem);

                //event.stopImmediatePropagation();
            }
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var className = this.props.className;


            return _react2.default.createElement('div', { id: this.id, className: (0, _classnames2.default)(className) });
        }
    }]);

    return TreeView;
}(_react.Component);

TreeView.propTypes = propTypes;
TreeView.defaultProps = defaultProps;

exports.default = TreeView;

},{"../services/Util":77,"classnames":2,"react":34}],68:[function(require,module,exports){
/**
 * Window component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/09/06
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.Window options={options} />
 *
 * Kendo Window 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    id: _react.PropTypes.string,
    className: _react.PropTypes.string,
    title: _react.PropTypes.string,
    titleIconClassName: _react.PropTypes.string,
    visible: _react.PropTypes.bool,
    actions: _react.PropTypes.array, // ['Pin', 'Refresh', 'Minimize', 'Maximize', 'Close']
    modal: _react.PropTypes.bool,
    resizable: _react.PropTypes.bool,
    width: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
    height: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
    minWidth: _react.PropTypes.number,
    minHeight: _react.PropTypes.number,
    onOpen: _react.PropTypes.func,
    onClose: _react.PropTypes.func,
    onResize: _react.PropTypes.func,
    onDragStart: _react.PropTypes.func,
    onDragEnd: _react.PropTypes.func,
    onRefresh: _react.PropTypes.func,
    onActivate: _react.PropTypes.func,
    onDeactivate: _react.PropTypes.func
};

var defaultProps = {
    title: 'Title',
    titleIconClassName: 'window-title-icon',
    visible: true,
    actions: ['Minimize', 'Maximize', 'Close'], // Pin
    modal: false,
    resizable: true,
    minWidth: 150,
    minHeight: 100
};

/** Class representing a Window. */

var Window = function (_Component) {
    _inherits(Window, _Component);

    function Window(props) {
        _classCallCheck(this, Window);

        // Operations usually carried out in componentWillMount go here

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Window).call(this, props));

        var id = props.id;
        if (typeof id === 'undefined') {
            id = _Util2.default.getUUID();
        }

        _this.id = id;

        // Manually bind this method to the component instance...
        _this.onOpen = _this.onOpen.bind(_this);
        _this.onClose = _this.onClose.bind(_this);
        _this.onResize = _this.onResize.bind(_this);
        _this.onDragStart = _this.onDragStart.bind(_this);
        _this.onDragEnd = _this.onDragEnd.bind(_this);
        _this.onRefresh = _this.onRefresh.bind(_this);
        _this.onActivate = _this.onActivate.bind(_this);
        _this.onDeactivate = _this.onDeactivate.bind(_this);
        return _this;
    }

    _createClass(Window, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$window = $('#' + this.id);
            this.window = this.$window.kendoWindow(this.options()).data('kendoWindow');

            // Events
            this.window.bind('open', this.onOpen);
            this.window.bind('close', this.onClose);
            this.window.bind('resize', this.onResize);
            this.window.bind('dragstart', this.onDragStart);
            this.window.bind('dragend', this.onDragEnd);
            this.window.bind('refresh', this.onRefresh);
            this.window.bind('activate', this.onActivate);
            this.window.bind('deactivate', this.onDeactivate);

            var _props = this.props;
            var className = _props.className;
            var titleIconClassName = _props.titleIconClassName;
            // render의 div는 k-window-content 에 해당되는 dom이다.
            // 부모인 k-window 에 addClass 해준다.

            if (typeof className !== 'undefined') {
                this.$window.parent().addClass(className);
            }

            // title icon
            // this.window.wrapper.find('.k-window-title').prepend('<span class=' + titleIconClassName + '></span>');
            $('<span></span>').insertBefore(this.window.wrapper.find('.k-window-title')).addClass(titleIconClassName);
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            // 컴포넌트가 새로운 props를 받을 때 호출(최초 렌더링 시에는 호출되지 않음)
            if (typeof nextProps.titleIconClassName !== 'undefined' && nextProps.titleIconClassName !== this.props.titleIconClassName) {
                this.setTitleIcon(nextProps.titleIconClassName);
            }
        }

        /**
         * @private
         */

    }, {
        key: 'options',
        value: function options() {
            var _props2 = this.props;
            var title = _props2.title;
            var visible = _props2.visible;
            var actions = _props2.actions;
            var modal = _props2.modal;
            var resizable = _props2.resizable;
            var width = _props2.width;
            var height = _props2.height;
            var minWidth = _props2.minWidth;
            var minHeight = _props2.minHeight;


            var options = {
                title: title,
                visible: visible,
                actions: actions,
                modal: modal,
                resizable: resizable,
                minWidth: minWidth,
                minHeight: minHeight
            };

            // width
            if (typeof width !== 'undefined') {
                $.extend(options, { width: width });
            }

            // height
            if (typeof height !== 'undefined') {
                $.extend(options, { height: height });
            }

            return options;
        }

        //-----------------------------
        // methods

    }, {
        key: 'open',
        value: function open() {
            return this.window.open();
        }
    }, {
        key: 'close',
        value: function close() {
            return this.window.close();
        }
    }, {
        key: 'center',
        value: function center() {
            return this.window.center();
        }
    }, {
        key: 'pos',
        value: function pos(x, y) {
            this.$window.offset({ left: x, top: y });
        }
    }, {
        key: 'title',
        value: function title(val) {
            if (arguments.length == 0) {
                return this.window.title();
            } else {
                return this.window.title(val);
            }
        }
    }, {
        key: 'setTitleIcon',
        value: function setTitleIcon(iconClassName) {
            if (typeof iconClassName === 'string') {
                this.window.wrapper.find('.k-window-title').prev().attr('class', iconClassName);
            }
        }

        //-----------------------------
        // events

    }, {
        key: 'onOpen',
        value: function onOpen(e) {

            if (typeof this.props.onOpen !== 'undefined') {
                this.props.onOpen(e);
            }
        }
    }, {
        key: 'onClose',
        value: function onClose(e) {

            if (typeof this.props.onClose !== 'undefined') {
                this.props.onClose(e);
            }
        }
    }, {
        key: 'onResize',
        value: function onResize(e) {

            if (typeof this.props.onResize !== 'undefined') {
                this.props.onResize(e);
            }
        }
    }, {
        key: 'onDragStart',
        value: function onDragStart(e) {

            if (typeof this.props.onDragStart !== 'undefined') {
                this.props.onDragStart(e);
            }
        }
    }, {
        key: 'onDragEnd',
        value: function onDragEnd(e) {

            if (typeof this.props.onDragEnd !== 'undefined') {
                this.props.onDragEnd(e);
            }
        }
    }, {
        key: 'onRefresh',
        value: function onRefresh(e) {

            if (typeof this.props.onRefresh !== 'undefined') {
                this.props.onRefresh(e);
            }
        }
    }, {
        key: 'onActivate',
        value: function onActivate(e) {

            if (typeof this.props.onActivate !== 'undefined') {
                this.props.onActivate(e);
            }
        }
    }, {
        key: 'onDeactivate',
        value: function onDeactivate(e) {

            if (typeof this.props.onDeactivate !== 'undefined') {
                this.props.onDeactivate(e);
            }
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            var _props3 = this.props;
            var className = _props3.className;
            var children = _props3.children;


            return _react2.default.createElement(
                'div',
                { id: this.id },
                children
            );
        }
    }]);

    return Window;
}(_react.Component);

Window.propTypes = propTypes;
Window.defaultProps = defaultProps;

exports.default = Window;

},{"../services/Util":77,"classnames":2,"react":34}],69:[function(require,module,exports){
/**
 * Tab component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/08/06
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.Tab />
 *
 * Kendo TabStrip 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** Class representing a Tab. */

var Tab = function (_Component) {
    _inherits(Tab, _Component);

    function Tab(props) {
        _classCallCheck(this, Tab);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(Tab).call(this, props));
    }

    _createClass(Tab, [{
        key: 'render',
        value: function render() {
            // 필수 항목
            return _react2.default.createElement(
                'li',
                null,
                this.props.children
            );
        }
    }]);

    return Tab;
}(_react.Component);

exports.default = Tab;

},{"react":34}],70:[function(require,module,exports){
/**
 * TabContent component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/08/06
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.TabContent />
 *
 * Kendo TabStrip 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** Class representing a TabContent. */

var TabContent = function (_Component) {
    _inherits(TabContent, _Component);

    function TabContent(props) {
        _classCallCheck(this, TabContent);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(TabContent).call(this, props));
    }

    _createClass(TabContent, [{
        key: 'render',
        value: function render() {
            // 필수 항목
            return _react2.default.createElement(
                'div',
                null,
                this.props.children
            );
        }
    }]);

    return TabContent;
}(_react.Component);

exports.default = TabContent;

},{"react":34}],71:[function(require,module,exports){
/**
 * TabStrip component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/08/06
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.TabStrip className={className} selectedIndex={0} onSelect={func} />
 *
 * Kendo TabStrip 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Util = require('../../services/Util');

var _Util2 = _interopRequireDefault(_Util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var propTypes = {
    className: _react.PropTypes.string,
    selectedIndex: _react.PropTypes.number,
    contentUrls: _react.PropTypes.array,
    animation: _react.PropTypes.oneOfType([_react.PropTypes.object, _react.PropTypes.bool]),
    tabPosition: _react.PropTypes.oneOf(['left', 'right', 'bottom']),
    onSelect: _react.PropTypes.func,
    onActivate: _react.PropTypes.func,
    onShow: _react.PropTypes.func,
    onContentLoad: _react.PropTypes.func,
    onError: _react.PropTypes.func
};

var defaultProps = {
    selectedIndex: 0,
    animation: false
};

/** Class representing a TabStrip. */

var TabStrip = function (_Component) {
    _inherits(TabStrip, _Component);

    function TabStrip(props) {
        _classCallCheck(this, TabStrip);

        // Operations usually carried out in componentWillMount go here

        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(TabStrip).call(this, props));

        var id = props.id;
        if (typeof id === 'undefined') {
            id = _Util2.default.getUUID();
        }

        _this.id = id;

        // Manually bind this method to the component instance...
        _this.onSelect = _this.onSelect.bind(_this);
        _this.onActivate = _this.onActivate.bind(_this);
        _this.onShow = _this.onShow.bind(_this);
        _this.onContentLoad = _this.onContentLoad.bind(_this);
        _this.onError = _this.onError.bind(_this);
        return _this;
    }

    _createClass(TabStrip, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            // 최초 렌더링이 일어난 다음(한번 호출)
            this.$tabstrip = $('#' + this.id);
            this.tabstrip = this.$tabstrip.kendoTabStrip(this.options()).data('kendoTabStrip');

            // Events
            this.tabstrip.bind('select', this.onSelect);
            this.tabstrip.bind('activate', this.onActivate);
            this.tabstrip.bind('show', this.onShow);
            this.tabstrip.bind('contentLoad', this.onContentLoad);
            this.tabstrip.bind('error', this.onError);

            this.select(this.props.selectedIndex);
        }

        /**
         * @private
         */

    }, {
        key: 'options',
        value: function options() {
            var _props = this.props;
            var animation = _props.animation;
            var contentUrls = _props.contentUrls;
            var tabPosition = _props.tabPosition;

            // animation (false|object) true는 유효하지 않음

            var _animation;
            if (typeof animation === 'boolean' && animation === true) {
                _animation = {
                    open: {
                        effects: 'fadeIn'
                    }
                };
            } else {
                _animation = animation;
            }

            var options = {
                animation: _animation
            };

            // tabPosition
            if (tabPosition) {
                $.extend(options, { tabPosition: tabPosition });
            }

            // contentUrls
            if (contentUrls) {
                $.extend(options, { contentUrls: contentUrls });
            }

            return options;
        }

        //-----------------------------
        // methods

    }, {
        key: 'select',
        value: function select(index) {
            this.tabstrip.select(index);
        }

        //-----------------------------
        // events

    }, {
        key: 'onSelect',
        value: function onSelect(e) {
            //console.log('onSelect');
            //console.log(e);
            if (typeof this.props.onSelect === 'function') {
                this.props.onSelect(e); // e.item, index 알아내서 넘기자
            }
        }
    }, {
        key: 'onActivate',
        value: function onActivate(e) {
            //console.log('onActivate');
            //console.log(e);
            if (typeof this.props.onActivate === 'function') {
                this.props.onActivate(e);
            }
        }
    }, {
        key: 'onShow',
        value: function onShow(e) {
            //console.log('onShow');
            //console.log(e);
            if (typeof this.props.onShow === 'function') {
                this.props.onShow(e);
            }
        }
    }, {
        key: 'onContentLoad',
        value: function onContentLoad(e) {
            //console.log('onContentLoad');
            //console.log(e);
            if (typeof this.props.onContentLoad === 'function') {
                this.props.onContentLoad(e);
            }
        }
    }, {
        key: 'onError',
        value: function onError(e) {
            //console.log('onError');
            //console.log(e);
            if (typeof this.props.onError === 'function') {
                this.props.onError(e);
            }
        }

        /**
         * @private
         * render function
         */

    }, {
        key: 'renderChildren',
        value: function renderChildren() {
            var children = this.props.children,
                count = 0;

            return _react2.default.Children.map(children, function (child) {
                if (child === null) {
                    return null;
                }
                var result;

                // Tabs
                if (count++ === 0) {
                    result = _react2.default.cloneElement(child, {
                        children: _react2.default.Children.map(child.props.children, function (tab) {
                            if (tab === null) {
                                return null;
                            }

                            return _react2.default.cloneElement(tab);
                        })
                    });
                } else {
                    // TabContent
                    result = _react2.default.cloneElement(child);
                }
                return result;
            });
        }
    }, {
        key: 'render',
        value: function render() {
            // 필수 항목
            return _react2.default.createElement(
                'div',
                { id: this.id, className: this.props.className },
                this.renderChildren()
            );
        }
    }]);

    return TabStrip;
}(_react.Component);

TabStrip.propTypes = propTypes;
TabStrip.defaultProps = defaultProps;

exports.default = TabStrip;

},{"../../services/Util":77,"classnames":2,"react":34}],72:[function(require,module,exports){
/**
 * Tabs component
 *
 * version <tt>$ Version: 1.0 $</tt> date:2016/08/06
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 *
 * example:
 * <Puf.Tabs />
 *
 * Kendo TabStrip 라이브러리에 종속적이다.
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/** Class representing a Tabs. */

var Tabs = function (_Component) {
    _inherits(Tabs, _Component);

    function Tabs(props) {
        _classCallCheck(this, Tabs);

        return _possibleConstructorReturn(this, Object.getPrototypeOf(Tabs).call(this, props));
    }

    _createClass(Tabs, [{
        key: 'render',
        value: function render() {
            // 필수 항목
            return _react2.default.createElement(
                'ul',
                null,
                this.props.children
            );
        }
    }]);

    return Tabs;
}(_react.Component);

exports.default = Tabs;

},{"react":34}],73:[function(require,module,exports){
/**
 * ps-util services
 * 
 * version <tt>$ Version: 1.0 $</tt> date:2016/03/01
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 * 
 * example:
 * app.controller('Ctrl', ['$scope', 'psUtil', function($scope, psUtil) {
 * 	   var rootPath = psUtil.getRootPath();
 * }]);
 * 
 */
'use strict';

function getDateToString(date) {
	var year = date.getFullYear(),
	    month = zerofill(date.getMonth() + 1, 2),
	    day = zerofill(date.getDate(), 2),
	    hours = date.getHours() < 0 ? '00' : zerofill(date.getHours(), 2),
	    // daterangepicker hours 9시간 오버표시되는 버그로 인해 빼준다.
	minutes = zerofill(date.getMinutes(), 2),
	    seconds = zerofill(date.getSeconds(), 2),
	    dateString = year + '-' + month + '-' + day + ' ' + hours + ':' + minutes + ':' + seconds;

	return dateString;
}

function zerofill(n, digits) {
	var zero = '';
	n = n.toString();

	if (n.length < digits) {
		for (var i = 0; i < digits - n.length; i++) {
			zero += '0';
		}
	}

	return zero + n;
}

// date: 기준일, hours: 구하고자하는 이전 시간
function getLastDate(date, hours) {
	return new Date(Date.parse(date) - 1000 * 60 * 60 * hours);
}

module.exports = {
	getDateToString: getDateToString,
	getLastDate: getLastDate
};

},{}],74:[function(require,module,exports){
/**
 * NumberUtil services
 * 
 * version <tt>$ Version: 1.0 $</tt> date:2016/05/19
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 * 
 * example:
 * var NumberUtil = require('../services/NumberUtil');
 * NumberUtil.digit();
 *
 * Puf.NumberUtil.digit();
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var NumberUtil = function () {
  function NumberUtil() {
    _classCallCheck(this, NumberUtil);
  }

  _createClass(NumberUtil, null, [{
    key: 'digit',
    value: function digit(i) {
      var displayText;
      if (i < 10) {
        displayText = '0' + i;
      } else {
        displayText = i.toString();
      }
      return displayText;
    }
  }]);

  return NumberUtil;
}();

exports.default = NumberUtil;

},{}],75:[function(require,module,exports){
/**
 * RegExp services
 * 
 * version <tt>$ Version: 1.0 $</tt> date:2016/05/20
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 * 
 * example:
 * var RegExp = require('../services/RegExp');
 * RegExp.checkEmail(strValue);
 *
 * Puf.RegExp.checkEmail(strValue);
 */
'use strict';

var regExp_EMAIL = /[0-9a-zA-Z][_0-9a-zA-Z-]*@[_0-9a-zA-Z-]+(\.[_0-9a-zA-Z-]+){1,2}$/;

function checkEmail(strValue) {
  if (!strValue.match(regExp_EMAIL)) {
    return false;
  }
  return true;
}

module.exports = {
  checkEmail: checkEmail
};

},{}],76:[function(require,module,exports){
/**
 * Resource services
 * 
 * version <tt>$ Version: 1.0 $</tt> date:2016/06/03
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 * 
 * example:
 * Puf.Resource.loadResource();
 * Puf.Resource.i18n(key);
 *
 * 다국어 처리
 */
'use strict';

// load properties

var loadResource = function loadResource(name, path, mode, language, callback) {

	$.i18n.properties({
		name: name,
		path: path,
		mode: mode,
		language: language,
		callback: callback
		/*
  function() {
  	// Accessing a simple value through the map
  	jQuery.i18n.prop('msg_hello');
  	// Accessing a value with placeholders through the map
  	jQuery.i18n.prop('msg_complex', 'John');
  			// Accessing a simple value through a JS variable
  	alert(msg_hello +' '+ msg_world);
  	// Accessing a value with placeholders through a JS function
  	alert(msg_complex('John'));
  	alert(msg_hello);
     }
     */
	});
};

var i18n = function i18n(key) {
	//var args = '\'' + key + '\'';
	//for (var i=1; i<arguments.length; i++) {
	//   args += ', \'' + arguments[i] + '\'';
	//}
	//return eval('$.i18n.prop(' + args + ')');
	return $.i18n.prop.apply(this, arguments);
};

var i18nByKey = function i18nByKey(key) {
	//var args = '\'' + key + '\'';
	//for (var i=1; i<arguments.length; i++) {
	//	args += ', \'' + $.i18n.prop(arguments[i]) + '\'';
	//}
	//return eval('$.i18n.prop(' + args + ')');
	var args = [key];
	for (var i = 1; i < arguments.length; i++) {
		args.push($.i18n.prop(arguments[i]));
	}
	return $.i18n.prop.apply(this, args);
};

module.exports = {
	loadResource: loadResource,
	i18n: i18n,
	i18nByKey: i18nByKey
};

},{}],77:[function(require,module,exports){
/**
 * Util services
 * 
 * version <tt>$ Version: 1.0 $</tt> date:2016/03/01
 * author <a href="mailto:hrahn@nkia.co.kr">Ahn Hyung-Ro</a>
 * 
 * example:
 * var Util = require('../services/Util');
 * Util.getUUID();
 *
 */
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Util = function () {
	function Util() {
		_classCallCheck(this, Util);
	}

	_createClass(Util, null, [{
		key: 'getUUID',
		value: function getUUID() {
			return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
				var r = Math.random() * 16 | 0,
				    v = c == 'x' ? r : r & 0x3 | 0x8;
				return v.toString(16);
			});
		}
	}, {
		key: 'uniqueID',
		value: function uniqueID() {
			return 'id-' + Math.random().toString(36).substr(2, 9);
		}
	}, {
		key: 'sleep',
		value: function sleep(milliseconds) {
			var start = new Date().getTime();
			for (var i = 0; i < 1e7; i++) {
				if (new Date().getTime() - start > milliseconds) {
					break;
				}
			}
		}

		// 시작페이지로 설정

	}, {
		key: 'setStartPage',
		value: function setStartPage(obj, url) {
			obj.style.behavior = 'url(#default#homepage)';
			//obj.setHomePage('http://internet.scourt.go.kr/');
			obj.setHomePage(url);
		}

		// 쿠키 설정
		/*
  function setCookie(name, value, expires) {
  	// alert(name + ", " + value + ", " + expires);
  	document.cookie = name + "=" + escape(value) + "; path=/; expires=" + expires.toGMTString();
  }
  */

	}, {
		key: 'setCookie',
		value: function setCookie(cname, cvalue, exdays, cdomain) {
			var d = new Date();
			d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1000);
			var expires = 'expires=' + d.toUTCString();
			var domain;
			if (cdomain) {
				domain = '; domain=' + cdomain;
			}
			document.cookie = cname + '=' + escape(cvalue) + '; path=/; ' + expires + domain;
		}

		// 쿠키 가져오기
		/*
  function getCookie(Name) {
  	var search = Name + "="
  	if (document.cookie.length > 0) { // 쿠키가 설정되어 있다면
  		offset = document.cookie.indexOf(search)
  		if (offset != -1) { // 쿠키가 존재하면
  			offset += search.length
  			// set index of beginning of value
  			end = document.cookie.indexOf(";", offset)
  			// 쿠키 값의 마지막 위치 인덱스 번호 설정
  			if (end == -1)
  				end = document.cookie.length
  			return unescape(document.cookie.substring(offset, end))
  		}
  	}
  	return "";
  }
  */

	}, {
		key: 'getCookie',
		value: function getCookie(cname) {
			var name = cname + '=';
			var ca = document.cookie.split(';');
			for (var i = 0; i < ca.length; i++) {
				var c = ca[i];
				while (c.charAt(0) == ' ') {
					c = c.substring(1);
				}
				if (c.indexOf(name) == 0) {
					return unescape(c.substring(name.length, c.length));
				}
			}
			return '';
		}
	}]);

	return Util;
}();

exports.default = Util;

},{}]},{},[35])(35)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2NsYXNzbmFtZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL0tleUVzY2FwZVV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9Qb29sZWRDbGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3QuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q2hpbGRyZW4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q2xhc3MuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudFRyZWVIb29rLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RET01GYWN0b3JpZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0RWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RFbGVtZW50VmFsaWRhdG9yLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvUmVhY3RQdXJlQ29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9SZWFjdFZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi9jaGVja1JlYWN0VHlwZVNwZWMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL2dldEl0ZXJhdG9yRm4uanMiLCJub2RlX21vZHVsZXMvcmVhY3QvbGliL29ubHlDaGlsZC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9saWIvcmVhY3RQcm9kSW52YXJpYW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L2xpYi90cmF2ZXJzZUFsbENoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi9rZXlNaXJyb3IuanMiLCJub2RlX21vZHVsZXMvcmVhY3Qvbm9kZV9tb2R1bGVzL2ZianMvbGliL2tleU9mLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0L3JlYWN0LmpzIiwicmVhY3QtcHVmLmpzIiwic3JjXFxQdWYuanMiLCJzcmNcXGNoYXJ0c1xcaGlnaGNoYXJ0c1xcQ29sdW1uQ2hhcnQuanMiLCJzcmNcXGNoYXJ0c1xcaGlnaGNoYXJ0c1xcRGVmYXVsdENoYXJ0T3B0aW9uLmpzIiwic3JjXFxjaGFydHNcXGhpZ2hjaGFydHNcXEhpZ2hjaGFydHNPcHRpb24uanMiLCJzcmNcXGNoYXJ0c1xcaGlnaGNoYXJ0c1xcTGluZUNoYXJ0LmpzIiwic3JjXFxjaGFydHNcXGhpZ2hjaGFydHNcXFBpZUNoYXJ0LmpzIiwic3JjXFxjaGFydHNcXGhpZ2hjaGFydHNcXFNjYXR0ZXJDaGFydC5qcyIsInNyY1xcY29tcG9uZW50c1xcQWxlcnQuanMiLCJzcmNcXGNvbXBvbmVudHNcXEJ1dHRvbi5qcyIsInNyY1xcY29tcG9uZW50c1xcQnV0dG9uRHJvcGRvd24uanMiLCJzcmNcXGNvbXBvbmVudHNcXENoZWNrYm94LmpzIiwic3JjXFxjb21wb25lbnRzXFxGaWVsZHNldC5qcyIsInNyY1xcY29tcG9uZW50c1xcRmluZVVwbG9hZGVyLmpzIiwic3JjXFxjb21wb25lbnRzXFxIaWRkZW5Db250ZW50LmpzIiwic3JjXFxjb21wb25lbnRzXFxNYWluRnJhbWVTcGxpdHRlci5qcyIsInNyY1xcY29tcG9uZW50c1xcTW9kYWwuanMiLCJzcmNcXGNvbXBvbmVudHNcXFBhbmVsLmpzIiwic3JjXFxjb21wb25lbnRzXFxUb2dnbGVCdXR0b24uanMiLCJzcmNcXGNvbXBvbmVudHNcXHJhZGlvXFxSYWRpby5qcyIsInNyY1xcY29tcG9uZW50c1xccmFkaW9cXFJhZGlvRGl2aWRlci5qcyIsInNyY1xcY29tcG9uZW50c1xccmFkaW9cXFJhZGlvR3JvdXAuanMiLCJzcmNcXGtlbmRvXFxBdXRvQ29tcGxldGUuanMiLCJzcmNcXGtlbmRvXFxEYXRlUGlja2VyLmpzIiwic3JjXFxrZW5kb1xcRGF0ZVJhbmdlUGlja2VyLmpzIiwic3JjXFxrZW5kb1xcRHJvcERvd25MaXN0LmpzIiwic3JjXFxrZW5kb1xcR3JpZC5qcyIsInNyY1xca2VuZG9cXE11bHRpU2VsZWN0LmpzIiwic3JjXFxrZW5kb1xcTnVtZXJpY1RleHRCb3guanMiLCJzcmNcXGtlbmRvXFxQYW5lbEJhci5qcyIsInNyY1xca2VuZG9cXFByb2dyZXNzQmFyLmpzIiwic3JjXFxrZW5kb1xcU2xpZGVyLmpzIiwic3JjXFxrZW5kb1xcVHJlZVZpZXcuanMiLCJzcmNcXGtlbmRvXFxXaW5kb3cuanMiLCJzcmNcXGtlbmRvXFx0YWJzdHJpcFxcVGFiLmpzIiwic3JjXFxrZW5kb1xcdGFic3RyaXBcXFRhYkNvbnRlbnQuanMiLCJzcmNcXGtlbmRvXFx0YWJzdHJpcFxcVGFiU3RyaXAuanMiLCJzcmNcXGtlbmRvXFx0YWJzdHJpcFxcVGFicy5qcyIsInNyY1xcc2VydmljZXNcXERhdGVVdGlsLmpzIiwic3JjXFxzZXJ2aWNlc1xcTnVtYmVyVXRpbC5qcyIsInNyY1xcc2VydmljZXNcXFJlZ0V4cC5qcyIsInNyY1xcc2VydmljZXNcXFJlc291cmNlLmpzIiwic3JjXFxzZXJ2aWNlc1xcVXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMzdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNuT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7O0FBRUEsT0FBTyxPQUFQLEdBQWlCLFFBQVEsV0FBUixDQUFqQjs7Ozs7Ozs7OztBQ0tBOzs7OztBQUlBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOztBQUdBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQVVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUdBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFHQTs7OztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFEQSxJQUFJLFdBQVcsUUFBUSxxQkFBUixDQUFYOzs7O0FBRUosSUFBSSxTQUFTLFFBQVEsbUJBQVIsQ0FB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dGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiFcbiAgQ29weXJpZ2h0IChjKSAyMDE2IEplZCBXYXRzb24uXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG4gIGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgaGFzT3duID0ge30uaGFzT3duUHJvcGVydHk7XG5cblx0ZnVuY3Rpb24gY2xhc3NOYW1lcyAoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGNsYXNzZXMucHVzaChjbGFzc05hbWVzLmFwcGx5KG51bGwsIGFyZykpO1xuXHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBjbGFzc05hbWVzO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcblx0XHQvLyByZWdpc3RlciBhcyAnY2xhc3NuYW1lcycsIGNvbnNpc3RlbnQgd2l0aCBucG0gcGFja2FnZSBuYW1lXG5cdFx0ZGVmaW5lKCdjbGFzc25hbWVzJywgW10sIGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiBjbGFzc05hbWVzO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdHdpbmRvdy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblx0fVxufSgpKTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBLZXlFc2NhcGVVdGlsc1xuICogXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFVuZXNjYXBlIGFuZCB1bndyYXAga2V5IGZvciBodW1hbi1yZWFkYWJsZSBkaXNwbGF5XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byB1bmVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHVuZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIHVuZXNjYXBlKGtleSkge1xuICB2YXIgdW5lc2NhcGVSZWdleCA9IC8oPTB8PTIpL2c7XG4gIHZhciB1bmVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0wJzogJz0nLFxuICAgICc9Mic6ICc6J1xuICB9O1xuICB2YXIga2V5U3Vic3RyaW5nID0ga2V5WzBdID09PSAnLicgJiYga2V5WzFdID09PSAnJCcgPyBrZXkuc3Vic3RyaW5nKDIpIDoga2V5LnN1YnN0cmluZygxKTtcblxuICByZXR1cm4gKCcnICsga2V5U3Vic3RyaW5nKS5yZXBsYWNlKHVuZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiB1bmVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbn1cblxudmFyIEtleUVzY2FwZVV0aWxzID0ge1xuICBlc2NhcGU6IGVzY2FwZSxcbiAgdW5lc2NhcGU6IHVuZXNjYXBlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleUVzY2FwZVV0aWxzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBQb29sZWRDbGFzc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFN0YXRpYyBwb29sZXJzLiBTZXZlcmFsIGN1c3RvbSB2ZXJzaW9ucyBmb3IgZWFjaCBwb3RlbnRpYWwgbnVtYmVyIG9mXG4gKiBhcmd1bWVudHMuIEEgY29tcGxldGVseSBnZW5lcmljIHBvb2xlciBpcyBlYXN5IHRvIGltcGxlbWVudCwgYnV0IHdvdWxkXG4gKiByZXF1aXJlIGFjY2Vzc2luZyB0aGUgYGFyZ3VtZW50c2Agb2JqZWN0LiBJbiBlYWNoIG9mIHRoZXNlLCBgdGhpc2AgcmVmZXJzIHRvXG4gKiB0aGUgQ2xhc3MgaXRzZWxmLCBub3QgYW4gaW5zdGFuY2UuIElmIGFueSBvdGhlcnMgYXJlIG5lZWRlZCwgc2ltcGx5IGFkZCB0aGVtXG4gKiBoZXJlLCBvciBpbiB0aGVpciBvd24gZmlsZXMuXG4gKi9cbnZhciBvbmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChjb3B5RmllbGRzRnJvbSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBjb3B5RmllbGRzRnJvbSk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoY29weUZpZWxkc0Zyb20pO1xuICB9XG59O1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gS2xhc3MuaW5zdGFuY2VQb29sLnBvcCgpO1xuICAgIEtsYXNzLmNhbGwoaW5zdGFuY2UsIGExLCBhMik7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyKTtcbiAgfVxufTtcblxudmFyIHRocmVlQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMykge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzKTtcbiAgfVxufTtcblxudmFyIGZvdXJBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMywgYTQpO1xuICB9XG59O1xuXG52YXIgZml2ZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0LCBhNSk7XG4gIH1cbn07XG5cbnZhciBzdGFuZGFyZFJlbGVhc2VyID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gIHZhciBLbGFzcyA9IHRoaXM7XG4gICEoaW5zdGFuY2UgaW5zdGFuY2VvZiBLbGFzcykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gaW5zdGFuY2UgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IF9wcm9kSW52YXJpYW50KCcyNScpIDogdm9pZCAwO1xuICBpbnN0YW5jZS5kZXN0cnVjdG9yKCk7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoIDwgS2xhc3MucG9vbFNpemUpIHtcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogQXVnbWVudHMgYENvcHlDb25zdHJ1Y3RvcmAgdG8gYmUgYSBwb29sYWJsZSBjbGFzcywgYXVnbWVudGluZyBvbmx5IHRoZSBjbGFzc1xuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxuICogcHJvdG90eXBpY2FsIGBkZXN0cnVjdG9yYCBvbiBpbnN0YW5jZXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gQ29weUNvbnN0cnVjdG9yIENvbnN0cnVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzZXQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwb29sZXIgQ3VzdG9taXphYmxlIHBvb2xlci5cbiAqL1xudmFyIGFkZFBvb2xpbmdUbyA9IGZ1bmN0aW9uIChDb3B5Q29uc3RydWN0b3IsIHBvb2xlcikge1xuICB2YXIgTmV3S2xhc3MgPSBDb3B5Q29uc3RydWN0b3I7XG4gIE5ld0tsYXNzLmluc3RhbmNlUG9vbCA9IFtdO1xuICBOZXdLbGFzcy5nZXRQb29sZWQgPSBwb29sZXIgfHwgREVGQVVMVF9QT09MRVI7XG4gIGlmICghTmV3S2xhc3MucG9vbFNpemUpIHtcbiAgICBOZXdLbGFzcy5wb29sU2l6ZSA9IERFRkFVTFRfUE9PTF9TSVpFO1xuICB9XG4gIE5ld0tsYXNzLnJlbGVhc2UgPSBzdGFuZGFyZFJlbGVhc2VyO1xuICByZXR1cm4gTmV3S2xhc3M7XG59O1xuXG52YXIgUG9vbGVkQ2xhc3MgPSB7XG4gIGFkZFBvb2xpbmdUbzogYWRkUG9vbGluZ1RvLFxuICBvbmVBcmd1bWVudFBvb2xlcjogb25lQXJndW1lbnRQb29sZXIsXG4gIHR3b0FyZ3VtZW50UG9vbGVyOiB0d29Bcmd1bWVudFBvb2xlcixcbiAgdGhyZWVBcmd1bWVudFBvb2xlcjogdGhyZWVBcmd1bWVudFBvb2xlcixcbiAgZm91ckFyZ3VtZW50UG9vbGVyOiBmb3VyQXJndW1lbnRQb29sZXIsXG4gIGZpdmVBcmd1bWVudFBvb2xlcjogZml2ZUFyZ3VtZW50UG9vbGVyXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvb2xlZENsYXNzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdENoaWxkcmVuID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuJyk7XG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RQdXJlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdFB1cmVDb21wb25lbnQnKTtcbnZhciBSZWFjdENsYXNzID0gcmVxdWlyZSgnLi9SZWFjdENsYXNzJyk7XG52YXIgUmVhY3RET01GYWN0b3JpZXMgPSByZXF1aXJlKCcuL1JlYWN0RE9NRmFjdG9yaWVzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXMnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG52YXIgb25seUNoaWxkID0gcmVxdWlyZSgnLi9vbmx5Q2hpbGQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50O1xudmFyIGNyZWF0ZUZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeTtcbnZhciBjbG9uZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcbiAgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50O1xuICBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG4gIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jbG9uZUVsZW1lbnQ7XG59XG5cbnZhciBfX3NwcmVhZCA9IF9hc3NpZ247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgX19zcHJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcod2FybmVkLCAnUmVhY3QuX19zcHJlYWQgaXMgZGVwcmVjYXRlZCBhbmQgc2hvdWxkIG5vdCBiZSB1c2VkLiBVc2UgJyArICdPYmplY3QuYXNzaWduIGRpcmVjdGx5IG9yIGFub3RoZXIgaGVscGVyIGZ1bmN0aW9uIHdpdGggc2ltaWxhciAnICsgJ3NlbWFudGljcy4gWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byB5b3VyIGNvbXBpbGVyLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LXNwcmVhZC1kZXByZWNhdGlvbiBmb3IgbW9yZSBkZXRhaWxzLicpIDogdm9pZCAwO1xuICAgIHdhcm5lZCA9IHRydWU7XG4gICAgcmV0dXJuIF9hc3NpZ24uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIFJlYWN0ID0ge1xuXG4gIC8vIE1vZGVyblxuXG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBSZWFjdENoaWxkcmVuLm1hcCxcbiAgICBmb3JFYWNoOiBSZWFjdENoaWxkcmVuLmZvckVhY2gsXG4gICAgY291bnQ6IFJlYWN0Q2hpbGRyZW4uY291bnQsXG4gICAgdG9BcnJheTogUmVhY3RDaGlsZHJlbi50b0FycmF5LFxuICAgIG9ubHk6IG9ubHlDaGlsZFxuICB9LFxuXG4gIENvbXBvbmVudDogUmVhY3RDb21wb25lbnQsXG4gIFB1cmVDb21wb25lbnQ6IFJlYWN0UHVyZUNvbXBvbmVudCxcblxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50LFxuICBjbG9uZUVsZW1lbnQ6IGNsb25lRWxlbWVudCxcbiAgaXNWYWxpZEVsZW1lbnQ6IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudCxcblxuICAvLyBDbGFzc2ljXG5cbiAgUHJvcFR5cGVzOiBSZWFjdFByb3BUeXBlcyxcbiAgY3JlYXRlQ2xhc3M6IFJlYWN0Q2xhc3MuY3JlYXRlQ2xhc3MsXG4gIGNyZWF0ZUZhY3Rvcnk6IGNyZWF0ZUZhY3RvcnksXG4gIGNyZWF0ZU1peGluOiBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAvLyBDdXJyZW50bHkgYSBub29wLiBXaWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgYW5kIHRyYWNlIG1peGlucy5cbiAgICByZXR1cm4gbWl4aW47XG4gIH0sXG5cbiAgLy8gVGhpcyBsb29rcyBET00gc3BlY2lmaWMgYnV0IHRoZXNlIGFyZSBhY3R1YWxseSBpc29tb3JwaGljIGhlbHBlcnNcbiAgLy8gc2luY2UgdGhleSBhcmUganVzdCBnZW5lcmF0aW5nIERPTSBzdHJpbmdzLlxuICBET006IFJlYWN0RE9NRmFjdG9yaWVzLFxuXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICAvLyBEZXByZWNhdGVkIGhvb2sgZm9yIEpTWCBzcHJlYWQsIGRvbid0IHVzZSB0aGlzIGZvciBhbnl0aGluZy5cbiAgX19zcHJlYWQ6IF9fc3ByZWFkXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENoaWxkcmVuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xuXG52YXIgdHdvQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy50d29Bcmd1bWVudFBvb2xlcjtcbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBQb29sZWRDbGFzcy5mb3VyQXJndW1lbnRQb29sZXI7XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogdHJhdmVyc2FsLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIEZvckVhY2hCb29rS2VlcGluZ1xuICogQHBhcmFtIHshZnVuY3Rpb259IGZvckVhY2hGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIHRyYXZlcnNhbCB3aXRoLlxuICogQHBhcmFtIHs/Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIGNvbnRleHQgd2l0aC5cbiAqL1xuZnVuY3Rpb24gRm9yRWFjaEJvb2tLZWVwaW5nKGZvckVhY2hGdW5jdGlvbiwgZm9yRWFjaENvbnRleHQpIHtcbiAgdGhpcy5mdW5jID0gZm9yRWFjaEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBmb3JFYWNoQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5Gb3JFYWNoQm9va0tlZXBpbmcucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZnVuYyA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMuY291bnQgPSAwO1xufTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhGb3JFYWNoQm9va0tlZXBpbmcsIHR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmM7XG4gIHZhciBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gRm9yRWFjaEJvb2tLZWVwaW5nLmdldFBvb2xlZChmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIEZvckVhY2hCb29rS2VlcGluZy5yZWxlYXNlKHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbi8qKlxuICogUG9vbGVkQ2xhc3MgcmVwcmVzZW50aW5nIHRoZSBib29ra2VlcGluZyBhc3NvY2lhdGVkIHdpdGggcGVyZm9ybWluZyBhIGNoaWxkXG4gKiBtYXBwaW5nLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIE1hcEJvb2tLZWVwaW5nXG4gKiBAcGFyYW0geyEqfSBtYXBSZXN1bHQgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gbWFwRnVuY3Rpb24gRnVuY3Rpb24gdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKiBAcGFyYW0gez8qfSBtYXBDb250ZXh0IENvbnRleHQgdG8gcGVyZm9ybSBtYXBwaW5nIHdpdGguXG4gKi9cbmZ1bmN0aW9uIE1hcEJvb2tLZWVwaW5nKG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICB0aGlzLnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgdGhpcy5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gIHRoaXMuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbk1hcEJvb2tLZWVwaW5nLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gIHRoaXMua2V5UHJlZml4ID0gbnVsbDtcbiAgdGhpcy5mdW5jID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5jb3VudCA9IDA7XG59O1xuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKE1hcEJvb2tLZWVwaW5nLCBmb3VyQXJndW1lbnRQb29sZXIpO1xuXG5mdW5jdGlvbiBtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0KGJvb2tLZWVwaW5nLCBjaGlsZCwgY2hpbGRLZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGJvb2tLZWVwaW5nLnJlc3VsdDtcbiAgdmFyIGtleVByZWZpeCA9IGJvb2tLZWVwaW5nLmtleVByZWZpeDtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jO1xuICB2YXIgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cblxuICB2YXIgbWFwcGVkQ2hpbGQgPSBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xuICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKG1hcHBlZENoaWxkLCByZXN1bHQsIGNoaWxkS2V5LCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQpO1xuICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLFxuICAgICAgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAga2V5UHJlZml4ICsgKG1hcHBlZENoaWxkLmtleSAmJiAoIWNoaWxkIHx8IGNoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IGVzY2FwZVVzZXJQcm92aWRlZEtleShtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChtYXBwZWRDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgYXJyYXksIHByZWZpeCwgZnVuYywgY29udGV4dCkge1xuICB2YXIgZXNjYXBlZFByZWZpeCA9ICcnO1xuICBpZiAocHJlZml4ICE9IG51bGwpIHtcbiAgICBlc2NhcGVkUHJlZml4ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHByZWZpeCkgKyAnLyc7XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IE1hcEJvb2tLZWVwaW5nLmdldFBvb2xlZChhcnJheSwgZXNjYXBlZFByZWZpeCwgZnVuYywgY29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIE1hcEJvb2tLZWVwaW5nLnJlbGVhc2UodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoU2luZ2xlQ2hpbGREdW1teSh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkLCBuYW1lKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbiwgY29udGV4dCkge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXksIG51bGwpO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBjaGlsZHJlbiBvYmplY3QgKHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYCkgYW5kXG4gKiByZXR1cm4gYW4gYXJyYXkgd2l0aCBhcHByb3ByaWF0ZWx5IHJlLWtleWVkIGNoaWxkcmVuLlxuICpcbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi50b2FycmF5XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBSZWFjdENoaWxkcmVuID0ge1xuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIG1hcDogbWFwQ2hpbGRyZW4sXG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWw6IG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwsXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q2hpbGRyZW47IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2xhc3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfcHJvZEludmFyaWFudCA9IHJlcXVpcmUoJy4vcmVhY3RQcm9kSW52YXJpYW50JyksXG4gICAgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudCcpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgTUlYSU5TX0tFWSA9IGtleU9mKHsgbWl4aW5zOiBudWxsIH0pO1xuXG4vKipcbiAqIFBvbGljaWVzIHRoYXQgZGVzY3JpYmUgbWV0aG9kcyBpbiBgUmVhY3RDbGFzc0ludGVyZmFjZWAuXG4gKi9cbnZhciBTcGVjUG9saWN5ID0ga2V5TWlycm9yKHtcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIGRlZmluZWQgb25seSBvbmNlIGJ5IHRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIG9yIG1peGluLlxuICAgKi9cbiAgREVGSU5FX09OQ0U6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIG1heSBiZSBkZWZpbmVkIGJ5IGJvdGggdGhlIGNsYXNzIHNwZWNpZmljYXRpb24gYW5kIG1peGlucy5cbiAgICogU3Vic2VxdWVudCBkZWZpbml0aW9ucyB3aWxsIGJlIGNoYWluZWQuIFRoZXNlIG1ldGhvZHMgbXVzdCByZXR1cm4gdm9pZC5cbiAgICovXG4gIERFRklORV9NQU5ZOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBhcmUgb3ZlcnJpZGluZyB0aGUgYmFzZSBjbGFzcy5cbiAgICovXG4gIE9WRVJSSURFX0JBU0U6IG51bGwsXG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIGFyZSBzaW1pbGFyIHRvIERFRklORV9NQU5ZLCBleGNlcHQgd2UgYXNzdW1lIHRoZXkgcmV0dXJuXG4gICAqIG9iamVjdHMuIFdlIHRyeSB0byBtZXJnZSB0aGUga2V5cyBvZiB0aGUgcmV0dXJuIHZhbHVlcyBvZiBhbGwgdGhlIG1peGVkIGluXG4gICAqIGZ1bmN0aW9ucy4gSWYgdGhlcmUgaXMgYSBrZXkgY29uZmxpY3Qgd2UgdGhyb3cuXG4gICAqL1xuICBERUZJTkVfTUFOWV9NRVJHRUQ6IG51bGxcbn0pO1xuXG52YXIgaW5qZWN0ZWRNaXhpbnMgPSBbXTtcblxuLyoqXG4gKiBDb21wb3NpdGUgY29tcG9uZW50cyBhcmUgaGlnaGVyLWxldmVsIGNvbXBvbmVudHMgdGhhdCBjb21wb3NlIG90aGVyIGNvbXBvc2l0ZVxuICogb3IgaG9zdCBjb21wb25lbnRzLlxuICpcbiAqIFRvIGNyZWF0ZSBhIG5ldyB0eXBlIG9mIGBSZWFjdENsYXNzYCwgcGFzcyBhIHNwZWNpZmljYXRpb24gb2ZcbiAqIHlvdXIgbmV3IGNsYXNzIHRvIGBSZWFjdC5jcmVhdGVDbGFzc2AuIFRoZSBvbmx5IHJlcXVpcmVtZW50IG9mIHlvdXIgY2xhc3NcbiAqIHNwZWNpZmljYXRpb24gaXMgdGhhdCB5b3UgaW1wbGVtZW50IGEgYHJlbmRlcmAgbWV0aG9kLlxuICpcbiAqICAgdmFyIE15Q29tcG9uZW50ID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gKiAgICAgICByZXR1cm4gPGRpdj5IZWxsbyBXb3JsZDwvZGl2PjtcbiAqICAgICB9XG4gKiAgIH0pO1xuICpcbiAqIFRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIHN1cHBvcnRzIGEgc3BlY2lmaWMgcHJvdG9jb2wgb2YgbWV0aG9kcyB0aGF0IGhhdmVcbiAqIHNwZWNpYWwgbWVhbmluZyAoZS5nLiBgcmVuZGVyYCkuIFNlZSBgUmVhY3RDbGFzc0ludGVyZmFjZWAgZm9yXG4gKiBtb3JlIHRoZSBjb21wcmVoZW5zaXZlIHByb3RvY29sLiBBbnkgb3RoZXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBpbiB0aGVcbiAqIGNsYXNzIHNwZWNpZmljYXRpb24gd2lsbCBiZSBhdmFpbGFibGUgb24gdGhlIHByb3RvdHlwZS5cbiAqXG4gKiBAaW50ZXJmYWNlIFJlYWN0Q2xhc3NJbnRlcmZhY2VcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RDbGFzc0ludGVyZmFjZSA9IHtcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgTWl4aW4gb2JqZWN0cyB0byBpbmNsdWRlIHdoZW4gZGVmaW5pbmcgeW91ciBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHthcnJheX1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBtaXhpbnM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEFuIG9iamVjdCBjb250YWluaW5nIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgdGhhdCBzaG91bGQgYmUgZGVmaW5lZCBvblxuICAgKiB0aGUgY29tcG9uZW50J3MgY29uc3RydWN0b3IgaW5zdGVhZCBvZiBpdHMgcHJvdG90eXBlIChzdGF0aWMgbWV0aG9kcykuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc3RhdGljczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBwcm9wIHR5cGVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBwcm9wVHlwZXM6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgY29udGV4dCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29udGV4dFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgdGhpcyBjb21wb25lbnQgc2V0cyBmb3IgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8vID09PT0gRGVmaW5pdGlvbiBtZXRob2RzID09PT1cblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVmFsdWVzIGluIHRoZSBtYXBwaW5nIHdpbGwgYmUgc2V0IG9uXG4gICAqIGB0aGlzLnByb3BzYCBpZiB0aGF0IHByb3AgaXMgbm90IHNwZWNpZmllZCAoaS5lLiB1c2luZyBhbiBgaW5gIGNoZWNrKS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBiZWZvcmUgYGdldEluaXRpYWxTdGF0ZWAgYW5kIHRoZXJlZm9yZSBjYW5ub3QgcmVseVxuICAgKiBvbiBgdGhpcy5zdGF0ZWAgb3IgdXNlIGB0aGlzLnNldFN0YXRlYC5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIEludm9rZWQgb25jZSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgdXNlZFxuICAgKiBhcyB0aGUgaW5pdGlhbCB2YWx1ZSBvZiBgdGhpcy5zdGF0ZWAuXG4gICAqXG4gICAqICAgZ2V0SW5pdGlhbFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICogICAgIHJldHVybiB7XG4gICAqICAgICAgIGlzT246IGZhbHNlLFxuICAgKiAgICAgICBmb29CYXo6IG5ldyBCYXpGb28oKVxuICAgKiAgICAgfVxuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGdldEluaXRpYWxTdGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQsXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRDaGlsZENvbnRleHQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBVc2VzIHByb3BzIGZyb20gYHRoaXMucHJvcHNgIGFuZCBzdGF0ZSBmcm9tIGB0aGlzLnN0YXRlYCB0byByZW5kZXIgdGhlXG4gICAqIHN0cnVjdHVyZSBvZiB0aGUgY29tcG9uZW50LlxuICAgKlxuICAgKiBObyBndWFyYW50ZWVzIGFyZSBtYWRlIGFib3V0IHdoZW4gb3IgaG93IG9mdGVuIHRoaXMgbWV0aG9kIGlzIGludm9rZWQsIHNvXG4gICAqIGl0IG11c3Qgbm90IGhhdmUgc2lkZSBlZmZlY3RzLlxuICAgKlxuICAgKiAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAqICAgICB2YXIgbmFtZSA9IHRoaXMucHJvcHMubmFtZTtcbiAgICogICAgIHJldHVybiA8ZGl2PkhlbGxvLCB7bmFtZX0hPC9kaXY+O1xuICAgKiAgIH1cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gICAqIEBub3NpZGVlZmZlY3RzXG4gICAqIEByZXF1aXJlZFxuICAgKi9cbiAgcmVuZGVyOiBTcGVjUG9saWN5LkRFRklORV9PTkNFLFxuXG4gIC8vID09PT0gRGVsZWdhdGUgbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGluaXRpYWxseSBjcmVhdGVkIGFuZCBhYm91dCB0byBiZSBtb3VudGVkLlxuICAgKiBUaGlzIG1heSBoYXZlIHNpZGUgZWZmZWN0cywgYnV0IGFueSBleHRlcm5hbCBzdWJzY3JpcHRpb25zIG9yIGRhdGEgY3JlYXRlZFxuICAgKiBieSB0aGlzIG1ldGhvZCBtdXN0IGJlIGNsZWFuZWQgdXAgaW4gYGNvbXBvbmVudFdpbGxVbm1vdW50YC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsTW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGhhcyBiZWVuIG1vdW50ZWQgYW5kIGhhcyBhIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICogSG93ZXZlciwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIERPTSBub2RlIGlzIGluIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiBtb3VudGVkIChpbml0aWFsaXplZCBhbmQgcmVuZGVyZWQpIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRNb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCByZWNlaXZlcyBuZXcgcHJvcHMuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHJlYWN0IHRvIGEgcHJvcCB0cmFuc2l0aW9uIGJ5IHVwZGF0aW5nIHRoZVxuICAgKiBzdGF0ZSB1c2luZyBgdGhpcy5zZXRTdGF0ZWAuIEN1cnJlbnQgcHJvcHMgYXJlIGFjY2Vzc2VkIHZpYSBgdGhpcy5wcm9wc2AuXG4gICAqXG4gICAqICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0Q29udGV4dCkge1xuICAgKiAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAqICAgICAgIGxpa2VzSW5jcmVhc2luZzogbmV4dFByb3BzLmxpa2VDb3VudCA+IHRoaXMucHJvcHMubGlrZUNvdW50XG4gICAqICAgICB9KTtcbiAgICogICB9XG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGVxdWl2YWxlbnQgYGNvbXBvbmVudFdpbGxSZWNlaXZlU3RhdGVgLiBBbiBpbmNvbWluZyBwcm9wXG4gICAqIHRyYW5zaXRpb24gbWF5IGNhdXNlIGEgc3RhdGUgY2hhbmdlLCBidXQgdGhlIG9wcG9zaXRlIGlzIG5vdCB0cnVlLiBJZiB5b3VcbiAgICogbmVlZCBpdCwgeW91IGFyZSBwcm9iYWJseSBsb29raW5nIGZvciBgY29tcG9uZW50V2lsbFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoaWxlIGRlY2lkaW5nIGlmIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHVwZGF0ZWQgYXMgYSByZXN1bHQgb2ZcbiAgICogcmVjZWl2aW5nIG5ldyBwcm9wcywgc3RhdGUgYW5kL29yIGNvbnRleHQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGByZXR1cm4gZmFsc2VgIHdoZW4geW91J3JlIGNlcnRhaW4gdGhhdCB0aGVcbiAgICogdHJhbnNpdGlvbiB0byB0aGUgbmV3IHByb3BzL3N0YXRlL2NvbnRleHQgd2lsbCBub3QgcmVxdWlyZSBhIGNvbXBvbmVudFxuICAgKiB1cGRhdGUuXG4gICAqXG4gICAqICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBmdW5jdGlvbihuZXh0UHJvcHMsIG5leHRTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHJldHVybiAhZXF1YWwobmV4dFByb3BzLCB0aGlzLnByb3BzKSB8fFxuICAgKiAgICAgICAhZXF1YWwobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSB8fFxuICAgKiAgICAgICAhZXF1YWwobmV4dENvbnRleHQsIHRoaXMuY29udGV4dCk7XG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dFN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbmV4dENvbnRleHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IHNob3VsZCB1cGRhdGUuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgc2hvdWxkQ29tcG9uZW50VXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9PTkNFLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBhYm91dCB0byB1cGRhdGUgZHVlIHRvIGEgdHJhbnNpdGlvbiBmcm9tXG4gICAqIGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YCB0byBgbmV4dFByb3BzYCwgYG5leHRTdGF0ZWBcbiAgICogYW5kIGBuZXh0Q29udGV4dGAuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHBlcmZvcm0gcHJlcGFyYXRpb24gYmVmb3JlIGFuIHVwZGF0ZSBvY2N1cnMuXG4gICAqXG4gICAqIE5PVEU6IFlvdSAqKmNhbm5vdCoqIHVzZSBgdGhpcy5zZXRTdGF0ZSgpYCBpbiB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVXBkYXRlOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCdzIERPTSByZXByZXNlbnRhdGlvbiBoYXMgYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBvcGVyYXRlIG9uIHRoZSBET00gd2hlbiB0aGUgY29tcG9uZW50IGhhc1xuICAgKiBiZWVuIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBwcmV2Q29udGV4dFxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IHJvb3ROb2RlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50LlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudERpZFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZCBmcm9tIGl0cyBwYXJlbnQgYW5kIGhhdmVcbiAgICogaXRzIERPTSByZXByZXNlbnRhdGlvbiBkZXN0cm95ZWQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIGRlYWxsb2NhdGUgYW55IGV4dGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogTk9URTogVGhlcmUgaXMgbm8gYGNvbXBvbmVudERpZFVubW91bnRgIHNpbmNlIHlvdXIgY29tcG9uZW50IHdpbGwgaGF2ZSBiZWVuXG4gICAqIGRlc3Ryb3llZCBieSB0aGF0IHBvaW50LlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8vID09PT0gQWR2YW5jZWQgbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudCdzIGN1cnJlbnRseSBtb3VudGVkIERPTSByZXByZXNlbnRhdGlvbi5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgdGhpcyBpbXBsZW1lbnRzIFJlYWN0J3MgcmVuZGVyaW5nIGFuZCByZWNvbmNpbGlhdGlvbiBhbGdvcml0aG0uXG4gICAqIFNvcGhpc3RpY2F0ZWQgY2xpZW50cyBtYXkgd2lzaCB0byBvdmVycmlkZSB0aGlzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAb3ZlcnJpZGFibGVcbiAgICovXG4gIHVwZGF0ZUNvbXBvbmVudDogU3BlY1BvbGljeS5PVkVSUklERV9CQVNFXG5cbn07XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGNsYXNzIHNwZWNpZmljYXRpb24ga2V5cyB0byBzcGVjaWFsIHByb2Nlc3NpbmcgZnVuY3Rpb25zLlxuICpcbiAqIEFsdGhvdWdoIHRoZXNlIGFyZSBkZWNsYXJlZCBsaWtlIGluc3RhbmNlIHByb3BlcnRpZXMgaW4gdGhlIHNwZWNpZmljYXRpb25cbiAqIHdoZW4gZGVmaW5pbmcgY2xhc3NlcyB1c2luZyBgUmVhY3QuY3JlYXRlQ2xhc3NgLCB0aGV5IGFyZSBhY3R1YWxseSBzdGF0aWNcbiAqIGFuZCBhcmUgYWNjZXNzaWJsZSBvbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZCBvZiB0aGUgcHJvdG90eXBlLiBEZXNwaXRlXG4gKiBiZWluZyBzdGF0aWMsIHRoZXkgbXVzdCBiZSBkZWZpbmVkIG91dHNpZGUgb2YgdGhlIFwic3RhdGljc1wiIGtleSB1bmRlclxuICogd2hpY2ggYWxsIG90aGVyIHN0YXRpYyBtZXRob2RzIGFyZSBkZWZpbmVkLlxuICovXG52YXIgUkVTRVJWRURfU1BFQ19LRVlTID0ge1xuICBkaXNwbGF5TmFtZTogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBkaXNwbGF5TmFtZSkge1xuICAgIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIH0sXG4gIG1peGluczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBtaXhpbnMpIHtcbiAgICBpZiAobWl4aW5zKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1peGlucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3RvciwgbWl4aW5zW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNoaWxkQ29udGV4dFR5cGVzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY2hpbGRDb250ZXh0VHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMuY2hpbGRDb250ZXh0KTtcbiAgICB9XG4gICAgQ29uc3RydWN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0VHlwZXMpO1xuICB9LFxuICBjb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNvbnRleHQpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMsIGNvbnRleHRUeXBlcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBTcGVjaWFsIGNhc2UgZ2V0RGVmYXVsdFByb3BzIHdoaWNoIHNob3VsZCBtb3ZlIGludG8gc3RhdGljcyBidXQgcmVxdWlyZXNcbiAgICogYXV0b21hdGljIG1lcmdpbmcuXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgaWYgKENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcykge1xuICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24oQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLCBnZXREZWZhdWx0UHJvcHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHM7XG4gICAgfVxuICB9LFxuICBwcm9wVHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvcFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgcHJvcFR5cGVzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMgPSBfYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5wcm9wVHlwZXMsIHByb3BUeXBlcyk7XG4gIH0sXG4gIHN0YXRpY3M6IGZ1bmN0aW9uIChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICAgIG1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzdGF0aWNzKTtcbiAgfSxcbiAgYXV0b2JpbmQ6IGZ1bmN0aW9uICgpIHt9IH07XG5cbi8vIG5vb3BcbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgdHlwZURlZiwgbG9jYXRpb24pIHtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gdHlwZURlZikge1xuICAgIGlmICh0eXBlRGVmLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgLy8gdXNlIGEgd2FybmluZyBpbnN0ZWFkIG9mIGFuIGludmFyaWFudCBzbyBjb21wb25lbnRzXG4gICAgICAvLyBkb24ndCBzaG93IHVwIGluIHByb2QgYnV0IG9ubHkgaW4gX19ERVZfX1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIHR5cGVEZWZbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ1JlYWN0LlByb3BUeXBlcy4nLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKGlzQWxyZWFkeURlZmluZWQsIG5hbWUpIHtcbiAgdmFyIHNwZWNQb2xpY3kgPSBSZWFjdENsYXNzSW50ZXJmYWNlLmhhc093blByb3BlcnR5KG5hbWUpID8gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXSA6IG51bGw7XG5cbiAgLy8gRGlzYWxsb3cgb3ZlcnJpZGluZyBvZiBiYXNlIGNsYXNzIG1ldGhvZHMgdW5sZXNzIGV4cGxpY2l0bHkgYWxsb3dlZC5cbiAgaWYgKFJlYWN0Q2xhc3NNaXhpbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICEoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5PVkVSUklERV9CQVNFKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gb3ZlcnJpZGUgYCVzYCBmcm9tIHlvdXIgY2xhc3Mgc3BlY2lmaWNhdGlvbi4gRW5zdXJlIHRoYXQgeW91ciBtZXRob2QgbmFtZXMgZG8gbm90IG92ZXJsYXAgd2l0aCBSZWFjdCBtZXRob2RzLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzczJywgbmFtZSkgOiB2b2lkIDA7XG4gIH1cblxuICAvLyBEaXNhbGxvdyBkZWZpbmluZyBtZXRob2RzIG1vcmUgdGhhbiBvbmNlIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gIGlmIChpc0FscmVhZHlEZWZpbmVkKSB7XG4gICAgIShzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZIHx8IHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VEKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzSW50ZXJmYWNlOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lIGAlc2Agb24geW91ciBjb21wb25lbnQgbW9yZSB0aGFuIG9uY2UuIFRoaXMgY29uZmxpY3QgbWF5IGJlIGR1ZSB0byBhIG1peGluLicsIG5hbWUpIDogX3Byb2RJbnZhcmlhbnQoJzc0JywgbmFtZSkgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBNaXhpbiBoZWxwZXIgd2hpY2ggaGFuZGxlcyBwb2xpY3kgdmFsaWRhdGlvbiBhbmQgcmVzZXJ2ZWRcbiAqIHNwZWNpZmljYXRpb24ga2V5cyB3aGVuIGJ1aWxkaW5nIFJlYWN0IGNsYXNzZXMuXG4gKi9cbmZ1bmN0aW9uIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKSB7XG4gIGlmICghc3BlYykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgdHlwZW9mU3BlYyA9IHR5cGVvZiBzcGVjO1xuICAgICAgdmFyIGlzTWl4aW5WYWxpZCA9IHR5cGVvZlNwZWMgPT09ICdvYmplY3QnICYmIHNwZWMgIT09IG51bGw7XG5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGlzTWl4aW5WYWxpZCwgJyVzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvIGluY2x1ZGUgYSBtaXhpbiB0aGF0IGlzIGVpdGhlciBudWxsICcgKyAnb3Igbm90IGFuIG9iamVjdC4gQ2hlY2sgdGhlIG1peGlucyBpbmNsdWRlZCBieSB0aGUgY29tcG9uZW50LCAnICsgJ2FzIHdlbGwgYXMgYW55IG1peGlucyB0aGV5IGluY2x1ZGUgdGhlbXNlbHZlcy4gJyArICdFeHBlY3RlZCBvYmplY3QgYnV0IGdvdCAlcy4nLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsIHNwZWMgPT09IG51bGwgPyBudWxsIDogdHlwZW9mU3BlYykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgISh0eXBlb2Ygc3BlYyAhPT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogWW91XFwncmUgYXR0ZW1wdGluZyB0byB1c2UgYSBjb21wb25lbnQgY2xhc3Mgb3IgZnVuY3Rpb24gYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nKSA6IF9wcm9kSW52YXJpYW50KCc3NScpIDogdm9pZCAwO1xuICAhIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzcGVjKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGNvbXBvbmVudCBhcyBhIG1peGluLiBJbnN0ZWFkLCBqdXN0IHVzZSBhIHJlZ3VsYXIgb2JqZWN0LicpIDogX3Byb2RJbnZhcmlhbnQoJzc2JykgOiB2b2lkIDA7XG5cbiAgdmFyIHByb3RvID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICB2YXIgYXV0b0JpbmRQYWlycyA9IHByb3RvLl9fcmVhY3RBdXRvQmluZFBhaXJzO1xuXG4gIC8vIEJ5IGhhbmRsaW5nIG1peGlucyBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMsIHdlIGVuc3VyZSB0aGUgc2FtZVxuICAvLyBjaGFpbmluZyBvcmRlciBpcyBhcHBsaWVkIHRvIG1ldGhvZHMgd2l0aCBERUZJTkVfTUFOWSBwb2xpY3ksIHdoZXRoZXJcbiAgLy8gbWl4aW5zIGFyZSBsaXN0ZWQgYmVmb3JlIG9yIGFmdGVyIHRoZXNlIG1ldGhvZHMgaW4gdGhlIHNwZWMuXG4gIGlmIChzcGVjLmhhc093blByb3BlcnR5KE1JWElOU19LRVkpKSB7XG4gICAgUkVTRVJWRURfU1BFQ19LRVlTLm1peGlucyhDb25zdHJ1Y3Rvciwgc3BlYy5taXhpbnMpO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBzcGVjKSB7XG4gICAgaWYgKCFzcGVjLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gTUlYSU5TX0tFWSkge1xuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWQgbWl4aW5zIGluIGEgc3BlY2lhbCBjYXNlIGFib3ZlLlxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHByb3BlcnR5ID0gc3BlY1tuYW1lXTtcbiAgICB2YXIgaXNBbHJlYWR5RGVmaW5lZCA9IHByb3RvLmhhc093blByb3BlcnR5KG5hbWUpO1xuICAgIHZhbGlkYXRlTWV0aG9kT3ZlcnJpZGUoaXNBbHJlYWR5RGVmaW5lZCwgbmFtZSk7XG5cbiAgICBpZiAoUkVTRVJWRURfU1BFQ19LRVlTLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBSRVNFUlZFRF9TUEVDX0tFWVNbbmFtZV0oQ29uc3RydWN0b3IsIHByb3BlcnR5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0dXAgbWV0aG9kcyBvbiBwcm90b3R5cGU6XG4gICAgICAvLyBUaGUgZm9sbG93aW5nIG1lbWJlciBtZXRob2RzIHNob3VsZCBub3QgYmUgYXV0b21hdGljYWxseSBib3VuZDpcbiAgICAgIC8vIDEuIEV4cGVjdGVkIFJlYWN0Q2xhc3MgbWV0aG9kcyAoaW4gdGhlIFwiaW50ZXJmYWNlXCIpLlxuICAgICAgLy8gMi4gT3ZlcnJpZGRlbiBtZXRob2RzICh0aGF0IHdlcmUgbWl4ZWQgaW4pLlxuICAgICAgdmFyIGlzUmVhY3RDbGFzc01ldGhvZCA9IFJlYWN0Q2xhc3NJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIHZhciBzaG91bGRBdXRvQmluZCA9IGlzRnVuY3Rpb24gJiYgIWlzUmVhY3RDbGFzc01ldGhvZCAmJiAhaXNBbHJlYWR5RGVmaW5lZCAmJiBzcGVjLmF1dG9iaW5kICE9PSBmYWxzZTtcblxuICAgICAgaWYgKHNob3VsZEF1dG9CaW5kKSB7XG4gICAgICAgIGF1dG9CaW5kUGFpcnMucHVzaChuYW1lLCBwcm9wZXJ0eSk7XG4gICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICAgICAgIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXTtcblxuICAgICAgICAgIC8vIFRoZXNlIGNhc2VzIHNob3VsZCBhbHJlYWR5IGJlIGNhdWdodCBieSB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlLlxuICAgICAgICAgICEoaXNSZWFjdENsYXNzTWV0aG9kICYmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCB8fCBzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogVW5leHBlY3RlZCBzcGVjIHBvbGljeSAlcyBmb3Iga2V5ICVzIHdoZW4gbWl4aW5nIGluIGNvbXBvbmVudCBzcGVjcy4nLCBzcGVjUG9saWN5LCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3NycsIHNwZWNQb2xpY3ksIG5hbWUpIDogdm9pZCAwO1xuXG4gICAgICAgICAgLy8gRm9yIG1ldGhvZHMgd2hpY2ggYXJlIGRlZmluZWQgbW9yZSB0aGFuIG9uY2UsIGNhbGwgdGhlIGV4aXN0aW5nXG4gICAgICAgICAgLy8gbWV0aG9kcyBiZWZvcmUgY2FsbGluZyB0aGUgbmV3IHByb3BlcnR5LCBtZXJnaW5nIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgICAgIGlmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCkge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihwcm90b1tuYW1lXSwgcHJvcGVydHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWSkge1xuICAgICAgICAgICAgcHJvdG9bbmFtZV0gPSBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9bbmFtZV0gPSBwcm9wZXJ0eTtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgLy8gQWRkIHZlcmJvc2UgZGlzcGxheU5hbWUgdG8gdGhlIGZ1bmN0aW9uLCB3aGljaCBoZWxwcyB3aGVuIGxvb2tpbmdcbiAgICAgICAgICAgIC8vIGF0IHByb2ZpbGluZyB0b29scy5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgPT09ICdmdW5jdGlvbicgJiYgc3BlYy5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICBwcm90b1tuYW1lXS5kaXNwbGF5TmFtZSA9IHNwZWMuZGlzcGxheU5hbWUgKyAnXycgKyBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcykge1xuICBpZiAoIXN0YXRpY3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgbmFtZSBpbiBzdGF0aWNzKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gc3RhdGljc1tuYW1lXTtcbiAgICBpZiAoIXN0YXRpY3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBpc1Jlc2VydmVkID0gbmFtZSBpbiBSRVNFUlZFRF9TUEVDX0tFWVM7XG4gICAgISFpc1Jlc2VydmVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYSByZXNlcnZlZCBwcm9wZXJ0eSwgYCVzYCwgdGhhdCBzaG91bGRuXFwndCBiZSBvbiB0aGUgXCJzdGF0aWNzXCIga2V5LiBEZWZpbmUgaXQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgaW5zdGVhZDsgaXQgd2lsbCBzdGlsbCBiZSBhY2Nlc3NpYmxlIG9uIHRoZSBjb25zdHJ1Y3Rvci4nLCBuYW1lKSA6IF9wcm9kSW52YXJpYW50KCc3OCcsIG5hbWUpIDogdm9pZCAwO1xuXG4gICAgdmFyIGlzSW5oZXJpdGVkID0gbmFtZSBpbiBDb25zdHJ1Y3RvcjtcbiAgICAhIWlzSW5oZXJpdGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgZHVlIHRvIGEgbWl4aW4uJywgbmFtZSkgOiBfcHJvZEludmFyaWFudCgnNzknLCBuYW1lKSA6IHZvaWQgMDtcbiAgICBDb25zdHJ1Y3RvcltuYW1lXSA9IHByb3BlcnR5O1xuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdHdvIG9iamVjdHMsIGJ1dCB0aHJvdyBpZiBib3RoIGNvbnRhaW4gdGhlIHNhbWUga2V5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbmUgVGhlIGZpcnN0IG9iamVjdCwgd2hpY2ggaXMgbXV0YXRlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0d28gVGhlIHNlY29uZCBvYmplY3RcbiAqIEByZXR1cm4ge29iamVjdH0gb25lIGFmdGVyIGl0IGhhcyBiZWVuIG11dGF0ZWQgdG8gY29udGFpbiBldmVyeXRoaW5nIGluIHR3by5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhvbmUsIHR3bykge1xuICAhKG9uZSAmJiB0d28gJiYgdHlwZW9mIG9uZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHR3byA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoKTogQ2Fubm90IG1lcmdlIG5vbi1vYmplY3RzLicpIDogX3Byb2RJbnZhcmlhbnQoJzgwJykgOiB2b2lkIDA7XG5cbiAgZm9yICh2YXIga2V5IGluIHR3bykge1xuICAgIGlmICh0d28uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgIShvbmVba2V5XSA9PT0gdW5kZWZpbmVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IFRyaWVkIHRvIG1lcmdlIHR3byBvYmplY3RzIHdpdGggdGhlIHNhbWUga2V5OiBgJXNgLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgdG8gYSBtaXhpbjsgaW4gcGFydGljdWxhciwgdGhpcyBtYXkgYmUgY2F1c2VkIGJ5IHR3byBnZXRJbml0aWFsU3RhdGUoKSBvciBnZXREZWZhdWx0UHJvcHMoKSBtZXRob2RzIHJldHVybmluZyBvYmplY3RzIHdpdGggY2xhc2hpbmcga2V5cy4nLCBrZXkpIDogX3Byb2RJbnZhcmlhbnQoJzgxJywga2V5KSA6IHZvaWQgMDtcbiAgICAgIG9uZVtrZXldID0gdHdvW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvbmU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0d28gZnVuY3Rpb25zIGFuZCBtZXJnZXMgdGhlaXIgcmV0dXJuIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvbmUgRnVuY3Rpb24gdG8gaW52b2tlIGZpcnN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHdvIEZ1bmN0aW9uIHRvIGludm9rZSBzZWNvbmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gRnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSB0d28gYXJndW1lbnQgZnVuY3Rpb25zLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZFJlc3VsdCgpIHtcbiAgICB2YXIgYSA9IG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBiID0gdHdvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKGEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSBlbHNlIGlmIChiID09IG51bGwpIHtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICB2YXIgYyA9IHt9O1xuICAgIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMoYywgYSk7XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBiKTtcbiAgICByZXR1cm4gYztcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIGlnbm9yZXMgdGhlaXIgcmV0dXJuIHZhbGVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmVkRnVuY3Rpb24ob25lLCB0d28pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNoYWluZWRGdW5jdGlvbigpIHtcbiAgICBvbmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBCaW5kcyBhIG1ldGhvZCB0byB0aGUgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCBNZXRob2QgdG8gYmUgYm91bmQuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIGJvdW5kIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kKGNvbXBvbmVudCwgbWV0aG9kKSB7XG4gIHZhciBib3VuZE1ldGhvZCA9IG1ldGhvZC5iaW5kKGNvbXBvbmVudCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQ29udGV4dCA9IGNvbXBvbmVudDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gbnVsbDtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZTtcbiAgICB2YXIgX2JpbmQgPSBib3VuZE1ldGhvZC5iaW5kO1xuICAgIGJvdW5kTWV0aG9kLmJpbmQgPSBmdW5jdGlvbiAobmV3VGhpcykge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBVc2VyIGlzIHRyeWluZyB0byBiaW5kKCkgYW4gYXV0b2JvdW5kIG1ldGhvZDsgd2UgZWZmZWN0aXZlbHkgd2lsbFxuICAgICAgLy8gaWdub3JlIHRoZSB2YWx1ZSBvZiBcInRoaXNcIiB0aGF0IHRoZSB1c2VyIGlzIHRyeWluZyB0byB1c2UsIHNvXG4gICAgICAvLyBsZXQncyB3YXJuLlxuICAgICAgaWYgKG5ld1RoaXMgIT09IGNvbXBvbmVudCAmJiBuZXdUaGlzICE9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYmluZCgpOiBSZWFjdCBjb21wb25lbnQgbWV0aG9kcyBtYXkgb25seSBiZSBib3VuZCB0byB0aGUgJyArICdjb21wb25lbnQgaW5zdGFuY2UuIFNlZSAlcycsIGNvbXBvbmVudE5hbWUpIDogdm9pZCAwO1xuICAgICAgfSBlbHNlIGlmICghYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdiaW5kKCk6IFlvdSBhcmUgYmluZGluZyBhIGNvbXBvbmVudCBtZXRob2QgdG8gdGhlIGNvbXBvbmVudC4gJyArICdSZWFjdCBkb2VzIHRoaXMgZm9yIHlvdSBhdXRvbWF0aWNhbGx5IGluIGEgaGlnaC1wZXJmb3JtYW5jZSAnICsgJ3dheSwgc28geW91IGNhbiBzYWZlbHkgcmVtb3ZlIHRoaXMgY2FsbC4gU2VlICVzJywgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgICAgIHJldHVybiBib3VuZE1ldGhvZDtcbiAgICAgIH1cbiAgICAgIHZhciByZWJvdW5kTWV0aG9kID0gX2JpbmQuYXBwbHkoYm91bmRNZXRob2QsIGFyZ3VtZW50cyk7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZENvbnRleHQgPSBjb21wb25lbnQ7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIHJlYm91bmRNZXRob2QuX19yZWFjdEJvdW5kQXJndW1lbnRzID0gYXJncztcbiAgICAgIHJldHVybiByZWJvdW5kTWV0aG9kO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGJvdW5kTWV0aG9kO1xufVxuXG4vKipcbiAqIEJpbmRzIGFsbCBhdXRvLWJvdW5kIG1ldGhvZHMgaW4gYSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICovXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2RzKGNvbXBvbmVudCkge1xuICB2YXIgcGFpcnMgPSBjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kUGFpcnM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB2YXIgYXV0b0JpbmRLZXkgPSBwYWlyc1tpXTtcbiAgICB2YXIgbWV0aG9kID0gcGFpcnNbaSArIDFdO1xuICAgIGNvbXBvbmVudFthdXRvQmluZEtleV0gPSBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpO1xuICB9XG59XG5cbi8qKlxuICogQWRkIG1vcmUgdG8gdGhlIFJlYWN0Q2xhc3MgYmFzZSBjbGFzcy4gVGhlc2UgYXJlIGFsbCBsZWdhY3kgZmVhdHVyZXMgYW5kXG4gKiB0aGVyZWZvcmUgbm90IGFscmVhZHkgcGFydCBvZiB0aGUgbW9kZXJuIFJlYWN0Q29tcG9uZW50LlxuICovXG52YXIgUmVhY3RDbGFzc01peGluID0ge1xuXG4gIC8qKlxuICAgKiBUT0RPOiBUaGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBiZWNhdXNlIHN0YXRlIHNob3VsZCBhbHdheXMga2VlcCBhIGNvbnNpc3RlbnRcbiAgICogdHlwZSBzaWduYXR1cmUgYW5kIHRoZSBvbmx5IHVzZSBjYXNlIGZvciB0aGlzLCBpcyB0byBhdm9pZCB0aGF0LlxuICAgKi9cbiAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAobmV3U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUodGhpcywgbmV3U3RhdGUpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnVwZGF0ZXIuaXNNb3VudGVkKHRoaXMpO1xuICB9XG59O1xuXG52YXIgUmVhY3RDbGFzc0NvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHt9O1xuX2Fzc2lnbihSZWFjdENsYXNzQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENsYXNzTWl4aW4pO1xuXG4vKipcbiAqIE1vZHVsZSBmb3IgY3JlYXRpbmcgY29tcG9zaXRlIGNvbXBvbmVudHMuXG4gKlxuICogQGNsYXNzIFJlYWN0Q2xhc3NcbiAqL1xudmFyIFJlYWN0Q2xhc3MgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgY29tcG9uZW50IGNsYXNzIGdpdmVuIGEgY2xhc3Mgc3BlY2lmaWNhdGlvbi5cbiAgICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNyZWF0ZWNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzcGVjIENsYXNzIHNwZWNpZmljYXRpb24gKHdoaWNoIG11c3QgZGVmaW5lIGByZW5kZXJgKS5cbiAgICogQHJldHVybiB7ZnVuY3Rpb259IENvbXBvbmVudCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY3JlYXRlQ2xhc3M6IGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gICAgICAvLyBUaGlzIGNvbnN0cnVjdG9yIGdldHMgb3ZlcnJpZGRlbiBieSBtb2Nrcy4gVGhlIGFyZ3VtZW50IGlzIHVzZWRcbiAgICAgIC8vIGJ5IG1vY2tzIHRvIGFzc2VydCBvbiB3aGF0IGdldHMgbW91bnRlZC5cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodGhpcyBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLCAnU29tZXRoaW5nIGlzIGNhbGxpbmcgYSBSZWFjdCBjb21wb25lbnQgZGlyZWN0bHkuIFVzZSBhIGZhY3Rvcnkgb3IgJyArICdKU1ggaW5zdGVhZC4gU2VlOiBodHRwczovL2ZiLm1lL3JlYWN0LWxlZ2FjeWZhY3RvcnknKSA6IHZvaWQgMDtcbiAgICAgIH1cblxuICAgICAgLy8gV2lyZSB1cCBhdXRvLWJpbmRpbmdcbiAgICAgIGlmICh0aGlzLl9fcmVhY3RBdXRvQmluZFBhaXJzLmxlbmd0aCkge1xuICAgICAgICBiaW5kQXV0b0JpbmRNZXRob2RzKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG4gICAgICB0aGlzLnN0YXRlID0gbnVsbDtcblxuICAgICAgLy8gUmVhY3RDbGFzc2VzIGRvZXNuJ3QgaGF2ZSBjb25zdHJ1Y3RvcnMuIEluc3RlYWQsIHRoZXkgdXNlIHRoZVxuICAgICAgLy8gZ2V0SW5pdGlhbFN0YXRlIGFuZCBjb21wb25lbnRXaWxsTW91bnQgbWV0aG9kcyBmb3IgaW5pdGlhbGl6YXRpb24uXG5cbiAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSA/IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkgOiBudWxsO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmdldEluaXRpYWxTdGF0ZS5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgICAgaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgISh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRJbml0aWFsU3RhdGUoKTogbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9yIG51bGwnLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IF9wcm9kSW52YXJpYW50KCc4MicsIENvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdm9pZCAwO1xuXG4gICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIH07XG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gbmV3IFJlYWN0Q2xhc3NDb21wb25lbnQoKTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuX19yZWFjdEF1dG9CaW5kUGFpcnMgPSBbXTtcblxuICAgIGluamVjdGVkTWl4aW5zLmZvckVhY2gobWl4U3BlY0ludG9Db21wb25lbnQuYmluZChudWxsLCBDb25zdHJ1Y3RvcikpO1xuXG4gICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHNwZWMpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZGVmYXVsdFByb3BzIHByb3BlcnR5IGFmdGVyIGFsbCBtaXhpbnMgaGF2ZSBiZWVuIG1lcmdlZC5cbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5kZWZhdWx0UHJvcHMgPSBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMoKTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyBpcyBhIHRhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSB1c2Ugb2YgdGhlc2UgbWV0aG9kIG5hbWVzIGlzIG9rLFxuICAgICAgLy8gc2luY2UgaXQncyB1c2VkIHdpdGggY3JlYXRlQ2xhc3MuIElmIGl0J3Mgbm90LCB0aGVuIGl0J3MgbGlrZWx5IGFcbiAgICAgIC8vIG1pc3Rha2Ugc28gd2UnbGwgd2FybiB5b3UgdG8gdXNlIHRoZSBzdGF0aWMgcHJvcGVydHksIHByb3BlcnR5XG4gICAgICAvLyBpbml0aWFsaXplciBvciBjb25zdHJ1Y3RvciByZXNwZWN0aXZlbHkuXG4gICAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKENvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsU3RhdGUpIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCA9IHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgICFDb25zdHJ1Y3Rvci5wcm90b3R5cGUucmVuZGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZUNsYXNzKC4uLik6IENsYXNzIHNwZWNpZmljYXRpb24gbXVzdCBpbXBsZW1lbnQgYSBgcmVuZGVyYCBtZXRob2QuJykgOiBfcHJvZEludmFyaWFudCgnODMnKSA6IHZvaWQgMDtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFNob3VsZFVwZGF0ZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghQ29uc3RydWN0b3IucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIHNwZWMuZGlzcGxheU5hbWUgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgLy8gUmVkdWNlIHRpbWUgc3BlbnQgZG9pbmcgbG9va3VwcyBieSBzZXR0aW5nIHRoZXNlIG9uIHRoZSBwcm90b3R5cGUuXG4gICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBSZWFjdENsYXNzSW50ZXJmYWNlKSB7XG4gICAgICBpZiAoIUNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2ROYW1lXSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfSxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RNaXhpbjogZnVuY3Rpb24gKG1peGluKSB7XG4gICAgICBpbmplY3RlZE1peGlucy5wdXNoKG1peGluKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENsYXNzOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0gcmVxdWlyZSgnLi9SZWFjdE5vb3BVcGRhdGVRdWV1ZScpO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL2NhbkRlZmluZVByb3BlcnR5Jyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0Q29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKSA6IF9wcm9kSW52YXJpYW50KCc4NScpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuUmVhY3RDb21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFjdENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pIDogdm9pZCAwO1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9uZW50OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudFRyZWVIb29rXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBpc05hdGl2ZShmbikge1xuICAvLyBCYXNlZCBvbiBpc05hdGl2ZSgpIGZyb20gTG9kYXNoXG4gIHZhciBmdW5jVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArIGZ1bmNUb1N0cmluZ1xuICAvLyBUYWtlIGFuIGV4YW1wbGUgbmF0aXZlIGZ1bmN0aW9uIHNvdXJjZSBmb3IgY29tcGFyaXNvblxuICAuY2FsbChoYXNPd25Qcm9wZXJ0eSlcbiAgLy8gU3RyaXAgcmVnZXggY2hhcmFjdGVycyBzbyB3ZSBjYW4gdXNlIGl0IGZvciByZWdleFxuICAucmVwbGFjZSgvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2csICdcXFxcJCYnKVxuICAvLyBSZW1vdmUgaGFzT3duUHJvcGVydHkgZnJvbSB0aGUgdGVtcGxhdGUgdG8gbWFrZSBpdCBnZW5lcmljXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJyk7XG4gIHRyeSB7XG4gICAgdmFyIHNvdXJjZSA9IGZ1bmNUb1N0cmluZy5jYWxsKGZuKTtcbiAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KHNvdXJjZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG52YXIgY2FuVXNlQ29sbGVjdGlvbnMgPVxuLy8gQXJyYXkuZnJvbVxudHlwZW9mIEFycmF5LmZyb20gPT09ICdmdW5jdGlvbicgJiZcbi8vIE1hcFxudHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShNYXApICYmXG4vLyBNYXAucHJvdG90eXBlLmtleXNcbk1hcC5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2YgTWFwLnByb3RvdHlwZS5rZXlzID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKE1hcC5wcm90b3R5cGUua2V5cykgJiZcbi8vIFNldFxudHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBpc05hdGl2ZShTZXQpICYmXG4vLyBTZXQucHJvdG90eXBlLmtleXNcblNldC5wcm90b3R5cGUgIT0gbnVsbCAmJiB0eXBlb2YgU2V0LnByb3RvdHlwZS5rZXlzID09PSAnZnVuY3Rpb24nICYmIGlzTmF0aXZlKFNldC5wcm90b3R5cGUua2V5cyk7XG5cbnZhciBpdGVtTWFwO1xudmFyIHJvb3RJRFNldDtcblxudmFyIGl0ZW1CeUtleTtcbnZhciByb290QnlLZXk7XG5cbmlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICBpdGVtTWFwID0gbmV3IE1hcCgpO1xuICByb290SURTZXQgPSBuZXcgU2V0KCk7XG59IGVsc2Uge1xuICBpdGVtQnlLZXkgPSB7fTtcbiAgcm9vdEJ5S2V5ID0ge307XG59XG5cbnZhciB1bm1vdW50ZWRJRHMgPSBbXTtcblxuLy8gVXNlIG5vbi1udW1lcmljIGtleXMgdG8gcHJldmVudCBWOCBwZXJmb3JtYW5jZSBpc3N1ZXM6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MjMyXG5mdW5jdGlvbiBnZXRLZXlGcm9tSUQoaWQpIHtcbiAgcmV0dXJuICcuJyArIGlkO1xufVxuZnVuY3Rpb24gZ2V0SURGcm9tS2V5KGtleSkge1xuICByZXR1cm4gcGFyc2VJbnQoa2V5LnN1YnN0cigxKSwgMTApO1xufVxuXG5mdW5jdGlvbiBnZXQoaWQpIHtcbiAgaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gICAgcmV0dXJuIGl0ZW1NYXAuZ2V0KGlkKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICByZXR1cm4gaXRlbUJ5S2V5W2tleV07XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlKGlkKSB7XG4gIGlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICAgIGl0ZW1NYXBbJ2RlbGV0ZSddKGlkKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIga2V5ID0gZ2V0S2V5RnJvbUlEKGlkKTtcbiAgICBkZWxldGUgaXRlbUJ5S2V5W2tleV07XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlKGlkLCBlbGVtZW50LCBwYXJlbnRJRCkge1xuICB2YXIgaXRlbSA9IHtcbiAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICB0ZXh0OiBudWxsLFxuICAgIGNoaWxkSURzOiBbXSxcbiAgICBpc01vdW50ZWQ6IGZhbHNlLFxuICAgIHVwZGF0ZUNvdW50OiAwXG4gIH07XG5cbiAgaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gICAgaXRlbU1hcC5zZXQoaWQsIGl0ZW0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIGl0ZW1CeUtleVtrZXldID0gaXRlbTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRSb290KGlkKSB7XG4gIGlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICAgIHJvb3RJRFNldC5hZGQoaWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIHJvb3RCeUtleVtrZXldID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVSb290KGlkKSB7XG4gIGlmIChjYW5Vc2VDb2xsZWN0aW9ucykge1xuICAgIHJvb3RJRFNldFsnZGVsZXRlJ10oaWQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBrZXkgPSBnZXRLZXlGcm9tSUQoaWQpO1xuICAgIGRlbGV0ZSByb290QnlLZXlba2V5XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZWdpc3RlcmVkSURzKCkge1xuICBpZiAoY2FuVXNlQ29sbGVjdGlvbnMpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShpdGVtTWFwLmtleXMoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGl0ZW1CeUtleSkubWFwKGdldElERnJvbUtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Um9vdElEcygpIHtcbiAgaWYgKGNhblVzZUNvbGxlY3Rpb25zKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocm9vdElEU2V0LmtleXMoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJvb3RCeUtleSkubWFwKGdldElERnJvbUtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVyZ2VEZWVwKGlkKSB7XG4gIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgaWYgKGl0ZW0pIHtcbiAgICB2YXIgY2hpbGRJRHMgPSBpdGVtLmNoaWxkSURzO1xuXG4gICAgcmVtb3ZlKGlkKTtcbiAgICBjaGlsZElEcy5mb3JFYWNoKHB1cmdlRGVlcCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgbmFtZSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xufVxuXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gJyNlbXB0eSc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiAnI3RleHQnO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxlbWVudC50eXBlLmRpc3BsYXlOYW1lIHx8IGVsZW1lbnQudHlwZS5uYW1lIHx8ICdVbmtub3duJztcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZUlEKGlkKSB7XG4gIHZhciBuYW1lID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXREaXNwbGF5TmFtZShpZCk7XG4gIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgdmFyIG93bmVySUQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldE93bmVySUQoaWQpO1xuICB2YXIgb3duZXJOYW1lO1xuICBpZiAob3duZXJJRCkge1xuICAgIG93bmVyTmFtZSA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0RGlzcGxheU5hbWUob3duZXJJRCk7XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZWxlbWVudCwgJ1JlYWN0Q29tcG9uZW50VHJlZUhvb2s6IE1pc3NpbmcgUmVhY3QgZWxlbWVudCBmb3IgZGVidWdJRCAlcyB3aGVuICcgKyAnYnVpbGRpbmcgc3RhY2snLCBpZCkgOiB2b2lkIDA7XG4gIHJldHVybiBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGVsZW1lbnQgJiYgZWxlbWVudC5fc291cmNlLCBvd25lck5hbWUpO1xufVxuXG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHtcbiAgb25TZXRDaGlsZHJlbjogZnVuY3Rpb24gKGlkLCBuZXh0Q2hpbGRJRHMpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgaXRlbS5jaGlsZElEcyA9IG5leHRDaGlsZElEcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV4dENoaWxkSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dENoaWxkSUQgPSBuZXh0Q2hpbGRJRHNbaV07XG4gICAgICB2YXIgbmV4dENoaWxkID0gZ2V0KG5leHRDaGlsZElEKTtcbiAgICAgICFuZXh0Q2hpbGQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgaG9vayBldmVudHMgdG8gZmlyZSBmb3IgdGhlIGNoaWxkIGJlZm9yZSBpdHMgcGFyZW50IGluY2x1ZGVzIGl0IGluIG9uU2V0Q2hpbGRyZW4oKS4nKSA6IF9wcm9kSW52YXJpYW50KCcxNDAnKSA6IHZvaWQgMDtcbiAgICAgICEobmV4dENoaWxkLmNoaWxkSURzICE9IG51bGwgfHwgdHlwZW9mIG5leHRDaGlsZC5lbGVtZW50ICE9PSAnb2JqZWN0JyB8fCBuZXh0Q2hpbGQuZWxlbWVudCA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvblNldENoaWxkcmVuKCkgdG8gZmlyZSBmb3IgYSBjb250YWluZXIgY2hpbGQgYmVmb3JlIGl0cyBwYXJlbnQgaW5jbHVkZXMgaXQgaW4gb25TZXRDaGlsZHJlbigpLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MScpIDogdm9pZCAwO1xuICAgICAgIW5leHRDaGlsZC5pc01vdW50ZWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgb25Nb3VudENvbXBvbmVudCgpIHRvIGZpcmUgZm9yIHRoZSBjaGlsZCBiZWZvcmUgaXRzIHBhcmVudCBpbmNsdWRlcyBpdCBpbiBvblNldENoaWxkcmVuKCkuJykgOiBfcHJvZEludmFyaWFudCgnNzEnKSA6IHZvaWQgMDtcbiAgICAgIGlmIChuZXh0Q2hpbGQucGFyZW50SUQgPT0gbnVsbCkge1xuICAgICAgICBuZXh0Q2hpbGQucGFyZW50SUQgPSBpZDtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5IGJ1dCBtb3VudGluZyBhIG5ldyByb290IGR1cmluZyBpblxuICAgICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgY3VycmVudGx5IGNhdXNlcyBub3QteWV0LW1vdW50ZWQgY29tcG9uZW50cyB0b1xuICAgICAgICAvLyBiZSBwdXJnZWQgZnJvbSBvdXIgdHJlZSBkYXRhIHNvIHRoZWlyIHBhcmVudCBJRCBpcyBtaXNzaW5nLlxuICAgICAgfVxuICAgICAgIShuZXh0Q2hpbGQucGFyZW50SUQgPT09IGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBvbkJlZm9yZU1vdW50Q29tcG9uZW50KCkgcGFyZW50IGFuZCBvblNldENoaWxkcmVuKCkgdG8gYmUgY29uc2lzdGVudCAoJXMgaGFzIHBhcmVudHMgJXMgYW5kICVzKS4nLCBuZXh0Q2hpbGRJRCwgbmV4dENoaWxkLnBhcmVudElELCBpZCkgOiBfcHJvZEludmFyaWFudCgnMTQyJywgbmV4dENoaWxkSUQsIG5leHRDaGlsZC5wYXJlbnRJRCwgaWQpIDogdm9pZCAwO1xuICAgIH1cbiAgfSxcbiAgb25CZWZvcmVNb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkLCBlbGVtZW50LCBwYXJlbnRJRCkge1xuICAgIGNyZWF0ZShpZCwgZWxlbWVudCwgcGFyZW50SUQpO1xuICB9LFxuICBvbkJlZm9yZVVwZGF0ZUNvbXBvbmVudDogZnVuY3Rpb24gKGlkLCBlbGVtZW50KSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIGlmICghaXRlbSB8fCAhaXRlbS5pc01vdW50ZWQpIHtcbiAgICAgIC8vIFdlIG1heSBlbmQgdXAgaGVyZSBhcyBhIHJlc3VsdCBvZiBzZXRTdGF0ZSgpIGluIGNvbXBvbmVudFdpbGxVbm1vdW50KCkuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIGlnbm9yZSB0aGUgZWxlbWVudC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXRlbS5lbGVtZW50ID0gZWxlbWVudDtcbiAgfSxcbiAgb25Nb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIGl0ZW0uaXNNb3VudGVkID0gdHJ1ZTtcbiAgICB2YXIgaXNSb290ID0gaXRlbS5wYXJlbnRJRCA9PT0gMDtcbiAgICBpZiAoaXNSb290KSB7XG4gICAgICBhZGRSb290KGlkKTtcbiAgICB9XG4gIH0sXG4gIG9uVXBkYXRlQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgaWYgKCFpdGVtIHx8ICFpdGVtLmlzTW91bnRlZCkge1xuICAgICAgLy8gV2UgbWF5IGVuZCB1cCBoZXJlIGFzIGEgcmVzdWx0IG9mIHNldFN0YXRlKCkgaW4gY29tcG9uZW50V2lsbFVubW91bnQoKS5cbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgaWdub3JlIHRoZSBlbGVtZW50LlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpdGVtLnVwZGF0ZUNvdW50Kys7XG4gIH0sXG4gIG9uVW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIGlmIChpdGVtKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIGl0IGV4aXN0cy5cbiAgICAgIC8vIGBpdGVtYCBtaWdodCBub3QgZXhpc3QgaWYgaXQgaXMgaW5zaWRlIGFuIGVycm9yIGJvdW5kYXJ5LCBhbmQgYSBzaWJsaW5nXG4gICAgICAvLyBlcnJvciBib3VuZGFyeSBjaGlsZCB0aHJldyB3aGlsZSBtb3VudGluZy4gVGhlbiB0aGlzIGluc3RhbmNlIG5ldmVyXG4gICAgICAvLyBnb3QgYSBjaGFuY2UgdG8gbW91bnQsIGJ1dCBpdCBzdGlsbCBnZXRzIGFuIHVubW91bnRpbmcgZXZlbnQgZHVyaW5nXG4gICAgICAvLyB0aGUgZXJyb3IgYm91bmRhcnkgY2xlYW51cC5cbiAgICAgIGl0ZW0uaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICB2YXIgaXNSb290ID0gaXRlbS5wYXJlbnRJRCA9PT0gMDtcbiAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgcmVtb3ZlUm9vdChpZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHVubW91bnRlZElEcy5wdXNoKGlkKTtcbiAgfSxcbiAgcHVyZ2VVbm1vdW50ZWRDb21wb25lbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJlYWN0Q29tcG9uZW50VHJlZUhvb2suX3ByZXZlbnRQdXJnaW5nKSB7XG4gICAgICAvLyBTaG91bGQgb25seSBiZSB1c2VkIGZvciB0ZXN0aW5nLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5tb3VudGVkSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaWQgPSB1bm1vdW50ZWRJRHNbaV07XG4gICAgICBwdXJnZURlZXAoaWQpO1xuICAgIH1cbiAgICB1bm1vdW50ZWRJRHMubGVuZ3RoID0gMDtcbiAgfSxcbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLmlzTW91bnRlZCA6IGZhbHNlO1xuICB9LFxuICBnZXRDdXJyZW50U3RhY2tBZGRlbmR1bTogZnVuY3Rpb24gKHRvcEVsZW1lbnQpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIGlmICh0b3BFbGVtZW50KSB7XG4gICAgICB2YXIgdHlwZSA9IHRvcEVsZW1lbnQudHlwZTtcbiAgICAgIHZhciBuYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSA6IHR5cGU7XG4gICAgICB2YXIgb3duZXIgPSB0b3BFbGVtZW50Ll9vd25lcjtcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lIHx8ICdVbmtub3duJywgdG9wRWxlbWVudC5fc291cmNlLCBvd25lciAmJiBvd25lci5nZXROYW1lKCkpO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50T3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIHZhciBpZCA9IGN1cnJlbnRPd25lciAmJiBjdXJyZW50T3duZXIuX2RlYnVnSUQ7XG5cbiAgICBpbmZvICs9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoaWQpO1xuICAgIHJldHVybiBpbmZvO1xuICB9LFxuICBnZXRTdGFja0FkZGVuZHVtQnlJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB3aGlsZSAoaWQpIHtcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVJRChpZCk7XG4gICAgICBpZCA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0UGFyZW50SUQoaWQpO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbztcbiAgfSxcbiAgZ2V0Q2hpbGRJRHM6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uY2hpbGRJRHMgOiBbXTtcbiAgfSxcbiAgZ2V0RGlzcGxheU5hbWU6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0RGlzcGxheU5hbWUoZWxlbWVudCk7XG4gIH0sXG4gIGdldEVsZW1lbnQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBpdGVtID0gZ2V0KGlkKTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0uZWxlbWVudCA6IG51bGw7XG4gIH0sXG4gIGdldE93bmVySUQ6IGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBlbGVtZW50ID0gUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRFbGVtZW50KGlkKTtcbiAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuX293bmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQuX293bmVyLl9kZWJ1Z0lEO1xuICB9LFxuICBnZXRQYXJlbnRJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIHJldHVybiBpdGVtID8gaXRlbS5wYXJlbnRJRCA6IG51bGw7XG4gIH0sXG4gIGdldFNvdXJjZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGl0ZW0gPSBnZXQoaWQpO1xuICAgIHZhciBlbGVtZW50ID0gaXRlbSA/IGl0ZW0uZWxlbWVudCA6IG51bGw7XG4gICAgdmFyIHNvdXJjZSA9IGVsZW1lbnQgIT0gbnVsbCA/IGVsZW1lbnQuX3NvdXJjZSA6IG51bGw7XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfSxcbiAgZ2V0VGV4dDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEVsZW1lbnQoaWQpO1xuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJycgKyBlbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sXG4gIGdldFVwZGF0ZUNvdW50OiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaXRlbSA9IGdldChpZCk7XG4gICAgcmV0dXJuIGl0ZW0gPyBpdGVtLnVwZGF0ZUNvdW50IDogMDtcbiAgfSxcblxuXG4gIGdldFJlZ2lzdGVyZWRJRHM6IGdldFJlZ2lzdGVyZWRJRHMsXG5cbiAgZ2V0Um9vdElEczogZ2V0Um9vdElEc1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudFRyZWVIb29rOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEN1cnJlbnRPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q3VycmVudE93bmVyOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUZhY3Rvcmllc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbi8qKlxuICogQ3JlYXRlIGEgZmFjdG9yeSB0aGF0IGNyZWF0ZXMgSFRNTCB0YWcgZWxlbWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIGNyZWF0ZURPTUZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRmFjdG9yeTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudFZhbGlkYXRvcicpO1xuICBjcmVhdGVET01GYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcHBpbmcgZnJvbSBzdXBwb3J0ZWQgSFRNTCB0YWdzIHRvIGBSZWFjdERPTUNvbXBvbmVudGAgY2xhc3Nlcy5cbiAqIFRoaXMgaXMgYWxzbyBhY2Nlc3NpYmxlIHZpYSBgUmVhY3QuRE9NYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IHtcbiAgYTogY3JlYXRlRE9NRmFjdG9yeSgnYScpLFxuICBhYmJyOiBjcmVhdGVET01GYWN0b3J5KCdhYmJyJyksXG4gIGFkZHJlc3M6IGNyZWF0ZURPTUZhY3RvcnkoJ2FkZHJlc3MnKSxcbiAgYXJlYTogY3JlYXRlRE9NRmFjdG9yeSgnYXJlYScpLFxuICBhcnRpY2xlOiBjcmVhdGVET01GYWN0b3J5KCdhcnRpY2xlJyksXG4gIGFzaWRlOiBjcmVhdGVET01GYWN0b3J5KCdhc2lkZScpLFxuICBhdWRpbzogY3JlYXRlRE9NRmFjdG9yeSgnYXVkaW8nKSxcbiAgYjogY3JlYXRlRE9NRmFjdG9yeSgnYicpLFxuICBiYXNlOiBjcmVhdGVET01GYWN0b3J5KCdiYXNlJyksXG4gIGJkaTogY3JlYXRlRE9NRmFjdG9yeSgnYmRpJyksXG4gIGJkbzogY3JlYXRlRE9NRmFjdG9yeSgnYmRvJyksXG4gIGJpZzogY3JlYXRlRE9NRmFjdG9yeSgnYmlnJyksXG4gIGJsb2NrcXVvdGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2Jsb2NrcXVvdGUnKSxcbiAgYm9keTogY3JlYXRlRE9NRmFjdG9yeSgnYm9keScpLFxuICBicjogY3JlYXRlRE9NRmFjdG9yeSgnYnInKSxcbiAgYnV0dG9uOiBjcmVhdGVET01GYWN0b3J5KCdidXR0b24nKSxcbiAgY2FudmFzOiBjcmVhdGVET01GYWN0b3J5KCdjYW52YXMnKSxcbiAgY2FwdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnY2FwdGlvbicpLFxuICBjaXRlOiBjcmVhdGVET01GYWN0b3J5KCdjaXRlJyksXG4gIGNvZGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvZGUnKSxcbiAgY29sOiBjcmVhdGVET01GYWN0b3J5KCdjb2wnKSxcbiAgY29sZ3JvdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ2NvbGdyb3VwJyksXG4gIGRhdGE6IGNyZWF0ZURPTUZhY3RvcnkoJ2RhdGEnKSxcbiAgZGF0YWxpc3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ2RhdGFsaXN0JyksXG4gIGRkOiBjcmVhdGVET01GYWN0b3J5KCdkZCcpLFxuICBkZWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2RlbCcpLFxuICBkZXRhaWxzOiBjcmVhdGVET01GYWN0b3J5KCdkZXRhaWxzJyksXG4gIGRmbjogY3JlYXRlRE9NRmFjdG9yeSgnZGZuJyksXG4gIGRpYWxvZzogY3JlYXRlRE9NRmFjdG9yeSgnZGlhbG9nJyksXG4gIGRpdjogY3JlYXRlRE9NRmFjdG9yeSgnZGl2JyksXG4gIGRsOiBjcmVhdGVET01GYWN0b3J5KCdkbCcpLFxuICBkdDogY3JlYXRlRE9NRmFjdG9yeSgnZHQnKSxcbiAgZW06IGNyZWF0ZURPTUZhY3RvcnkoJ2VtJyksXG4gIGVtYmVkOiBjcmVhdGVET01GYWN0b3J5KCdlbWJlZCcpLFxuICBmaWVsZHNldDogY3JlYXRlRE9NRmFjdG9yeSgnZmllbGRzZXQnKSxcbiAgZmlnY2FwdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnZmlnY2FwdGlvbicpLFxuICBmaWd1cmU6IGNyZWF0ZURPTUZhY3RvcnkoJ2ZpZ3VyZScpLFxuICBmb290ZXI6IGNyZWF0ZURPTUZhY3RvcnkoJ2Zvb3RlcicpLFxuICBmb3JtOiBjcmVhdGVET01GYWN0b3J5KCdmb3JtJyksXG4gIGgxOiBjcmVhdGVET01GYWN0b3J5KCdoMScpLFxuICBoMjogY3JlYXRlRE9NRmFjdG9yeSgnaDInKSxcbiAgaDM6IGNyZWF0ZURPTUZhY3RvcnkoJ2gzJyksXG4gIGg0OiBjcmVhdGVET01GYWN0b3J5KCdoNCcpLFxuICBoNTogY3JlYXRlRE9NRmFjdG9yeSgnaDUnKSxcbiAgaDY6IGNyZWF0ZURPTUZhY3RvcnkoJ2g2JyksXG4gIGhlYWQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2hlYWQnKSxcbiAgaGVhZGVyOiBjcmVhdGVET01GYWN0b3J5KCdoZWFkZXInKSxcbiAgaGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdoZ3JvdXAnKSxcbiAgaHI6IGNyZWF0ZURPTUZhY3RvcnkoJ2hyJyksXG4gIGh0bWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2h0bWwnKSxcbiAgaTogY3JlYXRlRE9NRmFjdG9yeSgnaScpLFxuICBpZnJhbWU6IGNyZWF0ZURPTUZhY3RvcnkoJ2lmcmFtZScpLFxuICBpbWc6IGNyZWF0ZURPTUZhY3RvcnkoJ2ltZycpLFxuICBpbnB1dDogY3JlYXRlRE9NRmFjdG9yeSgnaW5wdXQnKSxcbiAgaW5zOiBjcmVhdGVET01GYWN0b3J5KCdpbnMnKSxcbiAga2JkOiBjcmVhdGVET01GYWN0b3J5KCdrYmQnKSxcbiAga2V5Z2VuOiBjcmVhdGVET01GYWN0b3J5KCdrZXlnZW4nKSxcbiAgbGFiZWw6IGNyZWF0ZURPTUZhY3RvcnkoJ2xhYmVsJyksXG4gIGxlZ2VuZDogY3JlYXRlRE9NRmFjdG9yeSgnbGVnZW5kJyksXG4gIGxpOiBjcmVhdGVET01GYWN0b3J5KCdsaScpLFxuICBsaW5rOiBjcmVhdGVET01GYWN0b3J5KCdsaW5rJyksXG4gIG1haW46IGNyZWF0ZURPTUZhY3RvcnkoJ21haW4nKSxcbiAgbWFwOiBjcmVhdGVET01GYWN0b3J5KCdtYXAnKSxcbiAgbWFyazogY3JlYXRlRE9NRmFjdG9yeSgnbWFyaycpLFxuICBtZW51OiBjcmVhdGVET01GYWN0b3J5KCdtZW51JyksXG4gIG1lbnVpdGVtOiBjcmVhdGVET01GYWN0b3J5KCdtZW51aXRlbScpLFxuICBtZXRhOiBjcmVhdGVET01GYWN0b3J5KCdtZXRhJyksXG4gIG1ldGVyOiBjcmVhdGVET01GYWN0b3J5KCdtZXRlcicpLFxuICBuYXY6IGNyZWF0ZURPTUZhY3RvcnkoJ25hdicpLFxuICBub3NjcmlwdDogY3JlYXRlRE9NRmFjdG9yeSgnbm9zY3JpcHQnKSxcbiAgb2JqZWN0OiBjcmVhdGVET01GYWN0b3J5KCdvYmplY3QnKSxcbiAgb2w6IGNyZWF0ZURPTUZhY3RvcnkoJ29sJyksXG4gIG9wdGdyb3VwOiBjcmVhdGVET01GYWN0b3J5KCdvcHRncm91cCcpLFxuICBvcHRpb246IGNyZWF0ZURPTUZhY3RvcnkoJ29wdGlvbicpLFxuICBvdXRwdXQ6IGNyZWF0ZURPTUZhY3RvcnkoJ291dHB1dCcpLFxuICBwOiBjcmVhdGVET01GYWN0b3J5KCdwJyksXG4gIHBhcmFtOiBjcmVhdGVET01GYWN0b3J5KCdwYXJhbScpLFxuICBwaWN0dXJlOiBjcmVhdGVET01GYWN0b3J5KCdwaWN0dXJlJyksXG4gIHByZTogY3JlYXRlRE9NRmFjdG9yeSgncHJlJyksXG4gIHByb2dyZXNzOiBjcmVhdGVET01GYWN0b3J5KCdwcm9ncmVzcycpLFxuICBxOiBjcmVhdGVET01GYWN0b3J5KCdxJyksXG4gIHJwOiBjcmVhdGVET01GYWN0b3J5KCdycCcpLFxuICBydDogY3JlYXRlRE9NRmFjdG9yeSgncnQnKSxcbiAgcnVieTogY3JlYXRlRE9NRmFjdG9yeSgncnVieScpLFxuICBzOiBjcmVhdGVET01GYWN0b3J5KCdzJyksXG4gIHNhbXA6IGNyZWF0ZURPTUZhY3RvcnkoJ3NhbXAnKSxcbiAgc2NyaXB0OiBjcmVhdGVET01GYWN0b3J5KCdzY3JpcHQnKSxcbiAgc2VjdGlvbjogY3JlYXRlRE9NRmFjdG9yeSgnc2VjdGlvbicpLFxuICBzZWxlY3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3NlbGVjdCcpLFxuICBzbWFsbDogY3JlYXRlRE9NRmFjdG9yeSgnc21hbGwnKSxcbiAgc291cmNlOiBjcmVhdGVET01GYWN0b3J5KCdzb3VyY2UnKSxcbiAgc3BhbjogY3JlYXRlRE9NRmFjdG9yeSgnc3BhbicpLFxuICBzdHJvbmc6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0cm9uZycpLFxuICBzdHlsZTogY3JlYXRlRE9NRmFjdG9yeSgnc3R5bGUnKSxcbiAgc3ViOiBjcmVhdGVET01GYWN0b3J5KCdzdWInKSxcbiAgc3VtbWFyeTogY3JlYXRlRE9NRmFjdG9yeSgnc3VtbWFyeScpLFxuICBzdXA6IGNyZWF0ZURPTUZhY3RvcnkoJ3N1cCcpLFxuICB0YWJsZTogY3JlYXRlRE9NRmFjdG9yeSgndGFibGUnKSxcbiAgdGJvZHk6IGNyZWF0ZURPTUZhY3RvcnkoJ3Rib2R5JyksXG4gIHRkOiBjcmVhdGVET01GYWN0b3J5KCd0ZCcpLFxuICB0ZXh0YXJlYTogY3JlYXRlRE9NRmFjdG9yeSgndGV4dGFyZWEnKSxcbiAgdGZvb3Q6IGNyZWF0ZURPTUZhY3RvcnkoJ3Rmb290JyksXG4gIHRoOiBjcmVhdGVET01GYWN0b3J5KCd0aCcpLFxuICB0aGVhZDogY3JlYXRlRE9NRmFjdG9yeSgndGhlYWQnKSxcbiAgdGltZTogY3JlYXRlRE9NRmFjdG9yeSgndGltZScpLFxuICB0aXRsZTogY3JlYXRlRE9NRmFjdG9yeSgndGl0bGUnKSxcbiAgdHI6IGNyZWF0ZURPTUZhY3RvcnkoJ3RyJyksXG4gIHRyYWNrOiBjcmVhdGVET01GYWN0b3J5KCd0cmFjaycpLFxuICB1OiBjcmVhdGVET01GYWN0b3J5KCd1JyksXG4gIHVsOiBjcmVhdGVET01GYWN0b3J5KCd1bCcpLFxuICAndmFyJzogY3JlYXRlRE9NRmFjdG9yeSgndmFyJyksXG4gIHZpZGVvOiBjcmVhdGVET01GYWN0b3J5KCd2aWRlbycpLFxuICB3YnI6IGNyZWF0ZURPTUZhY3RvcnkoJ3dicicpLFxuXG4gIC8vIFNWR1xuICBjaXJjbGU6IGNyZWF0ZURPTUZhY3RvcnkoJ2NpcmNsZScpLFxuICBjbGlwUGF0aDogY3JlYXRlRE9NRmFjdG9yeSgnY2xpcFBhdGgnKSxcbiAgZGVmczogY3JlYXRlRE9NRmFjdG9yeSgnZGVmcycpLFxuICBlbGxpcHNlOiBjcmVhdGVET01GYWN0b3J5KCdlbGxpcHNlJyksXG4gIGc6IGNyZWF0ZURPTUZhY3RvcnkoJ2cnKSxcbiAgaW1hZ2U6IGNyZWF0ZURPTUZhY3RvcnkoJ2ltYWdlJyksXG4gIGxpbmU6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmUnKSxcbiAgbGluZWFyR3JhZGllbnQ6IGNyZWF0ZURPTUZhY3RvcnkoJ2xpbmVhckdyYWRpZW50JyksXG4gIG1hc2s6IGNyZWF0ZURPTUZhY3RvcnkoJ21hc2snKSxcbiAgcGF0aDogY3JlYXRlRE9NRmFjdG9yeSgncGF0aCcpLFxuICBwYXR0ZXJuOiBjcmVhdGVET01GYWN0b3J5KCdwYXR0ZXJuJyksXG4gIHBvbHlnb246IGNyZWF0ZURPTUZhY3RvcnkoJ3BvbHlnb24nKSxcbiAgcG9seWxpbmU6IGNyZWF0ZURPTUZhY3RvcnkoJ3BvbHlsaW5lJyksXG4gIHJhZGlhbEdyYWRpZW50OiBjcmVhdGVET01GYWN0b3J5KCdyYWRpYWxHcmFkaWVudCcpLFxuICByZWN0OiBjcmVhdGVET01GYWN0b3J5KCdyZWN0JyksXG4gIHN0b3A6IGNyZWF0ZURPTUZhY3RvcnkoJ3N0b3AnKSxcbiAgc3ZnOiBjcmVhdGVET01GYWN0b3J5KCdzdmcnKSxcbiAgdGV4dDogY3JlYXRlRE9NRmFjdG9yeSgndGV4dCcpLFxuICB0c3BhbjogY3JlYXRlRE9NRmFjdG9yeSgndHNwYW4nKVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZhY3RvcmllczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbGVtZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudCB0eXBlLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddICYmIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKSB8fCAweGVhYzc7XG5cbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG5cbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biwgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgbm8gaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuICAgIHZhciBzaGFkb3dDaGlsZHJlbiA9IEFycmF5LmlzQXJyYXkocHJvcHMuY2hpbGRyZW4pID8gcHJvcHMuY2hpbGRyZW4uc2xpY2UoMCkgOiBwcm9wcy5jaGlsZHJlbjtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBpZiAoY2FuRGVmaW5lUHJvcGVydHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHNlbGZcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2hhZG93Q2hpbGRyZW4nLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzaGFkb3dDaGlsZHJlblxuICAgICAgfSk7XG4gICAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgIGVsZW1lbnQuX3NlbGYgPSBzZWxmO1xuICAgICAgZWxlbWVudC5fc2hhZG93Q2hpbGRyZW4gPSBzaGFkb3dDaGlsZHJlbjtcbiAgICAgIGVsZW1lbnQuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy90b3AtbGV2ZWwtYXBpLmh0bWwjcmVhY3QuY3JlYXRlZWxlbWVudFxuICovXG5SZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBwcm9wcyA9IHt9O1xuXG4gIHZhciBrZXkgPSBudWxsO1xuICB2YXIgcmVmID0gbnVsbDtcbiAgdmFyIHNlbGYgPSBudWxsO1xuICB2YXIgc291cmNlID0gbnVsbDtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlO1xuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcbiAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuJCR0eXBlb2YgPT09ICd1bmRlZmluZWQnIHx8IHByb3BzLiQkdHlwZW9mICE9PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBSZWFjdEVsZW1lbnRzIG9mIGEgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL3RvcC1sZXZlbC1hcGkuaHRtbCNyZWFjdC5jcmVhdGVmYWN0b3J5XG4gKi9cblJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5ID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgdmFyIGZhY3RvcnkgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAvLyBFeHBvc2UgdGhlIHR5cGUgb24gdGhlIGZhY3RvcnkgYW5kIHRoZSBwcm90b3R5cGUgc28gdGhhdCBpdCBjYW4gYmVcbiAgLy8gZWFzaWx5IGFjY2Vzc2VkIG9uIGVsZW1lbnRzLiBFLmcuIGA8Rm9vIC8+LnR5cGUgPT09IEZvb2AuXG4gIC8vIFRoaXMgc2hvdWxkIG5vdCBiZSBuYW1lZCBgY29uc3RydWN0b3JgIHNpbmNlIHRoaXMgbWF5IG5vdCBiZSB0aGUgZnVuY3Rpb25cbiAgLy8gdGhhdCBjcmVhdGVkIHRoZSBlbGVtZW50LCBhbmQgaXQgbWF5IG5vdCBldmVuIGJlIGEgY29uc3RydWN0b3IuXG4gIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICBmYWN0b3J5LnR5cGUgPSB0eXBlO1xuICByZXR1cm4gZmFjdG9yeTtcbn07XG5cblJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VLZXkgPSBmdW5jdGlvbiAob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59O1xuXG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNsb25lZWxlbWVudFxuICovXG5SZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmO1xuICAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcblxuICAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufTtcblxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmlzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIGNvbXBvbmVudC5cbiAqIEBmaW5hbFxuICovXG5SZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59O1xuXG5SZWFjdEVsZW1lbnQuUkVBQ1RfRUxFTUVOVF9UWVBFID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RWxlbWVudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbGVtZW50VmFsaWRhdG9yXG4gKi9cblxuLyoqXG4gKiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGVsZW1lbnQgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RDb21wb25lbnRUcmVlSG9vayA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRUcmVlSG9vaycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xuXG52YXIgY2hlY2tSZWFjdFR5cGVTcGVjID0gcmVxdWlyZSgnLi9jaGVja1JlYWN0VHlwZVNwZWMnKTtcblxudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcbiAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgaW5mbyA9ICcgQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgbWVtb2l6ZXIgPSBvd25lckhhc0tleVVzZVdhcm5pbmcudW5pcXVlS2V5IHx8IChvd25lckhhc0tleVVzZVdhcm5pbmcudW5pcXVlS2V5ID0ge30pO1xuXG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcbiAgaWYgKG1lbW9pemVyW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG1lbW9pemVyW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZWxlbWVudC5fb3duZXIuZ2V0TmFtZSgpICsgJy4nO1xuICB9XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLiVzJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lciwgUmVhY3RDb21wb25lbnRUcmVlSG9vay5nZXRDdXJyZW50U3RhY2tBZGRlbmR1bShlbGVtZW50KSkgOiB2b2lkIDA7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgLy8gRW50cnkgaXRlcmF0b3JzIHByb3ZpZGUgaW1wbGljaXQga2V5cy5cbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgY29tcG9uZW50Q2xhc3MgPSBlbGVtZW50LnR5cGU7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWUgPSBjb21wb25lbnRDbGFzcy5kaXNwbGF5TmFtZSB8fCBjb21wb25lbnRDbGFzcy5uYW1lO1xuICBpZiAoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzKSB7XG4gICAgY2hlY2tSZWFjdFR5cGVTcGVjKGNvbXBvbmVudENsYXNzLnByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wLCBuYW1lLCBlbGVtZW50LCBudWxsKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgfVxufVxuXG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0ge1xuXG4gIGNyZWF0ZUVsZW1lbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nO1xuICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIHNob3VsZCBub3QgYmUgbnVsbCwgdW5kZWZpbmVkLCBib29sZWFuLCBvciAnICsgJ251bWJlci4gSXQgc2hvdWxkIGJlIGEgc3RyaW5nIChmb3IgRE9NIGVsZW1lbnRzKSBvciBhIFJlYWN0Q2xhc3MgJyArICcoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIGNyZWF0ZUZhY3Rvcnk6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBSZWFjdEVsZW1lbnRWYWxpZGF0b3IuY3JlYXRlRWxlbWVudC5iaW5kKG51bGwsIHR5cGUpO1xuICAgIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICAgIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpIDogdm9pZCAwO1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xuICB9LFxuXG4gIGNsb25lRWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gICAgfVxuICAgIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE5vb3BVcGRhdGVRdWV1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJykgOiB2b2lkIDA7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRW5xdWV1ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciBhbGwgdGhlIHBlbmRpbmcgdXBkYXRlc1xuICAgKiBoYXZlIHByb2Nlc3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdG8gdXNlIGFzIGB0aGlzYCBjb250ZXh0LlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUNhbGxiYWNrOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrKSB7fSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xuICAgIHByb3A6ICdwcm9wJyxcbiAgICBjb250ZXh0OiAnY29udGV4dCcsXG4gICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZUxvY2F0aW9uc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IGtleU1pcnJvcih7XG4gIHByb3A6IG51bGwsXG4gIGNvbnRleHQ6IG51bGwsXG4gIGNoaWxkQ29udGV4dDogbnVsbFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uczsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQcm9wVHlwZXNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICpcbiAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAqXG4gKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAqICAgICB9LFxuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gKiAgIH0pO1xuICpcbiAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAqXG4gKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICpcbiAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgIHByb3BUeXBlczoge1xuICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICogICAgICAgICAgKTtcbiAqICAgICAgICB9XG4gKiAgICAgIH1cbiAqICAgIH0sXG4gKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAqICB9KTtcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG52YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG52YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXJcbn07XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbi8qKlxuICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciB3ZSBkb24ndCB1c2UgcmVhbFxuICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICovXG5mdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy5zdGFjayA9ICcnO1xufVxuLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gIH1cbiAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgaWYgKCFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0pIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgKyAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgKyAnYW5kIHdpbGwgbm90IHdvcmsgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi4gWW91IG1heSBiZSAnICsgJ3NlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzIGxpYnJhcnkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzIGZvciBkZXRhaWxzLicsIHByb3BGdWxsTmFtZSwgY29tcG9uZW50TmFtZSkgOiB2b2lkIDA7XG4gICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1JlcXVpcmVkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agd2FzIG5vdCBzcGVjaWZpZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyhudWxsKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgIH1cbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAoIVJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgfVxuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICBjYXNlICdudW1iZXInOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gIC8vIE5hdGl2ZSBTeW1ib2wuXG4gIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbmZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH1cbiAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICByZXR1cm4gJ29iamVjdCc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgcmV0dXJuICdzeW1ib2wnO1xuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxuLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG5mdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gJ2RhdGUnO1xuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wVHlwZTtcbn1cblxuLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbmZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgfVxuICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVzU2VjcmV0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0OyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFB1cmVDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gUmVhY3RDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBSZWFjdENvbXBvbmVudC5wcm90b3R5cGU7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVhY3RQdXJlQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKFJlYWN0UHVyZUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0Q29tcG9uZW50LnByb3RvdHlwZSk7XG5SZWFjdFB1cmVDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFB1cmVDb21wb25lbnQ7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VmVyc2lvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSAnMTUuMy4yJzsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY2FuRGVmaW5lUHJvcGVydHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IGZhbHNlO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4JywgeyBnZXQ6IGZ1bmN0aW9uICgpIHt9IH0pO1xuICAgIGNhbkRlZmluZVByb3BlcnR5ID0gdHJ1ZTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIElFIHdpbGwgZmFpbCBvbiBkZWZpbmVQcm9wZXJ0eVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FuRGVmaW5lUHJvcGVydHk7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNoZWNrUmVhY3RUeXBlU3BlY1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAvLyBUZW1wb3JhcnkgaGFjay5cbiAgLy8gSW5saW5lIHJlcXVpcmVzIGRvbid0IHdvcmsgd2VsbCB3aXRoIEplc3Q6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI0MFxuICAvLyBSZW1vdmUgdGhlIGlubGluZSByZXF1aXJlcyB3aGVuIHdlIGRvbid0IG5lZWQgdGhlbSBhbnltb3JlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC83MTc4XG4gIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbn1cblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9vYmplY3R9IGVsZW1lbnQgVGhlIFJlYWN0IGVsZW1lbnQgdGhhdCBpcyBiZWluZyB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7P251bWJlcn0gZGVidWdJRCBUaGUgUmVhY3QgY29tcG9uZW50IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgdHlwZS1jaGVja2VkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1JlYWN0VHlwZVNwZWModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50LCBkZWJ1Z0lEKSB7XG4gIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgIHZhciBlcnJvcjtcbiAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAhKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSBSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHR5cGVTcGVjTmFtZSkgOiBfcHJvZEludmFyaWFudCgnODQnLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgdHlwZVNwZWNOYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGVycm9yID0gZXg7XG4gICAgICB9XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcikgOiB2b2lkIDA7XG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgY29tcG9uZW50U3RhY2tJbmZvID0gJyc7XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoIVJlYWN0Q29tcG9uZW50VHJlZUhvb2spIHtcbiAgICAgICAgICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2sgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50VHJlZUhvb2snKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlYnVnSUQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFN0YWNrSW5mbyA9IFJlYWN0Q29tcG9uZW50VHJlZUhvb2suZ2V0U3RhY2tBZGRlbmR1bUJ5SUQoZGVidWdJRCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21wb25lbnRTdGFja0luZm8gPSBSZWFjdENvbXBvbmVudFRyZWVIb29rLmdldEN1cnJlbnRTdGFja0FkZGVuZHVtKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgY29tcG9uZW50U3RhY2tJbmZvKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1JlYWN0VHlwZVNwZWM7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEl0ZXJhdG9yRm5cbiAqIFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuXG52YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gKlxuICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gKlxuICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICogICAgICAgLi4uXG4gKiAgICAgfVxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRJdGVyYXRvckZuOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBvbmx5Q2hpbGRcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3Byb2RJbnZhcmlhbnQgPSByZXF1aXJlKCcuL3JlYWN0UHJvZEludmFyaWFudCcpO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvdG9wLWxldmVsLWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogX3Byb2RJbnZhcmlhbnQoJzE0MycpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb25seUNoaWxkOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgcmVhY3RQcm9kSW52YXJpYW50XG4gKiBcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuZnVuY3Rpb24gcmVhY3RQcm9kSW52YXJpYW50KGNvZGUpIHtcbiAgdmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7XG5cbiAgdmFyIG1lc3NhZ2UgPSAnTWluaWZpZWQgUmVhY3QgZXJyb3IgIycgKyBjb2RlICsgJzsgdmlzaXQgJyArICdodHRwOi8vZmFjZWJvb2suZ2l0aHViLmlvL3JlYWN0L2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD0nICsgY29kZTtcblxuICBmb3IgKHZhciBhcmdJZHggPSAwOyBhcmdJZHggPCBhcmdDb3VudDsgYXJnSWR4KyspIHtcbiAgICBtZXNzYWdlICs9ICcmYXJnc1tdPScgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2FyZ0lkeCArIDFdKTtcbiAgfVxuXG4gIG1lc3NhZ2UgKz0gJyBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQnICsgJyBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nO1xuXG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IHJlYWN0UHJvZEludmFyaWFudCdzIG93biBmcmFtZVxuXG4gIHRocm93IGVycm9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0UHJvZEludmFyaWFudDsiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgdHJhdmVyc2VBbGxDaGlsZHJlblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF9wcm9kSW52YXJpYW50ID0gcmVxdWlyZSgnLi9yZWFjdFByb2RJbnZhcmlhbnQnKTtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgS2V5RXNjYXBlVXRpbHMgPSByZXF1aXJlKCcuL0tleUVzY2FwZVV0aWxzJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBrZXkgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyBhIGNvbXBvbmVudCB3aXRoaW4gYSBzZXQuXG4gKlxuICogQHBhcmFtIHsqfSBjb21wb25lbnQgQSBjb21wb25lbnQgdGhhdCBjb3VsZCBjb250YWluIGEgbWFudWFsIGtleS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCB0aGF0IGlzIHVzZWQgaWYgYSBtYW51YWwga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50S2V5KGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgLy8gRG8gc29tZSB0eXBlY2hlY2tpbmcgaGVyZSBzaW5jZSB3ZSBjYWxsIHRoaXMgYmxpbmRseS4gV2Ugd2FudCB0byBlbnN1cmVcbiAgLy8gdGhhdCB3ZSBkb24ndCBibG9jayBwb3RlbnRpYWwgZnV0dXJlIEVTIEFQSXMuXG4gIGlmIChjb21wb25lbnQgJiYgdHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIEtleUVzY2FwZVV0aWxzLmVzY2FwZShjb21wb25lbnQua2V5KTtcbiAgfVxuICAvLyBJbXBsaWNpdCBrZXkgZGV0ZXJtaW5lZCBieSB0aGUgaW5kZXggaW4gdGhlIHNldFxuICByZXR1cm4gaW5kZXgudG9TdHJpbmcoMzYpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwgfHwgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHwgUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSkge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKGNoaWxkcmVuKTtcbiAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGlpID0gMDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5BZGRlbmR1bSA9ICcnO1xuICAgICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgbWFwc0FzQ2hpbGRyZW5Pd25lck5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICAgIGlmIChtYXBzQXNDaGlsZHJlbk93bmVyTmFtZSkge1xuICAgICAgICAgICAgICBtYXBzQXNDaGlsZHJlbkFkZGVuZHVtID0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG1hcHNBc0NoaWxkcmVuT3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgbm90IHlldCBmdWxseSBzdXBwb3J0ZWQuIEl0IGlzIGFuICcgKyAnZXhwZXJpbWVudGFsIGZlYXR1cmUgdGhhdCBtaWdodCBiZSByZW1vdmVkLiBDb252ZXJ0IGl0IHRvIGEgJyArICdzZXF1ZW5jZSAvIGl0ZXJhYmxlIG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIG1hcHNBc0NoaWxkcmVuQWRkZW5kdW0pIDogdm9pZCAwO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gZW50cnlbMV07XG4gICAgICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgS2V5RXNjYXBlVXRpbHMuZXNjYXBlKGVudHJ5WzBdKSArIFNVQlNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZCwgMCk7XG4gICAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICsgJ1JlYWN0IGFkZC1vbnMuJztcbiAgICAgICAgaWYgKGNoaWxkcmVuLl9pc1JlYWN0RWxlbWVudCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGFuIGVsZW1lbnQgY3JlYXRlZCBieSBhIGRpZmZlcmVudCAnICsgJ3ZlcnNpb24gb2YgUmVhY3QuIE1ha2Ugc3VyZSB0byB1c2Ugb25seSBvbmUgY29weSBvZiBSZWFjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgYWRkZW5kdW0gKz0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogX3Byb2RJbnZhcmlhbnQoJzMxJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmF2ZXJzZUFsbENoaWxkcmVuOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50OyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhbiBlbnVtZXJhdGlvbiB3aXRoIGtleXMgZXF1YWwgdG8gdGhlaXIgdmFsdWUuXG4gKlxuICogRm9yIGV4YW1wbGU6XG4gKlxuICogICB2YXIgQ09MT1JTID0ga2V5TWlycm9yKHtibHVlOiBudWxsLCByZWQ6IG51bGx9KTtcbiAqICAgdmFyIG15Q29sb3IgPSBDT0xPUlMuYmx1ZTtcbiAqICAgdmFyIGlzQ29sb3JWYWxpZCA9ICEhQ09MT1JTW215Q29sb3JdO1xuICpcbiAqIFRoZSBsYXN0IGxpbmUgY291bGQgbm90IGJlIHBlcmZvcm1lZCBpZiB0aGUgdmFsdWVzIG9mIHRoZSBnZW5lcmF0ZWQgZW51bSB3ZXJlXG4gKiBub3QgZXF1YWwgdG8gdGhlaXIga2V5cy5cbiAqXG4gKiAgIElucHV0OiAge2tleTE6IHZhbDEsIGtleTI6IHZhbDJ9XG4gKiAgIE91dHB1dDoge2tleTE6IGtleTEsIGtleTI6IGtleTJ9XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG52YXIga2V5TWlycm9yID0gZnVuY3Rpb24ga2V5TWlycm9yKG9iaikge1xuICB2YXIgcmV0ID0ge307XG4gIHZhciBrZXk7XG4gICEob2JqIGluc3RhbmNlb2YgT2JqZWN0ICYmICFBcnJheS5pc0FycmF5KG9iaikpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2tleU1pcnJvciguLi4pOiBBcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXRba2V5XSA9IGtleTtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlNaXJyb3I7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKi9cblxuLyoqXG4gKiBBbGxvd3MgZXh0cmFjdGlvbiBvZiBhIG1pbmlmaWVkIGtleS4gTGV0J3MgdGhlIGJ1aWxkIHN5c3RlbSBtaW5pZnkga2V5c1xuICogd2l0aG91dCBsb3NpbmcgdGhlIGFiaWxpdHkgdG8gZHluYW1pY2FsbHkgdXNlIGtleSBzdHJpbmdzIGFzIHZhbHVlc1xuICogdGhlbXNlbHZlcy4gUGFzcyBpbiBhbiBvYmplY3Qgd2l0aCBhIHNpbmdsZSBrZXkvdmFsIHBhaXIgYW5kIGl0IHdpbGwgcmV0dXJuXG4gKiB5b3UgdGhlIHN0cmluZyBrZXkgb2YgdGhhdCBzaW5nbGUgcmVjb3JkLiBTdXBwb3NlIHlvdSB3YW50IHRvIGdyYWIgdGhlXG4gKiB2YWx1ZSBmb3IgYSBrZXkgJ2NsYXNzTmFtZScgaW5zaWRlIG9mIGFuIG9iamVjdC4gS2V5L3ZhbCBtaW5pZmljYXRpb24gbWF5XG4gKiBoYXZlIGFsaWFzZWQgdGhhdCBrZXkgdG8gYmUgJ3hhMTInLiBrZXlPZih7Y2xhc3NOYW1lOiBudWxsfSkgd2lsbCByZXR1cm5cbiAqICd4YTEyJyBpbiB0aGF0IGNhc2UuIFJlc29sdmUga2V5cyB5b3Ugd2FudCB0byB1c2Ugb25jZSBhdCBzdGFydHVwIHRpbWUsIHRoZW5cbiAqIHJldXNlIHRob3NlIHJlc29sdXRpb25zLlxuICovXG52YXIga2V5T2YgPSBmdW5jdGlvbiBrZXlPZihvbmVLZXlPYmopIHtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gb25lS2V5T2JqKSB7XG4gICAgaWYgKCFvbmVLZXlPYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleU9mOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCAoeCkge31cbiAgICB9O1xuXG4gICAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICAgIH1cblxuICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgIH1cblxuICAgICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZzsiLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvUmVhY3QnKTtcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvUHVmJyk7XHJcbiIsIi8qKlxyXG4gKiBSZWFjdCBQdWYgQnVuZGxlXHJcbiAqXHJcbiAqIHZlcnNpb24gPHR0PiQgVmVyc2lvbjogMS4wICQ8L3R0PiBkYXRlOjIwMTYvMDMvMDhcclxuICogYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86aHJhaG5AbmtpYS5jby5rclwiPkFobiBIeXVuZy1SbzwvYT5cclxuICpcclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIGNvbXBvbmVudHNcclxuLy8gRWxlbWVudHNcclxuaW1wb3J0IEFsZXJ0IGZyb20gJy4vY29tcG9uZW50cy9BbGVydCc7XHJcbmltcG9ydCBCdXR0b24gZnJvbSAnLi9jb21wb25lbnRzL0J1dHRvbic7XHJcbmltcG9ydCBUb2dnbGVCdXR0b24gZnJvbSAnLi9jb21wb25lbnRzL1RvZ2dsZUJ1dHRvbic7XHJcbmltcG9ydCBCdXR0b25Ecm9wZG93biBmcm9tICcuL2NvbXBvbmVudHMvQnV0dG9uRHJvcGRvd24nO1xyXG5pbXBvcnQgSGlkZGVuQ29udGVudCBmcm9tICcuL2NvbXBvbmVudHMvSGlkZGVuQ29udGVudCc7XHJcbmltcG9ydCBNYWluRnJhbWVTcGxpdHRlciBmcm9tICcuL2NvbXBvbmVudHMvTWFpbkZyYW1lU3BsaXR0ZXInO1xyXG5pbXBvcnQgeyBNb2RhbCwgTW9kYWxIZWFkZXIsIE1vZGFsQm9keSwgTW9kYWxGb290ZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvTW9kYWwnO1xyXG5pbXBvcnQgeyBQYW5lbCwgUGFuZWxIZWFkZXIsIFBhbmVsQm9keSwgUGFuZWxGb290ZXIgfSBmcm9tICcuL2NvbXBvbmVudHMvUGFuZWwnO1xyXG5cclxuLy8gRm9ybSBFbGVtZW50c1xyXG5pbXBvcnQgQ2hlY2tib3ggZnJvbSAnLi9jb21wb25lbnRzL0NoZWNrYm94JztcclxuaW1wb3J0IFJhZGlvR3JvdXAgZnJvbSAnLi9jb21wb25lbnRzL3JhZGlvL1JhZGlvR3JvdXAnO1xyXG5pbXBvcnQgUmFkaW8gZnJvbSAnLi9jb21wb25lbnRzL3JhZGlvL1JhZGlvJztcclxuaW1wb3J0IFJhZGlvRGl2aWRlciBmcm9tICcuL2NvbXBvbmVudHMvcmFkaW8vUmFkaW9EaXZpZGVyJztcclxuaW1wb3J0IEZpZWxkc2V0IGZyb20gJy4vY29tcG9uZW50cy9GaWVsZHNldCc7XHJcbmltcG9ydCBGaW5lVXBsb2FkZXIgZnJvbSAnLi9jb21wb25lbnRzL0ZpbmVVcGxvYWRlcic7XHJcblxyXG4vLyBFdGMgRWxlbWVudHNcclxuLy92YXIgVGFiU2V0ID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL3RhYnMvVGFiU2V0Jyk7XHJcbi8vdmFyIFRhYnMgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvdGFicy9UYWJzJyk7XHJcbi8vdmFyIFRhYiA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy90YWJzL1RhYicpO1xyXG4vL3ZhciBUYWJDb250ZW50cyA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy90YWJzL1RhYkNvbnRlbnRzJyk7XHJcbi8vdmFyIFRhYkNvbnRlbnQgPSByZXF1aXJlKCcuL2NvbXBvbmVudHMvdGFicy9UYWJDb250ZW50Jyk7XHJcblxyXG4vLyBLZW5kb1xyXG5pbXBvcnQgVGFiU3RyaXAgZnJvbSAnLi9rZW5kby90YWJzdHJpcC9UYWJTdHJpcCc7XHJcbmltcG9ydCBUYWJzIGZyb20gJy4va2VuZG8vdGFic3RyaXAvVGFicyc7XHJcbmltcG9ydCBUYWIgZnJvbSAnLi9rZW5kby90YWJzdHJpcC9UYWInO1xyXG5pbXBvcnQgVGFiQ29udGVudCBmcm9tICcuL2tlbmRvL3RhYnN0cmlwL1RhYkNvbnRlbnQnO1xyXG5pbXBvcnQgQXV0b0NvbXBsZXRlIGZyb20gJy4va2VuZG8vQXV0b0NvbXBsZXRlJztcclxuaW1wb3J0IERhdGVQaWNrZXIgZnJvbSAnLi9rZW5kby9EYXRlUGlja2VyJztcclxuaW1wb3J0IERhdGVSYW5nZVBpY2tlciBmcm9tICcuL2tlbmRvL0RhdGVSYW5nZVBpY2tlcic7XHJcbmltcG9ydCBEcm9wRG93bkxpc3QgZnJvbSAnLi9rZW5kby9Ecm9wRG93bkxpc3QnO1xyXG5pbXBvcnQgR3JpZCBmcm9tICcuL2tlbmRvL0dyaWQnO1xyXG5pbXBvcnQgTXVsdGlTZWxlY3QgZnJvbSAnLi9rZW5kby9NdWx0aVNlbGVjdCc7XHJcbmltcG9ydCBOdW1lcmljVGV4dEJveCBmcm9tICcuL2tlbmRvL051bWVyaWNUZXh0Qm94JztcclxuaW1wb3J0IHsgUGFuZWxCYXIsIFBhbmVsQmFyUGFuZSB9IGZyb20gJy4va2VuZG8vUGFuZWxCYXInO1xyXG5pbXBvcnQgUHJvZ3Jlc3NCYXIgZnJvbSAnLi9rZW5kby9Qcm9ncmVzc0Jhcic7XHJcbmltcG9ydCBUcmVlVmlldyBmcm9tICcuL2tlbmRvL1RyZWVWaWV3JztcclxuaW1wb3J0IFdpbmRvdyBmcm9tICcuL2tlbmRvL1dpbmRvdyc7XHJcbmltcG9ydCBTbGlkZXIgZnJvbSAnLi9rZW5kby9TbGlkZXInO1xyXG5cclxuLy8gSGlnaGNoYXJ0c1xyXG5pbXBvcnQgTGluZUNoYXJ0IGZyb20gJy4vY2hhcnRzL2hpZ2hjaGFydHMvTGluZUNoYXJ0JztcclxuaW1wb3J0IFNjYXR0ZXJDaGFydCBmcm9tICcuL2NoYXJ0cy9oaWdoY2hhcnRzL1NjYXR0ZXJDaGFydCc7XHJcbmltcG9ydCBDb2x1bW5DaGFydCBmcm9tICcuL2NoYXJ0cy9oaWdoY2hhcnRzL0NvbHVtbkNoYXJ0JztcclxuaW1wb3J0IFBpZUNoYXJ0IGZyb20gJy4vY2hhcnRzL2hpZ2hjaGFydHMvUGllQ2hhcnQnO1xyXG5pbXBvcnQgRGVmYXVsdENoYXJ0T3B0aW9uIGZyb20gJy4vY2hhcnRzL2hpZ2hjaGFydHMvRGVmYXVsdENoYXJ0T3B0aW9uJztcclxuXHJcbi8vIFNlcnZpY2VzXHJcbmltcG9ydCBVdGlsIGZyb20gJy4vc2VydmljZXMvVXRpbCc7XHJcbnZhciBEYXRlVXRpbCA9IHJlcXVpcmUoJy4vc2VydmljZXMvRGF0ZVV0aWwnKTtcclxuaW1wb3J0IE51bWJlclV0aWwgZnJvbSAnLi9zZXJ2aWNlcy9OdW1iZXJVdGlsJztcclxudmFyIFJlZ0V4cCA9IHJlcXVpcmUoJy4vc2VydmljZXMvUmVnRXhwJyk7XHJcbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoJy4vc2VydmljZXMvUmVzb3VyY2UnKTtcclxuXHJcbnZhciBQdWYgPSB7XHJcbiAgICAvLyBFbGVtZW50c1xyXG4gICAgQWxlcnQ6IEFsZXJ0LFxyXG4gICAgQnV0dG9uOiBCdXR0b24sXHJcbiAgICBUb2dnbGVCdXR0b246IFRvZ2dsZUJ1dHRvbixcclxuICAgIEJ1dHRvbkRyb3Bkb3duOiBCdXR0b25Ecm9wZG93bixcclxuICAgIEhpZGRlbkNvbnRlbnQ6IEhpZGRlbkNvbnRlbnQsXHJcbiAgICBNYWluRnJhbWVTcGxpdHRlcjogTWFpbkZyYW1lU3BsaXR0ZXIsXHJcbiAgICBNb2RhbDogTW9kYWwsXHJcbiAgICBNb2RhbEhlYWRlcjogTW9kYWxIZWFkZXIsXHJcbiAgICBNb2RhbEJvZHk6IE1vZGFsQm9keSxcclxuICAgIE1vZGFsRm9vdGVyOiBNb2RhbEZvb3RlcixcclxuICAgIFBhbmVsOiBQYW5lbCxcclxuICAgIFBhbmVsSGVhZGVyOiBQYW5lbEhlYWRlcixcclxuICAgIFBhbmVsQm9keTogUGFuZWxCb2R5LFxyXG4gICAgUGFuZWxGb290ZXI6IFBhbmVsRm9vdGVyLFxyXG4gICAgXHJcbiAgICAvLyBGb3JtIEVsZW1lbnRzXHJcbiAgICBDaGVja2JveDogQ2hlY2tib3gsXHJcbiAgICBSYWRpb0dyb3VwOiBSYWRpb0dyb3VwLFxyXG4gICAgUmFkaW86IFJhZGlvLFxyXG4gICAgUmFkaW9EaXZpZGVyOiBSYWRpb0RpdmlkZXIsXHJcbiAgICBGaWVsZHNldDogRmllbGRzZXQsXHJcbiAgICBGaW5lVXBsb2FkZXI6IEZpbmVVcGxvYWRlcixcclxuXHJcbiAgICAvLyBFdGMgRWxlbWVudHNcclxuICAgIC8vVGFiU2V0OiBUYWJTZXQsXHJcbiAgICAvL1RhYnM6IFRhYnMsXHJcbiAgICAvL1RhYjogVGFiLFxyXG4gICAgLy9UYWJDb250ZW50czogVGFiQ29udGVudHMsXHJcbiAgICAvL1RhYkNvbnRlbnQ6IFRhYkNvbnRlbnQsXHJcblxyXG4gICAgLy8gS2VuZG9cclxuICAgIFRhYlN0cmlwOiBUYWJTdHJpcCxcclxuICAgIFRhYnM6IFRhYnMsXHJcbiAgICBUYWI6IFRhYixcclxuICAgIFRhYkNvbnRlbnQ6IFRhYkNvbnRlbnQsXHJcbiAgICBBdXRvQ29tcGxldGU6IEF1dG9Db21wbGV0ZSxcclxuICAgIERhdGVQaWNrZXI6IERhdGVQaWNrZXIsXHJcbiAgICBEYXRlUmFuZ2VQaWNrZXI6IERhdGVSYW5nZVBpY2tlcixcclxuICAgIERyb3BEb3duTGlzdDogRHJvcERvd25MaXN0LFxyXG4gICAgR3JpZDogR3JpZCxcclxuICAgIE11bHRpU2VsZWN0OiBNdWx0aVNlbGVjdCxcclxuICAgIE51bWVyaWNUZXh0Qm94OiBOdW1lcmljVGV4dEJveCxcclxuICAgIFBhbmVsQmFyOiBQYW5lbEJhcixcclxuICAgIFBhbmVsQmFyUGFuZTogUGFuZWxCYXJQYW5lLFxyXG4gICAgUHJvZ3Jlc3NCYXI6IFByb2dyZXNzQmFyLFxyXG4gICAgVHJlZVZpZXc6IFRyZWVWaWV3LFxyXG4gICAgV2luZG93OiBXaW5kb3csXHJcbiAgICBTbGlkZXI6IFNsaWRlcixcclxuXHJcbiAgICBrZW5kbzoge1xyXG4gICAgICAgIFRhYlN0cmlwOiBUYWJTdHJpcCxcclxuICAgICAgICBUYWJzOiBUYWJzLFxyXG4gICAgICAgIFRhYjogVGFiLFxyXG4gICAgICAgIFRhYkNvbnRlbnQ6IFRhYkNvbnRlbnQsXHJcbiAgICAgICAgQXV0b0NvbXBsZXRlOiBBdXRvQ29tcGxldGUsXHJcbiAgICAgICAgRGF0ZVBpY2tlcjogRGF0ZVBpY2tlcixcclxuICAgICAgICBEYXRlUmFuZ2VQaWNrZXI6IERhdGVSYW5nZVBpY2tlcixcclxuICAgICAgICBEcm9wRG93bkxpc3Q6IERyb3BEb3duTGlzdCxcclxuICAgICAgICBHcmlkOiBHcmlkLFxyXG4gICAgICAgIE11bHRpU2VsZWN0OiBNdWx0aVNlbGVjdCxcclxuICAgICAgICBOdW1lcmljVGV4dEJveDogTnVtZXJpY1RleHRCb3gsXHJcbiAgICAgICAgUGFuZWxCYXI6IFBhbmVsQmFyLFxyXG4gICAgICAgIFBhbmVsQmFyUGFuZTogUGFuZWxCYXJQYW5lLFxyXG4gICAgICAgIFByb2dyZXNzQmFyOiBQcm9ncmVzc0JhcixcclxuICAgICAgICBUcmVlVmlldzogVHJlZVZpZXcsXHJcbiAgICAgICAgV2luZG93OiBXaW5kb3csXHJcbiAgICAgICAgU2xpZGVyOiBTbGlkZXJcclxuICAgIH0sXHJcblxyXG4gICAgLy8gSGlnaGNoYXJ0c1xyXG4gICAgTGluZUNoYXJ0OiBMaW5lQ2hhcnQsXHJcbiAgICBTY2F0dGVyQ2hhcnQ6IFNjYXR0ZXJDaGFydCxcclxuICAgIENvbHVtbkNoYXJ0OiBDb2x1bW5DaGFydCxcclxuICAgIFBpZUNoYXJ0OiBQaWVDaGFydCxcclxuICAgIERlZmF1bHRDaGFydE9wdGlvbjogRGVmYXVsdENoYXJ0T3B0aW9uLFxyXG5cclxuICAgIC8vIFNlcnZpY2VzXHJcbiAgICBVdGlsOiBVdGlsLFxyXG4gICAgRGF0ZVV0aWw6IERhdGVVdGlsLFxyXG4gICAgTnVtYmVyVXRpbDogTnVtYmVyVXRpbCxcclxuICAgIFJlZ0V4cDogUmVnRXhwLFxyXG4gICAgUmVzb3VyY2U6IFJlc291cmNlXHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFB1ZjtcclxuIiwiLyoqXHJcbiAqIENvbHVtbkNoYXJ0IGNvbXBvbmVudFxyXG4gKlxyXG4gKiB2ZXJzaW9uIDx0dD4kIFZlcnNpb246IDEuMCAkPC90dD4gZGF0ZToyMDE2LzAzLzAzXHJcbiAqIGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmtqdWh3YUBua2lhLmNvLmtyXCI+a2p1aHdhPC9hPlxyXG4gKlxyXG4gKiBleGFtcGxlOlxyXG4gKiA8UHVmLkNvbHVtbkNoYXJ0IG9wdGlvbnM9e29wdGlvbnN9IC8+XHJcbiAqXHJcbiAqIEhpZ2hjaGFydHMg65287J2067iM65+s66as7JeQIOyiheyGjeyggeydtOuLpC5cclxuICogXHJcbiAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQgVXRpbCBmcm9tICcuLi8uLi9zZXJ2aWNlcy9VdGlsJztcclxuaW1wb3J0IERlZmF1bHRDaGFydE9wdGlvbiBmcm9tICcuL0RlZmF1bHRDaGFydE9wdGlvbic7XHJcblxyXG5jb25zdCBwcm9wVHlwZXMgPSB7XHJcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3QsXHJcbiAgICBhdXRvSW5pdDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBcclxuICAgIGNvbG9yczogUHJvcFR5cGVzLmFycmF5LFxyXG4gICAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXHJcblxyXG4gICAgY2F0ZWdvcmllczogUHJvcFR5cGVzLmFycmF5LFxyXG4gICAgc2VyaWVzOiBQcm9wVHlwZXMuYXJyYXksXHJcblxyXG4gICAgbGl2ZUludGVydmFsOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgdW5pdHM6IFByb3BUeXBlcy5zdHJpbmcsXHJcblxyXG4gICAgb25Mb2FkOiBQcm9wVHlwZXMuZnVuYyxcclxuICAgIC8vIOyLpOyLnOqwhCDrjbDsnbTtg4Ag7LaU6rCAIEZ1bmNcclxuICAgIG9uTGl2ZTogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICAvLyBUb29sdGlwXHJcbiAgICB0b29sdGlwRm9ybWF0dGVyOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuLy8g7YG0656Y7Iqk6rCAIOyDneyEseuQoCDrlYwg7ZWc67KIIO2YuOy2nOuQmOqzoCDsupDsi5zrkJzri6QuXHJcbi8vIOu2gOuqqCDsu7Ttj6zrhIztirjsl5DshJwgcHJvcOydtCDrhJjslrTsmKTsp4Ag7JWK7J2AIOqyveyasCAoaW4g7Jew7IKw7J6Q66GcIO2ZleyduCkg66ek7ZWR7J2YIOqwkuydtCB0aGlzLnByb3Bz7JeQIOyEpOygleuQnOuLpC5cclxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xyXG4gICAgd2lkdGg6IG51bGwsXHJcbiAgICBoZWlnaHQ6IG51bGwsXHJcbiAgICBsaXZlSW50ZXJ2YWw6IDEwMDAsXHJcbiAgICBhdXRvSW5pdDogdHJ1ZVxyXG59O1xyXG5cclxuY2xhc3MgQ29sdW1uQ2hhcnQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcblxyXG4gICAgICAgIGxldCBpZCA9IHByb3BzLmlkO1xyXG4gICAgICAgIGlmKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWQgPSBVdGlsLmdldFVVSUQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLmNvbHVtbkNoYXJ0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gTWFudWFsbHkgYmluZCB0aGlzIG1ldGhvZCB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlLi4uXHJcbiAgICAgICAgLy90aGlzLm9uTG9hZCA9IHRoaXMub25Mb2FkLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgaWYoIHRoaXMucHJvcHMuYXV0b0luaXQgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sdW1uQ2hhcnQgPSBuZXcgSGlnaGNoYXJ0cy5DaGFydCh0aGlzLm9wdGlvbnMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xyXG4gICAgICAgIC8vIHByb3BzIOqwkuydtCDrs4Dqsr0g65CgIOuVjOuniOuLpCDtmLjstpztlZzri6QuXHJcbiAgICAgICAgLy8g7IiY64+ZIOyDneyEseycvOuhnCDshKTsoJXrkJjslrQg7J6I7J2E65WM7JeQ66eMIOywqO2KuOulvCDsg53shLHtlbQg7KSA64ukLlxyXG4gICAgICAgIC8vIHNlcmllc+yXkCDqsJLsnbQg7J6I7Jy866m07IScIOywqO2KuOqwgCDsg53shLHrkJjslrQg7J6I7KeAIOyViuydhOuVjOyXkC4uLlxyXG4gICAgICAgIGlmKCAhdGhpcy5wcm9wcy5hdXRvSW5pdCAmJiB0aGlzLmNvbHVtbkNoYXJ0ID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sdW1uQ2hhcnQgPSBuZXcgSGlnaGNoYXJ0cy5DaGFydCh0aGlzLm9wdGlvbnMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIHByaXZhdGVcclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgb3B0aW9ucygpIHtcclxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGNvbG9ycywgY2F0ZWdvcmllcywgc2VyaWVzLCBvbkxvYWQsIHVuaXRzLCB0b29sdGlwRm9ybWF0dGVyIH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IERlZmF1bHRDaGFydE9wdGlvbi5nZXREZWZhdWx0Q2hhcnRPcHRpb24oKTtcclxuXHJcbiAgICAgICAgJC5leHRlbmQodHJ1ZSwgb3B0aW9ucywge1xyXG4gICAgICAgICAgICBjaGFydDogeyBcclxuICAgICAgICAgICAgICAgIHR5cGUgOiAnY29sdW1uJyxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyVG86IHRoaXMuaWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZih0eXBlb2YgY29sb3JzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBvcHRpb25zLCB7IGNvbG9yczogY29sb3JzIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodHlwZW9mIGNhdGVnb3JpZXMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIG9wdGlvbnMsIHsgeEF4aXM6IHsgY2F0ZWdvcmllczogY2F0ZWdvcmllcyB9IH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodHlwZW9mIHNlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgb3B0aW9ucywgeyBzZXJpZXM6IHNlcmllcyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZiBvbkxvYWQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIG9wdGlvbnMsIHsgXHJcbiAgICAgICAgICAgICAgICBjaGFydDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkOiBvbkxvYWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBpZih0eXBlb2YgdW5pdHMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIG9wdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgIHlBeGlzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVmYXVsdENoYXJ0T3B0aW9uLmNvbnZlcnRZQWl4VW5pdCh1bml0cywgdGhpcy52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodHlwZW9mIHRvb2x0aXBGb3JtYXR0ZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIG9wdGlvbnMsIHtcclxuICAgICAgICAgICAgICAgIHRvb2x0aXA6IHtcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IHRvb2x0aXBGb3JtYXR0ZXJcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBvcHRpb25zLCB0aGlzLnByb3BzLm9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICBjaGFydElkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlkO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShzZXJpZXMpIHtcclxuICAgICAgICAvLyBIaWdoY2hhcnRzIDUuMC4wXHJcbiAgICAgICAgdGhpcy5jb2x1bW5DaGFydC51cGRhdGUoe1xyXG4gICAgICAgICAgICBzZXJpZXM6IHNlcmllc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZmxvdygpIHtcclxuICAgICAgICB0aGlzLmNvbHVtbkNoYXJ0LnJlZmxvdygpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXJ0TGl2ZSgpIHtcclxuICAgICAgICBjb25zdCB7IG9uTGl2ZSwgbGl2ZUludGVydmFsIH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICBpZih0eXBlb2Ygb25MaXZlICE9PSAndW5kZWZpbmVkJykge1xyXG5cclxuICAgICAgICAgICAgbGV0IGNvbHVtbkNoYXJ0ID0gdGhpcy5jb2x1bW5DaGFydDtcclxuICAgICAgICAgICAgbGV0IGlkID0gdGhpcy5pZDtcclxuICAgICAgICAgICAgKGZ1bmN0aW9uIGFwcGVuZERhdGEoKSB7XHJcbiAgICAgICAgICAgICAgICBvbkxpdmUoY29sdW1uQ2hhcnQpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmJhc2ljQ2hhcnRUaW1lb3V0TWFwW2lkXSA9IHNldFRpbWVvdXQoYXBwZW5kRGF0YSwgbGl2ZUludGVydmFsKTtcclxuICAgICAgICAgICAgfSkuYmluZCh0aGlzKSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdG9wTGl2ZSgpIHtcclxuICAgICAgICBjb25zdCB7IG9uTGl2ZSB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBcclxuICAgICAgICBpZih0eXBlb2Ygb25MaXZlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZiAoIHdpbmRvdy5iYXNpY0NoYXJ0VGltZW91dE1hcFt0aGlzLmlkXSApIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh3aW5kb3cuYmFzaWNDaGFydFRpbWVvdXRNYXBbdGhpcy5pZF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcclxuICAgICAgICAvLyBUaW1lciDqsJ3ssrQg6rO16rCE7J20IOq1rOyEseuQmOyngCDslYrslZjri6TrqbQg7LSI6riw7ZmU66W8IOyLnOy8nOykgOuLpC5cclxuICAgICAgICAvLyBjeWdudXPsl5DshJwg7IKs7JqpIOykkeydtOq4sCDrlYzrrLjsl5Ag7YGs6rKMIOusuOygnCDrkKDqsbQg7JeG7J2EIOuTryDtlZjri6QuXHJcbiAgICAgICAgaWYgKCB3aW5kb3cuYmFzaWNDaGFydFRpbWVvdXRNYXAgPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICB3aW5kb3cuYmFzaWNDaGFydFRpbWVvdXRNYXAgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g7LCo7Yq4IOyCreygnOyLnCDrqZTrqqjrpqzsl5Ag7Jis65287JmAIOyeiOuKlCBIaWdoY2hhcnRzIOqwneyytOyZgCBUaW1lcuulvCDsp4DsmrTri6QuXHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgICAgICBsZXQgY2hhcnRJZCA9IHRoaXMuaWQ7XHJcbiAgICAgICAgJC5lYWNoKEhpZ2hjaGFydHMuY2hhcnRzLCBmdW5jdGlvbihpLCBjaGFydCkge1xyXG5cdFx0XHRpZiAoIGNoYXJ0ICYmIChjaGFydElkID09IGNoYXJ0LmNvbnRhaW5lci5wYXJlbnROb2RlLmlkKSkge1xyXG5cdFx0XHRcdGNoYXJ0LmRlc3Ryb3koKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG4gICAgICAgIGlmICggIXdpbmRvdy5iYXNpY0NoYXJ0VGltZW91dE1hcCApIHtcclxuXHRcdFx0d2luZG93LmJhc2ljQ2hhcnRUaW1lb3V0TWFwID0ge307XHJcblx0XHRcdHdpbmRvdy5iYXNpY0NoYXJ0VGltZW91dE1hcFtjaGFydElkXSA9IG51bGw7XHJcblx0XHR9IGVsc2UgaWYgKCB3aW5kb3cuYmFzaWNDaGFydFRpbWVvdXRNYXBbY2hhcnRJZF0gKSB7XHJcblx0XHRcdGNsZWFyVGltZW91dCh3aW5kb3cuYmFzaWNDaGFydFRpbWVvdXRNYXBbY2hhcnRJZF0pO1xyXG5cdFx0fVxyXG5cclxuICAgICAgICB0aGlzLmNvbHVtbkNoYXJ0ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgLy8g7ZWE7IiYIO2VreuqqVxyXG4gICAgICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBoZWlnaHQgfSA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgaWQ9e3RoaXMuaWR9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBzdHlsZT17e2hlaWdodDpoZWlnaHR9fT5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hhcnQtbG9hZGluZ1wiPjxpIGNsYXNzTmFtZT1cImZhIGZhLXJlZnJlc2ggZmEtc3BpbiBmYS1sZyBmYS1md1wiIC8+PC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbkNvbHVtbkNoYXJ0LnByb3BUeXBlcyA9IHByb3BUeXBlcztcclxuQ29sdW1uQ2hhcnQuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQ29sdW1uQ2hhcnQ7XHJcbiIsIid1c2Ugc3RyaWN0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERlZmF1bHRDaGFydE9wdGlvbiB7XHJcbiAgICBzdGF0aWMgZ2V0RGVmYXVsdENoYXJ0T3B0aW9uKHRpY2tJbnRlcnZhbCx0aWNrQ291bnQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG5cdFx0XHRjcmVkaXRzOiB7XHJcblx0XHRcdFx0ZW5hYmxlZDogZmFsc2VcclxuXHRcdFx0fSxcclxuXHQgICAgICAgIGNoYXJ0OiB7XHJcblx0ICAgICAgICAgICAgem9vbVR5cGU6ICd4JyxcclxuXHQgICAgICAgICAgICBhbmltYXRpb24gOiB0cnVlLFxyXG5cdFx0ICAgICAgICByZXNldFpvb21CdXR0b246IHtcclxuXHQgICAgICAgIFx0XHRwb3NpdGlvbjp7XHJcblx0ICAgICAgICBcdFx0XHRhbGlnbjoncmlnaHQnLFxyXG5cdCAgICAgICAgXHRcdFx0eDotNTAsXHJcblx0ICAgICAgICBcdFx0XHR5OjBcclxuXHQgICAgICAgIFx0XHR9LFxyXG5cdCAgICAgICAgICAgICAgICByZWxhdGl2ZVRvOiAnY2hhcnQnLy9vciAnY2hhcnQnXHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBldmVudHM6e1xyXG5cdCAgICAgICAgICAgIFxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB0aXRsZToge1xyXG5cdCAgICAgICAgICAgIHRleHQ6ICcnXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgc3VidGl0bGUgOiB7XHJcblx0ICAgICAgICBcdHRleHQ6ICcnXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbGVnZW5kOiB7XHJcblx0ICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIFx0bGF5b3V0OiAnaG9yaXpvbnRhbCcsXHJcbiAgICAgICAgICAgIFx0YWxpZ246ICd0b3AnLFxyXG4gICAgICAgICAgICBcdHZlcnRpY2FsQWxpZ246ICd0b3AnLFxyXG4gICAgICAgICAgICBcdHk6LTI3LFxyXG4gICAgICAgICAgICAgXHR4Oi0xMCxcclxuXHQgICAgICAgICAgICBpdGVtTWFyZ2luVG9wOjAsXHJcblx0ICAgICAgICAgICAgaXRlbU1hcmdpbkJvdHRvbTo1LFxyXG5cdCAgICAgICAgICAgIHN5bWJvbFBhZGRpbmc6MixcclxuXHQgICAgICAgICAgICBzeW1ib2xXaWR0aDogMTAsXHJcblx0ICAgICAgICBcdGl0ZW1TdHlsZToge1xyXG5cdCAgICAgICAgICAgICAgICBjb2xvcjogJyMzRTQ0NTQnLFxyXG5cdCAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcclxuXHQgICAgICAgICAgICAgICAgZm9udFNpemU6JzEyJ1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBcclxuXHQgICAgICAgIHhBeGlzOiB7XHJcblx0ICAgICAgICAgICAgdGlja0ludGVydmFsOiB0aWNrSW50ZXJ2YWwsXHJcblx0XHRcdFx0ZXZlbnRzIDoge1xyXG5cdFx0XHRcdFx0c2V0RXh0cmVtZXMgOiBmdW5jdGlvbiAoZXZlbnQpIHtcclxuXHRcdFx0XHRcdFx0dmFyIG1pbiA9IGV2ZW50Lm1pbiA9PSB1bmRlZmluZWQgPyAwIDogZXZlbnQubWluO1xyXG5cdFx0XHRcdFx0XHR2YXIgbWF4ID0gZXZlbnQubWF4ID09IHVuZGVmaW5lZCA/IHRoaXMuZGF0YU1heCA6IGV2ZW50Lm1heDtcclxuXHRcdFx0XHRcdFx0dGlja0ludGVydmFsID0gTWF0aC5yb3VuZCgobWF4IC0gbWluKSAvIHRpY2tDb3VudCk7XHJcblx0XHRcdFx0XHRcdHRoaXMub3B0aW9ucy50aWNrSW50ZXJ2YWwgPSB0aWNrSW50ZXJ2YWw7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVx0ICAgICAgICAgICAgICAgIFxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHlBeGlzOiB7XHJcblx0ICAgICAgICBcdG1pbjogMCxcclxuXHQgICAgICAgIFx0bWluUmFuZ2U6IDEsXHJcblx0ICAgICAgICBcdHRpdGxlOntcclxuXHQgICAgICAgIFx0XHR0ZXh0OicnXHJcblx0ICAgICAgICBcdH0sXHJcblx0ICAgICAgICBcdHN0YWNrTGFiZWxzIDoge1xyXG5cdFx0XHQgICAgICAgICBlbmFibGVkOiBmYWxzZSxcclxuXHRcdFx0ICAgICAgICAgc3R5bGU6IHtcclxuXHRcdFx0ICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXHJcblx0XHRcdCAgICAgICAgICAgICAgY29sb3I6IChIaWdoY2hhcnRzLnRoZW1lICYmIEhpZ2hjaGFydHMudGhlbWUudGV4dENvbG9yKSB8fCAnZ3JheSdcclxuXHRcdFx0ICAgICAgICAgfVxyXG5cdFx0XHQgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRvb2x0aXA6IHtcclxuXHQgICAgICAgIFx0c2hhcmVkOiB0cnVlLFxyXG5cdCAgICAgICAgXHRjcm9zc2hhaXJzOiB7XHJcblx0ICAgICAgICAgICAgIFx0Y29sb3I6J3JlZCcsXHJcblx0ICAgICAgICAgICAgIFx0d2lkdGg6MSAgIFxyXG5cdCAgICAgICAgICAgIH0sXHJcblx0ICAgICAgICBcdHVzZUhUTUw6IHRydWUsXHJcblx0ICAgICAgICBcdGJhY2tncm91bmRDb2xvcjoge1xyXG5cdCAgICAgICAgXHRcdGxpbmVhckdyYWRpZW50OiBbMCwgMCwgMCwgNjBdLFxyXG5cdCAgICAgICAgXHRcdHN0b3BzOiBbXHJcblx0ICAgICAgICBcdFx0ICAgICAgICBbMCwgJyNGRkZGRkYnXSxcclxuXHQgICAgICAgIFx0XHQgICAgICAgIFsxLCAnI2YzZjNmMyddXHJcblx0ICAgICAgICBcdFx0ICAgICAgIF1cclxuXHQgICAgICAgIFx0fSxcclxuXHQgICAgICAgIFx0Ym9yZGVyV2lkdGg6IDEsXHJcblx0ICAgICAgICBcdGJvcmRlckNvbG9yOiAnIzUyYjJlYSdcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBwbG90T3B0aW9uczoge1xyXG5cdCAgICAgICAgICAgIGNvbHVtbjoge1xyXG5cdCAgICAgICAgICAgIFx0Ly9zdGFja2luZzogJ25vcm1hbCcsXHJcblx0ICAgICAgICAgICAgICAgIGRhdGFMYWJlbHM6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgY29sb3I6IChIaWdoY2hhcnRzLnRoZW1lICYmIEhpZ2hjaGFydHMudGhlbWUuZGF0YUxhYmVsc0NvbG9yKSB8fCAnd2hpdGUnLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0U2hhZG93OiAnMCAwIDNweCBibGFjaydcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgcG9pbnRQYWRkaW5nOiAwLjIsXHJcblx0ICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAwLFxyXG5cdCAgICAgICAgICAgICAgICBzdGF0ZXM6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGhvdmVyOiB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBhcmVhOiB7XHJcblx0ICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogMSxcclxuXHQgICAgICAgICAgICAgICAgbWFya2VyOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBzaGFkb3c6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3Zlcjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiAxXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZU1vdXNlVHJhY2tpbmc6IHRydWVcclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIGxpbmU6IHtcclxuXHQgICAgICAgICAgICAgICAgbGluZVdpZHRoOiAxLFxyXG5cdCAgICAgICAgICAgICAgICBtYXJrZXI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6dHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIHN5bWJvbDogJ2NpcmNsZScsXHJcblx0ICAgICAgICAgICAgICAgICAgICByYWRpdXM6IDAuNVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBzcGxpbmU6IHtcclxuXHQgICAgICAgICAgICAgICAgbGluZVdpZHRoOiAxLFxyXG5cdCAgICAgICAgICAgICAgICBtYXJrZXI6IHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6dHJ1ZSxcclxuXHQgICAgICAgICAgICAgICAgICAgIHN5bWJvbDogJ2NpcmNsZScsXHJcblx0ICAgICAgICAgICAgICAgICAgICByYWRpdXM6IDAuNVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICBhcmVhcmFuZ2U6e1xyXG5cdFx0ICAgICAgICAgICAgdHVyYm9UaHJlc2hvbGQ6MjAwMFxyXG5cdFx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIHNlcmllczoge1xyXG5cdCAgICAgICAgICAgIFx0Y29ubmVjdE51bGxzOiB0cnVlLFxyXG5cdCAgICAgICAgICAgIFx0cG9pbnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0XHR9O1xyXG4gICAgfVxyXG5cclxuXHRzdGF0aWMgZ2V0U2NhdHRlckNoYXJ0T3B0aW9uKHRpY2tJbnRlcnZhbCxzdGVwKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRsb2FkaW5nOiB7XHJcblx0ICAgICAgICAgICAgbGFiZWxTdHlsZToge1xyXG5cdCAgICAgICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcclxuXHQgICAgICAgICAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCJcclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIHN0eWxlOiB7XHJcblx0ICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2dyYXknXHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHRcdFx0Y3JlZGl0czoge1xyXG5cdFx0XHRcdGVuYWJsZWQ6IGZhbHNlXHJcblx0XHRcdH0sXHJcblx0XHRcdGV4cG9ydGluZzoge1xyXG4gICAgXHRcdFx0ZW5hYmxlZDogZmFsc2UgXHJcblx0XHRcdH0sXHJcblx0ICAgICAgICBjaGFydDoge1xyXG5cdCAgICAgICAgXHR0eXBlOiAnc2NhdHRlcicsXHJcblx0ICAgICAgICAgICAgem9vbVR5cGU6ICd4eScsXHJcblx0ICAgICAgICAgICAgYW5pbWF0aW9uIDogZmFsc2UsXHJcblx0XHQgICAgICAgIHNwYWNpbmdSaWdodDogMTAsXHJcblx0XHQgICAgICAgIHJlc2V0Wm9vbUJ1dHRvbjoge1xyXG5cdCAgICAgICAgXHRcdHBvc2l0aW9uOntcclxuXHQgICAgICAgIFx0XHRcdGFsaWduOidyaWdodCcsXHJcblx0ICAgICAgICBcdFx0XHR4Oi01MCxcclxuXHQgICAgICAgIFx0XHRcdHk6MFxyXG5cdCAgICAgICAgXHRcdH0sXHJcblx0ICAgICAgICAgICAgICAgIHJlbGF0aXZlVG86ICdjaGFydCcvL29yICdjaGFydCdcclxuXHQgICAgICAgICAgICB9LFxyXG5cdCAgICAgICAgICAgIGV2ZW50czp7XHJcblx0ICAgICAgICAgICAgXHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHQgICAgICAgIHRpdGxlOiB7XHJcblx0ICAgICAgICAgICAgdGV4dDogJydcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBzdWJ0aXRsZToge1xyXG5cdCAgICAgICAgICAgIHRleHQ6ICcnXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgbGVnZW5kOiB7XHJcblx0XHRcdFx0ZW5hYmxlZDogZmFsc2UsXHJcblx0ICAgICAgICAgICAgbGF5b3V0OiAndmVydGljYWwnLFxyXG5cdCAgICAgICAgICAgIGFsaWduOiAnbGVmdCcsXHJcblx0ICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXHJcblx0ICAgICAgICAgICAgbWF4SGVpZ2h0OiAxMDAsXHJcblx0ICAgICAgICAgICAgeDogNTAsIFxyXG5cdCAgICAgICAgICAgIHk6IC0yNyxcclxuXHQgICAgICAgICAgICBmbG9hdGluZzogdHJ1ZSxcclxuXHQgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IChIaWdoY2hhcnRzLnRoZW1lICYmIEhpZ2hjaGFydHMudGhlbWUubGVnZW5kQmFja2dyb3VuZENvbG9yKSB8fCAnI0ZGRkZGRicsXHJcblx0ICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEsXHJcblx0ICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcjRDhEOEQ4JyxcclxuXHQgICAgICAgICAgICBib3JkZXJSYWRpdXM6IDUsXHJcblx0ICAgICAgICAgICAgaXRlbU1hcmdpblRvcDowLFxyXG5cdCAgICAgICAgICAgIGl0ZW1NYXJnaW5Cb3R0b206NSxcclxuXHQgICAgICAgICAgICBzeW1ib2xQYWRkaW5nOjIsXHJcblx0ICAgICAgICAgICAgc3ltYm9sV2lkdGg6IDIwLFxyXG5cdCAgICAgICAgICAgIHN5bWJvbFJhZGl1czo2LFxyXG5cdCAgICAgICAgXHRpdGVtU3R5bGU6IHtcclxuXHQgICAgICAgICAgICAgICAgY29sb3I6ICcjM0U0NDU0JyxcclxuXHQgICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXHJcblx0ICAgICAgICAgICAgICAgIGZvbnRTaXplOicxMicsXHJcblx0ICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICB0aXRsZToge1xyXG5cdCAgICAgICAgICAgIFx0dGV4dDogJydcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgeEF4aXM6IHtcclxuXHQgICAgICAgIFx0dGlja21hcmtQbGFjZW1lbnQ6J29uJyxcclxuICAgICAgICBcdFx0YWxsb3dEZWNpbWFsczpmYWxzZSxcclxuICAgICAgICBcdFx0dHlwZTonZGF0ZXRpbWUnLFxyXG4gICAgICAgIFx0XHRzdGFydE9uVGljazp0cnVlLFxyXG4gICAgICAgIFx0XHRlbmRPblRpY2s6dHJ1ZSxcclxuICAgICAgICBcdFx0dGlja0ludGVydmFsOnRpY2tJbnRlcnZhbCxcclxuICAgICAgICBcdFx0ZGF0ZVRpbWVMYWJlbEZvcm1hdHM6IHtcclxuICAgICAgICBcdFx0XHRzZWNvbmQ6JyVIOiVNOiVTJyxcclxuICAgICAgICBcdFx0XHRtaW51dGU6JyVIOiVNJ1xyXG4gICAgICAgIFx0XHR9LFxyXG4gICAgICAgIFx0XHRsYWJlbHM6IHtcclxuICAgICAgICBcdFx0XHRzdGVwOnN0ZXAsXHJcbiAgICAgICAgXHRcdFx0c3RhZ2dlckxpbmVzOjFcclxuICAgICAgICBcdFx0fSxcclxuICAgICAgICBcdFx0dGlja1dpZHRoOjBcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICB5QXhpczoge1xyXG5cdCAgICAgICAgXHRvcmRpbmFsOmZhbHNlLFxyXG5cdCAgICAgICAgXHRzaG93TGFzdExhYmVsOnRydWUsXHJcblx0ICAgICAgICBcdHRpdGxlOnt0ZXh0OicnfSxcclxuXHQgICAgICAgIFx0dGlja0xlbmd0aDo4LFxyXG5cdCAgICAgICAgXHR0aWNrUGl4ZWxJbnRlcnZhbDoxMDAsXHJcblx0ICAgICAgICBcdG1pbjowLFxyXG5cdCAgICAgICAgXHRtaW5SYW5nZToxXHJcblx0ICAgICAgICB9LFxyXG5cdCAgICAgICAgdG9vbHRpcDoge1xyXG5cdCAgICAgICAgXHRzaGFyZWQ6IHRydWUsXHJcblx0ICAgICAgICBcdHVzZUhUTUw6IHRydWUsXHJcblx0ICAgICAgICBcdGJhY2tncm91bmRDb2xvcjoge1xyXG5cdCAgICAgICAgXHRcdGxpbmVhckdyYWRpZW50OiBbMCwgMCwgMCwgNjBdLFxyXG5cdCAgICAgICAgXHRcdHN0b3BzOiBbXHJcblx0ICAgICAgICBcdFx0ICAgICAgICBbMCwgJyNGRkZGRkYnXSxcclxuXHQgICAgICAgIFx0XHQgICAgICAgIFsxLCAnI2YzZjNmMyddXHJcblx0ICAgICAgICBcdFx0ICAgICAgIF1cclxuXHQgICAgICAgIFx0fSxcclxuXHQgICAgICAgIFx0Ym9yZGVyV2lkdGg6IDEsXHJcblx0ICAgICAgICBcdGJvcmRlckNvbG9yOiAnIzUyYjJlYScsXHJcblx0ICAgICAgICBcdGFuaW1hdGlvbjogZmFsc2VcclxuXHQgICAgICAgIH0sXHJcblx0ICAgICAgICBwbG90T3B0aW9uczoge1xyXG5cdCAgICAgICAgXHRzY2F0dGVyOiB7XHJcblx0ICAgICAgICAgICAgICAgIG1hcmtlcjoge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiAxLjVcclxuXHQgICAgICAgICAgICAgICAgfSxcclxuXHQgICAgICAgICAgICAgICAgZXZlbnRzOntcclxuXHRcdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0c3RhdGljIGNvbnZlcnRZQWl4VW5pdCh1bml0U3RyLCB2YWx1ZSkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IHZhbHVlO1xyXG5cdFx0aWYodW5pdFN0cikge1xyXG5cdFx0XHR2YXIgbGFiZWwgPSB2YWx1ZTtcclxuICAgICAgICBcdHZhciBzZWVkID0gMTAwMDsgLy8gZGVjaW1hbCgxMDAwKSBvciBieXRlcygxMDI0KVxyXG4gICAgICAgIFx0dmFyIHUgPSAnJztcclxuICAgICAgICBcdHZhciBsb3dDYXNlVW5pdCA9IHVuaXRTdHIudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBcdHZhciB1bml0Q29uc3QgPSBbJ2snLCAnTScsICdHJywgJ1QnLCAnUCddO1xyXG4gICAgICAgIFx0dmFyIHRpbWVDb25zdCA9IFsnbXMnLCAnc2VjJywgJ21pbicsICdob3VyJywgJ2RheSddO1xyXG4gICAgICAgIFx0dmFyIHRpbWVTZWVkID0gWzEsIDEwMDAsIDEwMDAqNjAsIDEwMDAqNjAqNjAsIDEwMDAqNjAqNjAqMjRdO1xyXG4gICAgICAgIFx0XHJcbiAgICAgICAgXHQvLyBzZWVkIOqwkiDshKTsoJUoMTAwMCBvciAxMDI0KVxyXG4gICAgICAgIFx0aWYoIGxvd0Nhc2VVbml0LmluZGV4T2YoXCJicHNcIikgPiAtMSB8fFxyXG4gICAgICAgIFx0XHRsb3dDYXNlVW5pdC5pbmRleE9mKFwiYml0XCIpID4gLTEgfHxcclxuICAgICAgICBcdFx0bG93Q2FzZVVuaXQuaW5kZXhPZihcImtiXCIpID4gLTEgfHxcclxuICAgICAgICBcdFx0bG93Q2FzZVVuaXQuaW5kZXhPZihcIm1iXCIpID4gLTEgfHxcclxuICAgICAgICBcdFx0bG93Q2FzZVVuaXQuaW5kZXhPZihcImdiXCIpID4gLTEgfHxcclxuICAgICAgICBcdFx0bG93Q2FzZVVuaXQuaW5kZXhPZihcInRiXCIpID4gLTEgfHxcclxuICAgICAgICBcdFx0bG93Q2FzZVVuaXQuaW5kZXhPZihcInBiXCIpID4gLTFcclxuICAgICAgICBcdCkge1xyXG4gICAgICAgIFx0XHRzZWVkID0gMTAyNDtcclxuICAgICAgICBcdH1lbHNlIGlmKCBsb3dDYXNlVW5pdC5pbmRleE9mKFwidXNcIikgPiAtMSB8fFxyXG4gICAgICAgIFx0XHRsb3dDYXNlVW5pdC5pbmRleE9mKFwibXNcIikgPiAtMSB8fFxyXG4gICAgICAgICAgICBcdGxvd0Nhc2VVbml0LmluZGV4T2YoXCJzZWNcIikgPiAtMSB8fFxyXG4gICAgICAgICAgICBcdGxvd0Nhc2VVbml0LmluZGV4T2YoXCJtaW5cIikgPiAtMSB8fFxyXG4gICAgICAgICAgICBcdGxvd0Nhc2VVbml0LmluZGV4T2YoXCJob3VyXCIpID4gLTEgfHxcclxuICAgICAgICAgICAgXHRsb3dDYXNlVW5pdC5pbmRleE9mKFwiZGF5XCIpID4gLTFcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIFx0c2VlZCA9IC0xO1xyXG4gICAgICAgICAgICB9ZWxzZSBpZihsb3dDYXNlVW5pdC5pbmRleE9mKFwiYlwiKSA+IC0xKXtcclxuICAgICAgICBcdFx0c2VlZCA9IDEwMDA7XHJcbiAgICAgICAgXHR9ZWxzZXtcclxuICAgICAgICBcdFx0cmV0dXJuIHZhbHVlK3VuaXRTdHI7XHJcbiAgICAgICAgXHR9XHJcbiAgICAgICAgXHRcclxuICAgICAgICBcdC8vIOuLqOychOulvCDtlZjrgpjroZwg7J287KCV7ZWY6rKMIOunnuy2mOuLpC5cclxuICAgICAgICBcdGlmKGxvd0Nhc2VVbml0LmluZGV4T2YoXCJrYlwiKSA+IC0xKSBcclxuICAgICAgICBcdFx0bGFiZWwgKj1zZWVkO1xyXG4gICAgICAgIFx0ZWxzZSBpZihsb3dDYXNlVW5pdC5pbmRleE9mKFwibWJcIikgPiAtMSkgXHJcbiAgICAgICAgXHRcdGxhYmVsICo9IE1hdGgucG93KHNlZWQsIDIpO1xyXG4gICAgICAgIFx0ZWxzZSBpZihsb3dDYXNlVW5pdC5pbmRleE9mKFwiZ2JcIikgPiAtMSkgXHJcbiAgICAgICAgXHRcdGxhYmVsICo9IE1hdGgucG93KHNlZWQsIDMpO1xyXG4gICAgICAgIFx0ZWxzZSBpZihsb3dDYXNlVW5pdC5pbmRleE9mKFwidGJcIikgPiAtMSkgXHJcbiAgICAgICAgXHRcdGxhYmVsICo9IE1hdGgucG93KHNlZWQsIDQpO1xyXG4gICAgICAgIFx0ZWxzZSBpZihsb3dDYXNlVW5pdC5pbmRleE9mKFwicGJcIikgPiAtMSkgXHJcbiAgICAgICAgXHRcdGxhYmVsICo9IE1hdGgucG93KHNlZWQsIDUpO1xyXG4gICAgICAgIFx0ZWxzZSBpZihsb3dDYXNlVW5pdC5pbmRleE9mKFwibXNcIikgPiAtMSkge1xyXG4gICAgICAgICBcdFx0bGFiZWwgKj10aW1lU2VlZFswXTtcclxuXHRcdFx0fSBlbHNlIGlmKGxvd0Nhc2VVbml0LmluZGV4T2YoXCJzZWNcIikgPiAtMSAmJiBsb3dDYXNlVW5pdCAhPSBcImNvdW50X3Blcl9zZWNcIikge1xyXG4gICAgICAgICBcdFx0bGFiZWwgKj0gdGltZVNlZWRbMV07XHJcblx0XHRcdH0gZWxzZSBpZihsb3dDYXNlVW5pdC5pbmRleE9mKFwibWluXCIpID4gLTEpIHtcclxuICAgICAgICAgXHRcdGxhYmVsICo9IHRpbWVTZWVkWzJdO1xyXG5cdFx0XHR9IGVsc2UgaWYobG93Q2FzZVVuaXQuaW5kZXhPZihcImhvdXJcIikgPiAtMSkge1xyXG4gICAgICAgICBcdFx0bGFiZWwgKj0gdGltZVNlZWRbM107XHJcblx0XHRcdH0gZWxzZSBpZihsb3dDYXNlVW5pdC5pbmRleE9mKFwiZGF5XCIpID4gLTEpIHtcclxuICAgICAgICAgXHRcdGxhYmVsICo9IHRpbWVTZWVkWzRdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL+uLqOychOqwgCDsnbzsoJXtlbTsp4Qg6rCSKGRlY2ltYWwp7J2EIOqwgOyngOqzoCDsnb3quLAg7Ims7Jq0IOqwkuqzvCDri6jsnITroZwg67OA7ZmY7ZWc64ukLlxyXG4gICAgICAgIFx0aWYoIHNlZWQgIT0gLTEgKSB7XHJcbiAgICAgICAgXHRcdC8vIHNlZWQg6rCAIC0x7J28IOyVhOuLiOuptCDsmqnrn4kg6rSA66CoIOuLqOychFxyXG4gICAgICAgIFx0XHRmb3IodmFyIGkgPSAxOyBpIDwgdW5pdENvbnN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBcdFx0XHRcdGlmKGxhYmVsID4gKE1hdGgucG93KHNlZWQsIGkpIC0gMSkgJiYgbGFiZWwgPCBNYXRoLnBvdyhzZWVkLCBpKyAxKSkge1xyXG4gICAgICAgICAgICAgICAgXHRcdGxhYmVsID0gbGFiZWwvTWF0aC5wb3coc2VlZCwgaSk7XHJcbiAgICAgICAgICAgICAgICBcdFx0dSA9IHVuaXRDb25zdFtpIC0gMV07XHJcbiAgICAgICAgICAgICAgICBcdH0gXHJcbiAgICBcdFx0XHR9XHJcbiAgICAgICAgXHR9IGVsc2Uge1xyXG4gICAgICAgIFx0XHQvLyBzZWVkIOqwgCAtMSDsnbTrqbQg66y07KGw6rG0IOyLnOqwhCDqtIDroKgg64uo7JyEXHJcbiAgICAgICAgXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aW1lQ29uc3QubGVuZ3RoOyBpKyspIHtcclxuICAgIFx0XHRcdFx0aWYobGFiZWwgPiAodGltZVNlZWRbaV0tMSkgJiYgbGFiZWwgPCB0aW1lU2VlZFtpKzFdKSB7XHJcbiAgICAgICAgICAgICAgICBcdFx0bGFiZWwgPSBsYWJlbC90aW1lU2VlZFtpXTtcclxuICAgICAgICAgICAgICAgIFx0XHR1ID0gdGltZUNvbnN0W2ldO1xyXG4gICAgICAgICAgICAgICAgXHR9IFxyXG4gICAgXHRcdFx0fVxyXG4gICAgICAgIFx0fVxyXG5cdFx0XHRcclxuICAgICAgICBcdC8vIG51bWJlckZvcm1hdCAoTnVtYmVyIG51bWJlciwgW051bWJlciBkZWNpbWFsc10sIFtTdHJpbmcgZGVjaW1hbFBvaW50XSwgW1N0cmluZyB0aG91c2FuZHNTZXBdKVxyXG4gICAgICAgIFx0dmFyIG51bWJlckRlY2ltYWxzID0gMDtcclxuICAgICAgICBcdGlmKGxhYmVsIDwgMTApIHtcclxuICAgICAgICBcdFx0bnVtYmVyRGVjaW1hbHMgPSAxOyBcclxuICAgICAgICBcdH1cclxuICAgICAgICBcdHJlc3VsdCA9IEhpZ2hjaGFydHMubnVtYmVyRm9ybWF0KGxhYmVsLCBudW1iZXJEZWNpbWFscywgJy4nLCAnLCcpICsgdTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fVxyXG5cclxuXHRzdGF0aWMgdG9vbHRpcEZvcm1hdHRlcih2YWx1ZUtleSwgdW5pdFN0ciwgY29udmVydFlBaXhVbml0KSB7XHJcblx0XHRpZiggY29udmVydFlBaXhVbml0ID09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0Y29udmVydFlBaXhVbml0ID0gdGhpcy5jb252ZXJ0WUFpeFVuaXQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciBzID0gJzxzcGFuIHN0eWxlPVwiY29sb3I6IzMzMztcIj4mbmJzcDs8Yj4nKyAgdGhpcy5wb2ludHNbMF0ua2V5ICsnPC9iPjwvc3Bhbj48dGFibGUgd2lkdGg9MjAwPic7XHJcblx0XHRcdHMgKz0gJzx0ciA+PHRkIGNvbHNwYW49XCIyXCIgaGVpZ2h0PVwiMVwiICBzdHlsZT1cImJvcmRlci10b3A6IDFweCBzb2xpZCAjY2NjXCIgPjwvdGQ+PC90cj4nO1xyXG5cdFx0XHQkLmVhY2godGhpcy5wb2ludHMsIGZ1bmN0aW9uKGksIHBvaW50KSB7XHJcblx0XHRcdHZhciBkYXRhO1xyXG5cdFx0XHRcdGZvciAodmFyIHggaW4gcG9pbnQuc2VyaWVzLmRhdGEpe1xyXG5cdFx0XHRcdFx0dmFyIGtleSA9IGV2YWwoXCJwb2ludC5zZXJpZXMuZGF0YVt4XS5cIiArIHZhbHVlS2V5KTtcclxuXHRcdFx0XHRcdGlmKHBvaW50LmtleSA9PSBrZXkpIHtcclxuXHRcdFx0XHRcdFx0ZGF0YSA9IHBvaW50LnNlcmllcy5kYXRhW3hdLnk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgYztcclxuXHRcdFx0XHRpZiggcG9pbnQuc2VyaWVzLmNvbG9yLnN0b3BzICE9IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHRcdC8vIEdyYWRpZW50IGNvbG9yXHJcblx0XHRcdFx0XHRjID0gcG9pbnQuc2VyaWVzLmNvbG9yLnN0b3BzWzFdWzFdO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyBub3QgR3JhZGllbnQgY29sb3JcclxuXHRcdFx0XHRcdGMgPSBwb2ludC5zZXJpZXMuY29sb3I7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHMgKz0gJzx0cj48dGQgc3R5bGU9XCJjb2xvcjonICsgYyArICdcIj4nICsgJ+KXjyZuYnNwOycgKyBwb2ludC5zZXJpZXMubmFtZSArIFwiOiA8L3RkPlwiXHJcblx0XHRcdFx0cyArPSAnPHRkIHN0eWxlPVwidGV4dC1hbGlnbjogcmlnaHQ7IGNvbG9yOiM0NDQ7IGxpbmUtaGVpaHQ6MS4yZW07XCI+PGI+JyArIGNvbnZlcnRZQWl4VW5pdCh1bml0U3RyLCBkYXRhKSArICc8L2I+PC90ZD48L3RyPic7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRzICs9ICc8L3RhYmxlPic7XHJcblx0XHRcdFxyXG5cdFx0XHRyZXR1cm4gcztcclxuXHRcdH07XHJcblx0fVxyXG59IiwiJ3VzZSBzdHJpY3QnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSGlnaGNoYXJ0c09wdGlvbiB7XHJcbiAgICBzdGF0aWMgc2V0VXNlVVRDKHVzZVVUQykge1xyXG5cdFx0aWYoIHVzZVVUQyA9PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdHVzZVVUQyA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRIaWdoY2hhcnRzLnNldE9wdGlvbnMoe1xyXG5cdFx0XHRnbG9iYWw6IHtcclxuXHRcdFx0XHR1c2VVVEM6IHVzZVVUQ1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcbn0iLCIvKipcclxuICogTGluZUNoYXJ0IGNvbXBvbmVudFxyXG4gKlxyXG4gKiB2ZXJzaW9uIDx0dD4kIFZlcnNpb246IDEuMCAkPC90dD4gZGF0ZToyMDE2LzAzLzAzXHJcbiAqIGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmtqdWh3YUBua2lhLmNvLmtyXCI+a2p1aHdhPC9hPlxyXG4gKlxyXG4gKiBleGFtcGxlOlxyXG4gKiA8UHVmLkxpbmVDaGFydCBvcHRpb25zPXtvcHRpb25zfSAvPlxyXG4gKlxyXG4gKiBIaWdoY2hhcnRzIOudvOydtOu4jOufrOumrOyXkCDsooXsho3soIHsnbTri6QuXHJcbiAqIFxyXG4gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IFV0aWwgZnJvbSAnLi4vLi4vc2VydmljZXMvVXRpbCc7XHJcbmltcG9ydCBEZWZhdWx0Q2hhcnRPcHRpb24gZnJvbSAnLi9EZWZhdWx0Q2hhcnRPcHRpb24nO1xyXG5cclxuY29uc3QgcHJvcFR5cGVzID0ge1xyXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBvcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0LFxyXG4gICAgYXV0b0luaXQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgXHJcbiAgICBjb2xvcnM6IFByb3BUeXBlcy5hcnJheSxcclxuICAgIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxyXG5cclxuICAgIGNhdGVnb3JpZXM6IFByb3BUeXBlcy5hcnJheSxcclxuICAgIHNlcmllczogUHJvcFR5cGVzLmFycmF5LFxyXG4gICAgdGlja0ludGVydmFsOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgdGlja0NvdW50OiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgbGl2ZUludGVydmFsOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgdW5pdHM6IFByb3BUeXBlcy5zdHJpbmcsXHJcblxyXG4gICAgb25Mb2FkOiBQcm9wVHlwZXMuZnVuYyxcclxuICAgIC8vIOyLpOyLnOqwhCDrjbDsnbTtg4Ag7LaU6rCAIEZ1bmNcclxuICAgIG9uTGl2ZTogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICAvLyBUb29sdGlwXHJcbiAgICB0b29sdGlwRm9ybWF0dGVyOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuLy8g7YG0656Y7Iqk6rCAIOyDneyEseuQoCDrlYwg7ZWc67KIIO2YuOy2nOuQmOqzoCDsupDsi5zrkJzri6QuXHJcbi8vIOu2gOuqqCDsu7Ttj6zrhIztirjsl5DshJwgcHJvcOydtCDrhJjslrTsmKTsp4Ag7JWK7J2AIOqyveyasCAoaW4g7Jew7IKw7J6Q66GcIO2ZleyduCkg66ek7ZWR7J2YIOqwkuydtCB0aGlzLnByb3Bz7JeQIOyEpOygleuQnOuLpC5cclxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xyXG4gICAgd2lkdGg6IG51bGwsXHJcbiAgICBoZWlnaHQ6IG51bGwsXHJcbiAgICB0aWNrQ291bnQ6IDUsXHJcbiAgICB0aWNrSW50ZXJ2YWw6IDEsXHJcbiAgICBsaXZlSW50ZXJ2YWw6IDEwMDAsXHJcbiAgICBhdXRvSW5pdDogdHJ1ZVxyXG59O1xyXG5cclxuY2xhc3MgTGluZUNoYXJ0IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG5cclxuICAgICAgICBsZXQgaWQgPSBwcm9wcy5pZDtcclxuICAgICAgICBpZih0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGlkID0gVXRpbC5nZXRVVUlEKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgdGhpcy5saW5lQ2hhcnQgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBNYW51YWxseSBiaW5kIHRoaXMgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuLi5cclxuICAgICAgICAvL3RoaXMub25Mb2FkID0gdGhpcy5vbkxvYWQuYmluZCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICBpZiggdGhpcy5wcm9wcy5hdXRvSW5pdCApIHtcclxuICAgICAgICAgICAgdGhpcy5saW5lQ2hhcnQgPSBuZXcgSGlnaGNoYXJ0cy5DaGFydCh0aGlzLm9wdGlvbnMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xyXG4gICAgICAgIC8vIHByb3BzIOqwkuydtCDrs4Dqsr0g65CgIOuVjOuniOuLpCDtmLjstpztlZzri6QuXHJcbiAgICAgICAgLy8g7IiY64+ZIOyDneyEseycvOuhnCDshKTsoJXrkJjslrQg7J6I7J2E65WM7JeQ66eMIOywqO2KuOulvCDsg53shLHtlbQg7KSA64ukLlxyXG4gICAgICAgIC8vIHNlcmllc+yXkCDqsJLsnbQg7J6I7Jy866m07IScIOywqO2KuOqwgCDsg53shLHrkJjslrQg7J6I7KeAIOyViuydhOuVjOyXkC4uLlxyXG4gICAgICAgIGlmKCAhdGhpcy5wcm9wcy5hdXRvSW5pdCAmJiB0aGlzLmxpbmVDaGFydCA9PSBudWxsICkge1xyXG4gICAgICAgICAgICB0aGlzLmxpbmVDaGFydCA9IG5ldyBIaWdoY2hhcnRzLkNoYXJ0KHRoaXMub3B0aW9ucygpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gcHJpdmF0ZVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBvcHRpb25zKCkge1xyXG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgY29sb3JzLCBjYXRlZ29yaWVzLCBzZXJpZXMsIG9uTG9hZCwgdGlja0NvdW50LCB0aWNrSW50ZXJ2YWwsIHVuaXRzLCB0b29sdGlwRm9ybWF0dGVyIH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IERlZmF1bHRDaGFydE9wdGlvbi5nZXREZWZhdWx0Q2hhcnRPcHRpb24odGlja0ludGVydmFsLCB0aWNrQ291bnQpO1xyXG5cclxuICAgICAgICAkLmV4dGVuZCh0cnVlLCBvcHRpb25zLCB7XHJcbiAgICAgICAgICAgIGNoYXJ0OiB7IFxyXG4gICAgICAgICAgICAgICAgdHlwZSA6ICdsaW5lJyxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyVG86IHRoaXMuaWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZih0eXBlb2YgY29sb3JzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBvcHRpb25zLCB7IGNvbG9yczogY29sb3JzIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodHlwZW9mIGNhdGVnb3JpZXMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIG9wdGlvbnMsIHsgeEF4aXM6IHsgY2F0ZWdvcmllczogY2F0ZWdvcmllcyB9IH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodHlwZW9mIHNlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgb3B0aW9ucywgeyBzZXJpZXM6IHNlcmllcyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZiBvbkxvYWQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIG9wdGlvbnMsIHsgXHJcbiAgICAgICAgICAgICAgICBjaGFydDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50czoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2FkOiBvbkxvYWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodHlwZW9mIHVuaXRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBvcHRpb25zLCB7XHJcbiAgICAgICAgICAgICAgICB5QXhpczoge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlZmF1bHRDaGFydE9wdGlvbi5jb252ZXJ0WUFpeFVuaXQodW5pdHMsIHRoaXMudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZiB0b29sdGlwRm9ybWF0dGVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBvcHRpb25zLCB7XHJcbiAgICAgICAgICAgICAgICB0b29sdGlwOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiB0b29sdGlwRm9ybWF0dGVyXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMub3B0aW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgb3B0aW9ucywgdGhpcy5wcm9wcy5vcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgY2hhcnRJZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pZDtcclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGUoc2VyaWVzKSB7XHJcbiAgICAgICAgLy8gSGlnaGNoYXJ0cyA1LjAuMFxyXG4gICAgICAgIHRoaXMubGluZUNoYXJ0LnVwZGF0ZSh7XHJcbiAgICAgICAgICAgIHNlcmllczogc2VyaWVzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVmbG93KCkge1xyXG4gICAgICAgIHRoaXMubGluZUNoYXJ0LnJlZmxvdygpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXJ0TGl2ZSgpIHtcclxuICAgICAgICBjb25zdCB7IG9uTGl2ZSwgbGl2ZUludGVydmFsIH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICBpZih0eXBlb2Ygb25MaXZlICE9PSAndW5kZWZpbmVkJykge1xyXG5cclxuICAgICAgICAgICAgbGV0IGxpbmVDaGFydCA9IHRoaXMubGluZUNoYXJ0O1xyXG4gICAgICAgICAgICBsZXQgaWQgPSB0aGlzLmlkO1xyXG4gICAgICAgICAgICAoZnVuY3Rpb24gYXBwZW5kRGF0YSgpIHtcclxuICAgICAgICAgICAgICAgIG9uTGl2ZShsaW5lQ2hhcnQpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmJhc2ljQ2hhcnRUaW1lb3V0TWFwW2lkXSA9IHNldFRpbWVvdXQoYXBwZW5kRGF0YSwgbGl2ZUludGVydmFsKTtcclxuICAgICAgICAgICAgfSkuYmluZCh0aGlzKSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdG9wTGl2ZSgpIHtcclxuICAgICAgICBjb25zdCB7IG9uTGl2ZSB9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICAgICAgaWYodHlwZW9mIG9uTGl2ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWYgKCB3aW5kb3cuYmFzaWNDaGFydFRpbWVvdXRNYXBbdGhpcy5pZF0gKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQod2luZG93LmJhc2ljQ2hhcnRUaW1lb3V0TWFwW3RoaXMuaWRdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XHJcbiAgICAgICAgLy8gVGltZXIg6rCd7LK0IOqzteqwhOydtCDqtazshLHrkJjsp4Ag7JWK7JWY64uk66m0IOy0iOq4sO2ZlOulvCDsi5zsvJzspIDri6QuXHJcbiAgICAgICAgLy8gY3lnbnVz7JeQ7IScIOyCrOyaqSDspJHsnbTquLAg65WM66y47JeQIO2BrOqyjCDrrLjsoJwg65Cg6rG0IOyXhuydhCDrk68g7ZWY64ukLlxyXG4gICAgICAgIGlmICggd2luZG93LmJhc2ljQ2hhcnRUaW1lb3V0TWFwID09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgd2luZG93LmJhc2ljQ2hhcnRUaW1lb3V0TWFwID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOywqO2KuCDsgq3soJzsi5wg66mU66qo66as7JeQIOyYrOudvOyZgCDsnojripQgSGlnaGNoYXJ0cyDqsJ3ssrTsmYAgVGltZXLrpbwg7KeA7Jq064ukLlxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0SWQgPSB0aGlzLmlkO1xyXG4gICAgICAgICQuZWFjaChIaWdoY2hhcnRzLmNoYXJ0cywgZnVuY3Rpb24oaSwgY2hhcnQpIHtcclxuXHRcdFx0aWYgKCBjaGFydCAmJiAoY2hhcnRJZCA9PSBjaGFydC5jb250YWluZXIucGFyZW50Tm9kZS5pZCkpIHtcclxuXHRcdFx0XHRjaGFydC5kZXN0cm95KCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuICAgICAgICBpZiAoICF3aW5kb3cuYmFzaWNDaGFydFRpbWVvdXRNYXAgKSB7XHJcblx0XHRcdHdpbmRvdy5iYXNpY0NoYXJ0VGltZW91dE1hcCA9IHt9O1xyXG5cdFx0XHR3aW5kb3cuYmFzaWNDaGFydFRpbWVvdXRNYXBbY2hhcnRJZF0gPSBudWxsO1xyXG5cdFx0fSBlbHNlIGlmICggd2luZG93LmJhc2ljQ2hhcnRUaW1lb3V0TWFwW2NoYXJ0SWRdICkge1xyXG5cdFx0XHRjbGVhclRpbWVvdXQod2luZG93LmJhc2ljQ2hhcnRUaW1lb3V0TWFwW2NoYXJ0SWRdKTtcclxuXHRcdH1cclxuICAgICAgICBcclxuICAgICAgICB0aGlzLmxpbmVDaGFydCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIC8vIO2VhOyImCDtla3rqqlcclxuICAgICAgICBjb25zdCB7IGNsYXNzTmFtZSwgaGVpZ2h0IH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2IGlkPXt0aGlzLmlkfSBjbGFzc05hbWU9e2NsYXNzTmFtZX0gc3R5bGU9e3toZWlnaHQ6aGVpZ2h0fX0+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNoYXJ0LWxvYWRpbmdcIj48aSBjbGFzc05hbWU9XCJmYSBmYS1yZWZyZXNoIGZhLXNwaW4gZmEtbGcgZmEtZndcIiAvPjwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApXHJcbiAgICB9XHJcbn1cclxuXHJcbkxpbmVDaGFydC5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XHJcbkxpbmVDaGFydC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMaW5lQ2hhcnQ7XHJcbiIsIi8qKlxyXG4gKiBQaWVDaGFydCBjb21wb25lbnRcclxuICpcclxuICogdmVyc2lvbiA8dHQ+JCBWZXJzaW9uOiAxLjAgJDwvdHQ+IGRhdGU6MjAxNi8wMy8wM1xyXG4gKiBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpranVod2FAbmtpYS5jby5rclwiPmtqdWh3YTwvYT5cclxuICpcclxuICogZXhhbXBsZTpcclxuICogPFB1Zi5QaWVDaGFydCBvcHRpb25zPXtvcHRpb25zfSAvPlxyXG4gKlxyXG4gKiBIaWdoY2hhcnRzIOudvOydtOu4jOufrOumrOyXkCDsooXsho3soIHsnbTri6QuXHJcbiAqIFxyXG4gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IFV0aWwgZnJvbSAnLi4vLi4vc2VydmljZXMvVXRpbCc7XHJcbmltcG9ydCBEZWZhdWx0Q2hhcnRPcHRpb24gZnJvbSAnLi9EZWZhdWx0Q2hhcnRPcHRpb24nO1xyXG5cclxuY29uc3QgcHJvcFR5cGVzID0ge1xyXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBvcHRpb25zOiBQcm9wVHlwZXMub2JqZWN0LFxyXG4gICAgYXV0b0luaXQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgXHJcbiAgICBjb2xvcnM6IFByb3BUeXBlcy5hcnJheSxcclxuICAgIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgaGVpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLFxyXG5cclxuICAgIHNlcmllczogUHJvcFR5cGVzLmFycmF5LFxyXG5cclxuICAgIGxpdmVJbnRlcnZhbDogUHJvcFR5cGVzLm51bWJlcixcclxuXHJcbiAgICBvbkxvYWQ6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgLy8g7Iuk7Iuc6rCEIOuNsOydtO2DgCDstpTqsIAgRnVuY1xyXG4gICAgb25MaXZlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuLy8g7YG0656Y7Iqk6rCAIOyDneyEseuQoCDrlYwg7ZWc67KIIO2YuOy2nOuQmOqzoCDsupDsi5zrkJzri6QuXHJcbi8vIOu2gOuqqCDsu7Ttj6zrhIztirjsl5DshJwgcHJvcOydtCDrhJjslrTsmKTsp4Ag7JWK7J2AIOqyveyasCAoaW4g7Jew7IKw7J6Q66GcIO2ZleyduCkg66ek7ZWR7J2YIOqwkuydtCB0aGlzLnByb3Bz7JeQIOyEpOygleuQnOuLpC5cclxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xyXG4gICAgd2lkdGg6IG51bGwsXHJcbiAgICBoZWlnaHQ6IG51bGwsXHJcbiAgICBsaXZlSW50ZXJ2YWw6IDEwMDAsXHJcbiAgICBhdXRvSW5pdDogdHJ1ZVxyXG59O1xyXG5cclxuY2xhc3MgUGllQ2hhcnQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcblxyXG4gICAgICAgIGxldCBpZCA9IHByb3BzLmlkO1xyXG4gICAgICAgIGlmKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWQgPSBVdGlsLmdldFVVSUQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgICAgICB0aGlzLnBpZUNoYXJ0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gTWFudWFsbHkgYmluZCB0aGlzIG1ldGhvZCB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlLi4uXHJcbiAgICAgICAgLy90aGlzLm9uTG9hZCA9IHRoaXMub25Mb2FkLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgaWYoIHRoaXMucHJvcHMuYXV0b0luaXQgKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGllQ2hhcnQgPSBuZXcgSGlnaGNoYXJ0cy5DaGFydCh0aGlzLm9wdGlvbnMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xyXG4gICAgICAgIC8vIHByb3BzIOqwkuydtCDrs4Dqsr0g65CgIOuVjOuniOuLpCDtmLjstpztlZzri6QuXHJcbiAgICAgICAgLy8g7IiY64+ZIOyDneyEseycvOuhnCDshKTsoJXrkJjslrQg7J6I7J2E65WM7JeQ66eMIOywqO2KuOulvCDsg53shLHtlbQg7KSA64ukLlxyXG4gICAgICAgIC8vIHNlcmllc+yXkCDqsJLsnbQg7J6I7Jy866m07IScIOywqO2KuOqwgCDsg53shLHrkJjslrQg7J6I7KeAIOyViuydhOuVjOyXkC4uLlxyXG4gICAgICAgIGlmKCAhdGhpcy5wcm9wcy5hdXRvSW5pdCAmJiB0aGlzLnBpZUNoYXJ0ID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGllQ2hhcnQgPSBuZXcgSGlnaGNoYXJ0cy5DaGFydCh0aGlzLm9wdGlvbnMoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIHByaXZhdGVcclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgb3B0aW9ucygpIHtcclxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGNvbG9ycywgc2VyaWVzLCBvbkxvYWQgfSA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgIHZhciBvcHRpb25zID0gRGVmYXVsdENoYXJ0T3B0aW9uLmdldERlZmF1bHRDaGFydE9wdGlvbigpO1xyXG5cclxuICAgICAgICAkLmV4dGVuZCh0cnVlLCBvcHRpb25zLCB7XHJcbiAgICAgICAgICAgIGNoYXJ0OiB7IFxyXG4gICAgICAgICAgICAgICAgdHlwZSA6ICdwaWUnLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgICAgICByZW5kZXJUbzogdGhpcy5pZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZiBjb2xvcnMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIG9wdGlvbnMsIHsgY29sb3JzOiBjb2xvcnMgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0eXBlb2Ygc2VyaWVzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBvcHRpb25zLCB7IHNlcmllczogc2VyaWVzIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodHlwZW9mIG9uTG9hZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgb3B0aW9ucywgeyBcclxuICAgICAgICAgICAgICAgIGNoYXJ0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWQ6IG9uTG9hZFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vcHRpb25zICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBvcHRpb25zLCB0aGlzLnByb3BzLm9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICBjaGFydElkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlkO1xyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZShzZXJpZXMpIHtcclxuICAgICAgICAvLyBIaWdoY2hhcnRzIDUuMC4wXHJcbiAgICAgICAgdGhpcy5waWVDaGFydC51cGRhdGUoe1xyXG4gICAgICAgICAgICBzZXJpZXM6IHNlcmllc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZmxvdygpIHtcclxuICAgICAgICB0aGlzLnBpZUNoYXJ0LnJlZmxvdygpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXJ0TGl2ZSgpIHtcclxuICAgICAgICBjb25zdCB7IG9uTGl2ZSwgbGl2ZUludGVydmFsIH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICBpZih0eXBlb2Ygb25MaXZlICE9PSAndW5kZWZpbmVkJykge1xyXG5cclxuICAgICAgICAgICAgbGV0IHBpZUNoYXJ0ID0gdGhpcy5waWVDaGFydDtcclxuICAgICAgICAgICAgbGV0IGlkID0gdGhpcy5pZDtcclxuICAgICAgICAgICAgKGZ1bmN0aW9uIGFwcGVuZERhdGEoKSB7XHJcbiAgICAgICAgICAgICAgICBvbkxpdmUocGllQ2hhcnQpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmJhc2ljQ2hhcnRUaW1lb3V0TWFwW2lkXSA9IHNldFRpbWVvdXQoYXBwZW5kRGF0YSwgbGl2ZUludGVydmFsKTtcclxuICAgICAgICAgICAgfSkuYmluZCh0aGlzKSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdG9wTGl2ZSgpIHtcclxuICAgICAgICBjb25zdCB7IG9uTGl2ZSB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBcclxuICAgICAgICBpZih0eXBlb2Ygb25MaXZlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZiAoIHdpbmRvdy5iYXNpY0NoYXJ0VGltZW91dE1hcFt0aGlzLmlkXSApIHtcclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh3aW5kb3cuYmFzaWNDaGFydFRpbWVvdXRNYXBbdGhpcy5pZF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcclxuICAgICAgICAvLyBUaW1lciDqsJ3ssrQg6rO16rCE7J20IOq1rOyEseuQmOyngCDslYrslZjri6TrqbQg7LSI6riw7ZmU66W8IOyLnOy8nOykgOuLpC5cclxuICAgICAgICAvLyBjeWdudXPsl5DshJwg7IKs7JqpIOykkeydtOq4sCDrlYzrrLjsl5Ag7YGs6rKMIOusuOygnCDrkKDqsbQg7JeG7J2EIOuTryDtlZjri6QuXHJcbiAgICAgICAgaWYgKCB3aW5kb3cuYmFzaWNDaGFydFRpbWVvdXRNYXAgPT0gdW5kZWZpbmVkICkge1xyXG4gICAgICAgICAgICB3aW5kb3cuYmFzaWNDaGFydFRpbWVvdXRNYXAgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8g7LCo7Yq4IOyCreygnOyLnCDrqZTrqqjrpqzsl5Ag7Jis65287JmAIOyeiOuKlCBIaWdoY2hhcnRzIOqwneyytOyZgCBUaW1lcuulvCDsp4DsmrTri6QuXHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgICAgICBsZXQgY2hhcnRJZCA9IHRoaXMuaWQ7XHJcbiAgICAgICAgJC5lYWNoKEhpZ2hjaGFydHMuY2hhcnRzLCBmdW5jdGlvbihpLCBjaGFydCkge1xyXG5cdFx0XHRpZiAoIGNoYXJ0ICYmIChjaGFydElkID09IGNoYXJ0LmNvbnRhaW5lci5wYXJlbnROb2RlLmlkKSkge1xyXG5cdFx0XHRcdGNoYXJ0LmRlc3Ryb3koKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG4gICAgICAgIGlmICggIXdpbmRvdy5iYXNpY0NoYXJ0VGltZW91dE1hcCApIHtcclxuXHRcdFx0d2luZG93LmJhc2ljQ2hhcnRUaW1lb3V0TWFwID0ge307XHJcblx0XHRcdHdpbmRvdy5iYXNpY0NoYXJ0VGltZW91dE1hcFtjaGFydElkXSA9IG51bGw7XHJcblx0XHR9IGVsc2UgaWYgKCB3aW5kb3cuYmFzaWNDaGFydFRpbWVvdXRNYXBbY2hhcnRJZF0gKSB7XHJcblx0XHRcdGNsZWFyVGltZW91dCh3aW5kb3cuYmFzaWNDaGFydFRpbWVvdXRNYXBbY2hhcnRJZF0pO1xyXG5cdFx0fVxyXG5cclxuICAgICAgICB0aGlzLnBpZUNoYXJ0ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgLy8g7ZWE7IiYIO2VreuqqVxyXG4gICAgICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBoZWlnaHQgfSA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgaWQ9e3RoaXMuaWR9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBzdHlsZT17e2hlaWdodDpoZWlnaHR9fT5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2hhcnQtbG9hZGluZ1wiPjxpIGNsYXNzTmFtZT1cImZhIGZhLXJlZnJlc2ggZmEtc3BpbiBmYS1sZyBmYS1md1wiIC8+PC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcblBpZUNoYXJ0LnByb3BUeXBlcyA9IHByb3BUeXBlcztcclxuUGllQ2hhcnQuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUGllQ2hhcnQ7XHJcbiIsIi8qKlxyXG4gKiBTY2F0dGVyQ2hhcnQgY29tcG9uZW50XHJcbiAqXHJcbiAqIHZlcnNpb24gPHR0PiQgVmVyc2lvbjogMS4wICQ8L3R0PiBkYXRlOjIwMTYvMDMvMDNcclxuICogYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86a2p1aHdhQG5raWEuY28ua3JcIj5ranVod2E8L2E+XHJcbiAqXHJcbiAqIGV4YW1wbGU6XHJcbiAqIDxQdWYuU2NhdHRlckNoYXJ0IG9wdGlvbnM9e29wdGlvbnN9IC8+XHJcbiAqXHJcbiAqIEhpZ2hjaGFydHMg65287J2067iM65+s66as7JeQIOyiheyGjeyggeydtOuLpC5cclxuICogXHJcbiAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQgVXRpbCBmcm9tICcuLi8uLi9zZXJ2aWNlcy9VdGlsJztcclxuaW1wb3J0IERlZmF1bHRDaGFydE9wdGlvbiBmcm9tICcuL0RlZmF1bHRDaGFydE9wdGlvbic7XHJcbmltcG9ydCBIaWdoY2hhcnRzT3B0aW9uIGZyb20gJy4vSGlnaGNoYXJ0c09wdGlvbic7XHJcblxyXG5jb25zdCBwcm9wVHlwZXMgPSB7XHJcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3QsXHJcbiAgICBhdXRvSW5pdDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBcclxuICAgIGNvbG9yczogUHJvcFR5cGVzLmFycmF5LFxyXG4gICAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICBoZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICB1c2VVVEM6IFByb3BUeXBlcy5ib29sLFxyXG5cclxuICAgIHNlcmllczogUHJvcFR5cGVzLmFycmF5LFxyXG4gICAgdGlja0ludGVydmFsOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgdGlja0NvdW50OiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgbGl2ZUludGVydmFsOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgdW5pdHM6IFByb3BUeXBlcy5zdHJpbmcsXHJcblxyXG4gICAgb25Mb2FkOiBQcm9wVHlwZXMuZnVuYyxcclxuICAgIC8vIOyLpOyLnOqwhCDrjbDsnbTtg4Ag7LaU6rCAIEZ1bmNcclxuICAgIG9uTGl2ZTogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICAvLyBUb29sdGlwXHJcbiAgICB0b29sdGlwRm9ybWF0dGVyOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuLy8g7YG0656Y7Iqk6rCAIOyDneyEseuQoCDrlYwg7ZWc67KIIO2YuOy2nOuQmOqzoCDsupDsi5zrkJzri6QuXHJcbi8vIOu2gOuqqCDsu7Ttj6zrhIztirjsl5DshJwgcHJvcOydtCDrhJjslrTsmKTsp4Ag7JWK7J2AIOqyveyasCAoaW4g7Jew7IKw7J6Q66GcIO2ZleyduCkg66ek7ZWR7J2YIOqwkuydtCB0aGlzLnByb3Bz7JeQIOyEpOygleuQnOuLpC5cclxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xyXG4gICAgd2lkdGg6IG51bGwsXHJcbiAgICBoZWlnaHQ6IG51bGwsXHJcbiAgICB1c2VVVEM6IGZhbHNlLFxyXG4gICAgdGlja0NvdW50OiA1LFxyXG4gICAgdGlja0ludGVydmFsOiAxMDAwLFxyXG4gICAgbGl2ZUludGVydmFsOiAxMDAwLFxyXG4gICAgYXV0b0luaXQ6IHRydWVcclxufTtcclxuXHJcbmNsYXNzIFNjYXR0ZXJDaGFydCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgbGV0IGlkID0gcHJvcHMuaWQ7XHJcbiAgICAgICAgaWYodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZCA9IFV0aWwuZ2V0VVVJRCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuc2NhdHRlckNoYXJ0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gTWFudWFsbHkgYmluZCB0aGlzIG1ldGhvZCB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlLi4uXHJcbiAgICAgICAgLy90aGlzLm9uTG9hZCA9IHRoaXMub25Mb2FkLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgLy8gR2xvYmFsIG9wdGlvbnNcclxuICAgICAgICBIaWdoY2hhcnRzT3B0aW9uLnNldFVzZVVUQyh0aGlzLnByb3BzLnVzZVVUQyk7XHJcblxyXG4gICAgICAgIGlmKCB0aGlzLnByb3BzLmF1dG9Jbml0ICkge1xyXG4gICAgICAgICAgICB0aGlzLnNjYXR0ZXJDaGFydCA9IG5ldyBIaWdoY2hhcnRzLkNoYXJ0KHRoaXMub3B0aW9ucygpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XHJcbiAgICAgICAgLy8gcHJvcHMg6rCS7J20IOuzgOqyvSDrkKAg65WM66eI64ukIO2YuOy2nO2VnOuLpC5cclxuICAgICAgICAvLyDsiJjrj5kg7IOd7ISx7Jy866GcIOyEpOygleuQmOyWtCDsnojsnYTrlYzsl5Drp4wg7LCo7Yq466W8IOyDneyEse2VtCDspIDri6QuXHJcbiAgICAgICAgLy8gc2VyaWVz7JeQIOqwkuydtCDsnojsnLzrqbTshJwg7LCo7Yq46rCAIOyDneyEseuQmOyWtCDsnojsp4Ag7JWK7J2E65WM7JeQLi4uXHJcbiAgICAgICAgaWYoICF0aGlzLnByb3BzLmF1dG9Jbml0ICYmIHRoaXMuc2NhdHRlckNoYXJ0ID09IG51bGwgKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhdHRlckNoYXJ0ID0gbmV3IEhpZ2hjaGFydHMuQ2hhcnQodGhpcy5vcHRpb25zKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBwcml2YXRlXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIG9wdGlvbnMoKSB7XHJcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBjb2xvcnMsIHNlcmllcywgb25Mb2FkLCB0aWNrSW50ZXJ2YWwsIHRpY2tDb3VudCwgdW5pdHMsIHRvb2x0aXBGb3JtYXR0ZXIgfSA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgIHZhciBvcHRpb25zID0gRGVmYXVsdENoYXJ0T3B0aW9uLmdldFNjYXR0ZXJDaGFydE9wdGlvbih0aWNrSW50ZXJ2YWwsdGlja0NvdW50KTtcclxuXHJcbiAgICAgICAgJC5leHRlbmQodHJ1ZSwgb3B0aW9ucywge1xyXG4gICAgICAgICAgICBjaGFydDogeyBcclxuICAgICAgICAgICAgICAgIHR5cGUgOiAnc2NhdHRlcicsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgICAgIHJlbmRlclRvOiB0aGlzLmlkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYodHlwZW9mIGNvbG9ycyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgb3B0aW9ucywgeyBjb2xvcnM6IGNvbG9ycyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZiBzZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIG9wdGlvbnMsIHsgc2VyaWVzOiBzZXJpZXMgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0eXBlb2Ygb25Mb2FkICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBvcHRpb25zLCB7IFxyXG4gICAgICAgICAgICAgICAgY2hhcnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudHM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZDogb25Mb2FkXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZiB1bml0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgb3B0aW9ucywge1xyXG4gICAgICAgICAgICAgICAgeUF4aXM6IHtcclxuICAgICAgICAgICAgICAgICAgICBsYWJlbHM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWZhdWx0Q2hhcnRPcHRpb24uY29udmVydFlBaXhVbml0KHVuaXRzLCB0aGlzLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0eXBlb2YgdG9vbHRpcEZvcm1hdHRlciAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgb3B0aW9ucywge1xyXG4gICAgICAgICAgICAgICAgdG9vbHRpcDoge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogdG9vbHRpcEZvcm1hdHRlclxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9wdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIG9wdGlvbnMsIHRoaXMucHJvcHMub3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIGNoYXJ0SWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlKHNlcmllcykge1xyXG4gICAgICAgIC8vIEhpZ2hjaGFydHMgNS4wLjBcclxuICAgICAgICB0aGlzLnNjYXR0ZXJDaGFydC51cGRhdGUoe1xyXG4gICAgICAgICAgICBzZXJpZXM6IHNlcmllc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZmxvdygpIHtcclxuICAgICAgICB0aGlzLnNjYXR0ZXJDaGFydC5yZWZsb3coKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGFydExpdmUoKSB7XHJcbiAgICAgICAgY29uc3QgeyBvbkxpdmUsIGxpdmVJbnRlcnZhbCB9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICAgICAgaWYodHlwZW9mIG9uTGl2ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHJcbiAgICAgICAgICAgIGxldCBzY2F0dGVyQ2hhcnQgPSB0aGlzLnNjYXR0ZXJDaGFydDtcclxuICAgICAgICAgICAgbGV0IGlkID0gdGhpcy5pZDtcclxuICAgICAgICAgICAgKGZ1bmN0aW9uIGFwcGVuZERhdGEoKSB7XHJcbiAgICAgICAgICAgICAgICBvbkxpdmUoc2NhdHRlckNoYXJ0KTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5iYXNpY0NoYXJ0VGltZW91dE1hcFtpZF0gPSBzZXRUaW1lb3V0KGFwcGVuZERhdGEsIGxpdmVJbnRlcnZhbCk7XHJcbiAgICAgICAgICAgIH0pLmJpbmQodGhpcykoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3RvcExpdmUoKSB7XHJcbiAgICAgICAgY29uc3QgeyBvbkxpdmUgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodHlwZW9mIG9uTGl2ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWYgKCB3aW5kb3cuYmFzaWNDaGFydFRpbWVvdXRNYXBbdGhpcy5pZF0gKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQod2luZG93LmJhc2ljQ2hhcnRUaW1lb3V0TWFwW3RoaXMuaWRdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XHJcbiAgICAgICAgLy8gVGltZXIg6rCd7LK0IOqzteqwhOydtCDqtazshLHrkJjsp4Ag7JWK7JWY64uk66m0IOy0iOq4sO2ZlOulvCDsi5zsvJzspIDri6QuXHJcbiAgICAgICAgLy8gY3lnbnVz7JeQ7IScIOyCrOyaqSDspJHsnbTquLAg65WM66y47JeQIO2BrOqyjCDrrLjsoJwg65Cg6rG0IOyXhuydhCDrk68g7ZWY64ukLlxyXG4gICAgICAgIGlmICggd2luZG93LmJhc2ljQ2hhcnRUaW1lb3V0TWFwID09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgd2luZG93LmJhc2ljQ2hhcnRUaW1lb3V0TWFwID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIOywqO2KuCDsgq3soJzsi5wg66mU66qo66as7JeQIOyYrOudvOyZgCDsnojripQgSGlnaGNoYXJ0cyDqsJ3ssrTsmYAgVGltZXLrpbwg7KeA7Jq064ukLlxyXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XHJcbiAgICAgICAgbGV0IGNoYXJ0SWQgPSB0aGlzLmlkO1xyXG4gICAgICAgICQuZWFjaChIaWdoY2hhcnRzLmNoYXJ0cywgZnVuY3Rpb24oaSwgY2hhcnQpIHtcclxuXHRcdFx0aWYgKCBjaGFydCAmJiAoY2hhcnRJZCA9PSBjaGFydC5jb250YWluZXIucGFyZW50Tm9kZS5pZCkpIHtcclxuXHRcdFx0XHRjaGFydC5kZXN0cm95KCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuICAgICAgICBpZiAoICF3aW5kb3cuYmFzaWNDaGFydFRpbWVvdXRNYXAgKSB7XHJcblx0XHRcdHdpbmRvdy5iYXNpY0NoYXJ0VGltZW91dE1hcCA9IHt9O1xyXG5cdFx0XHR3aW5kb3cuYmFzaWNDaGFydFRpbWVvdXRNYXBbY2hhcnRJZF0gPSBudWxsO1xyXG5cdFx0fSBlbHNlIGlmICggd2luZG93LmJhc2ljQ2hhcnRUaW1lb3V0TWFwW2NoYXJ0SWRdICkge1xyXG5cdFx0XHRjbGVhclRpbWVvdXQod2luZG93LmJhc2ljQ2hhcnRUaW1lb3V0TWFwW2NoYXJ0SWRdKTtcclxuXHRcdH1cclxuXHJcbiAgICAgICAgdGhpcy5zY2F0dGVyQ2hhcnQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICAvLyDtlYTsiJgg7ZWt66qpXHJcbiAgICAgICAgY29uc3QgeyBjbGFzc05hbWUsIGhlaWdodCB9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBpZD17dGhpcy5pZH0gY2xhc3NOYW1lPXtjbGFzc05hbWV9IHN0eWxlPXt7aGVpZ2h0OmhlaWdodH19PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGFydC1sb2FkaW5nXCI+PGkgY2xhc3NOYW1lPVwiZmEgZmEtcmVmcmVzaCBmYS1zcGluIGZhLWxnIGZhLWZ3XCIgLz48L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuU2NhdHRlckNoYXJ0LnByb3BUeXBlcyA9IHByb3BUeXBlcztcclxuU2NhdHRlckNoYXJ0LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNjYXR0ZXJDaGFydDsiLCIvKipcclxuICogQWxlcnQgY29tcG9uZW50XHJcbiAqXHJcbiAqIHZlcnNpb24gPHR0PiQgVmVyc2lvbjogMS4wICQ8L3R0PiBkYXRlOjIwMTYvMDMvMjRcclxuICogYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86aHJhaG5AbmtpYS5jby5rclwiPkFobiBIeXVuZy1SbzwvYT5cclxuICpcclxuICogZXhhbXBsZTpcclxuICogPFB1bS5BbGVydCByZWY9XCJhbGVydFwiIHRpdGxlPVwi7YOA7J207YuAXCIgbWVzc2FnZT1cIuuplOyLnOyngFwiIG9uT2s9e3RoaXMub25Pa30gLz5cclxuICogPFB1bS5BbGVydCByZWY9XCJjb25maXJtXCIgdHlwZT1cImNvbmZpcm1cIiB0aXRsZT1cIu2DgOydtO2LgFwiIG1lc3NhZ2U9XCLrqZTsi5zsp4BcIiBvbk9rPXt0aGlzLm9uQ29uZmlybX0gb25DYW5jZWw9e3RoaXMub25DYW5jZWx9Lz5cclxuICpcclxuICogYm9vdHN0cmFwIGNvbXBvbmVudFxyXG4gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IFV0aWwgZnJvbSAnLi4vc2VydmljZXMvVXRpbCc7XHJcblxyXG5jb25zdCBwcm9wVHlwZXMgPSB7XHJcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIHR5cGU6IFByb3BUeXBlcy5zdHJpbmcsICAgICAgICAgICAgIC8vIG51bGwvY29uZmlybSAoZGVmYXVsdDogbnVsbClcclxuICAgIHRpdGxlOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgdGl0bGVJY29uQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgbWVzc2FnZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIG9rTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBjYW5jZWxMYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIG9rQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgY2FuY2VsQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgb25PazogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICBvbkNhbmNlbDogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICB3aWR0aDogUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLnN0cmluZyxcclxuICAgICAgICBQcm9wVHlwZXMubnVtYmVyXHJcbiAgICBdKVxyXG59O1xyXG5cclxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xyXG4gICAgdGl0bGU6ICdUaXRsZScsIFxyXG4gICAgb2tMYWJlbDogJHBzX2xvY2FsZS5jb25maXJtLCBcclxuICAgIGNhbmNlbExhYmVsOiAkcHNfbG9jYWxlLmNhbmNlbFxyXG59O1xyXG5cclxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIEFsZXJ0LiAqL1xyXG5jbGFzcyBBbGVydCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgdGl0bGU6IHByb3BzLnRpdGxlLCBcclxuICAgICAgICAgICAgbWVzc2FnZTogcHJvcHMubWVzc2FnZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIE9wZXJhdGlvbnMgdXN1YWxseSBjYXJyaWVkIG91dCBpbiBjb21wb25lbnRXaWxsTW91bnQgZ28gaGVyZVxyXG4gICAgICAgIGxldCBpZCA9IHByb3BzLmlkO1xyXG4gICAgICAgIGlmKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWQgPSBVdGlsLmdldFVVSUQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHJcbiAgICAgICAgLy8gTWFudWFsbHkgYmluZCB0aGlzIG1ldGhvZCB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlLi4uXHJcbiAgICAgICAgdGhpcy5vbk9rID0gdGhpcy5vbk9rLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbkNhbmNlbCA9IHRoaXMub25DYW5jZWwuYmluZCh0aGlzKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcclxuICAgICAgICAvLyDsu7Ttj6zrhIztirjqsIAg7IOI66Gc7Jq0IHByb3Bz66W8IOuwm+ydhCDrlYwg7Zi47LacKOy1nOy0iCDroIzrjZTrp4Eg7Iuc7JeQ64qUIO2YuOy2nOuQmOyngCDslYrsnYwpXHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IHRpdGxlOiBuZXh0UHJvcHMudGl0bGUsIG1lc3NhZ2U6IG5leHRQcm9wcy5tZXNzYWdlIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGV2ZW50c1xyXG4gICAgb25PayhldmVudCkge1xyXG4gICAgICAgIC8vIGN1c3RvbSBldmVudCBlbWl0IOyXkCDrjIDtlbTshJwg7Jew6rWsIO2VhOyalFxyXG4gICAgICAgIHRoaXMuaGlkZSgpO1xyXG5cclxuICAgICAgICAvLyBva0Z1bmNcclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5va0Z1bmMgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5va0Z1bmMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG9uT2tcclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbk9rID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25PaygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkNhbmNlbChldmVudCkge1xyXG4gICAgICAgIC8vIGN1c3RvbSBldmVudCBlbWl0IOyXkCDrjIDtlbTshJwg7Jew6rWsIO2VhOyalFxyXG4gICAgICAgIHRoaXMuaGlkZSgpO1xyXG5cclxuICAgICAgICAvLyBjYW5jZWxGdW5jXHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMuY2FuY2VsRnVuYyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aGlzLmNhbmNlbEZ1bmMoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIG9uQ2FuY2VsXHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMub25DYW5jZWwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNhbmNlbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gbWV0aG9kc1xyXG4gICAgc2hvdyhva0Z1bmMsIGNhbmNlbEZ1bmMpIHtcclxuICAgICAgICB2YXIgYWxlcnQgPSAkKCcjJyt0aGlzLmlkKTtcclxuICAgICAgICBhbGVydC5tb2RhbCgnc2hvdycpO1xyXG5cclxuICAgICAgICB0aGlzLm9rRnVuYyA9IG9rRnVuYztcclxuICAgICAgICB0aGlzLmNhbmNlbEZ1bmMgPSBjYW5jZWxGdW5jO1xyXG4gICAgfVxyXG5cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgICAgdmFyIGFsZXJ0ID0gJCgnIycrdGhpcy5pZCk7XHJcbiAgICAgICAgYWxlcnQubW9kYWwoJ2hpZGUnKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICBpZih0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7bWVzc2FnZTogbWVzc2FnZX0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIC8vIO2VhOyImCDtla3rqqlcclxuICAgICAgICBjb25zdCB7Y2xhc3NOYW1lLCB0eXBlLCBva0xhYmVsLCBjYW5jZWxMYWJlbCwgb2tDbGFzc05hbWUsIGNhbmNlbENsYXNzTmFtZSwgdGl0bGVJY29uQ2xhc3NOYW1lLCB3aWR0aH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICB2YXIgY2FuY2VsQnV0dG9uO1xyXG4gICAgICAgIGlmKHR5cGUgPT09ICdjb25maXJtJykge1xyXG4gICAgICAgICAgICBjYW5jZWxCdXR0b24gPSA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ2J0bicsICdidG4tY2FuY2VsJywgY2FuY2VsQ2xhc3NOYW1lKX0gb25DbGljaz17dGhpcy5vbkNhbmNlbH0gZGF0YS1kaXNtaXNzPVwibW9kYWxcIj57Y2FuY2VsTGFiZWx9PC9idXR0b24+O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBpZD17dGhpcy5pZH0gY2xhc3NOYW1lPXtjbGFzc05hbWVzKCdtb2RhbCcsICdtb2RhbC1hbGVydCcsIGNsYXNzTmFtZSl9IHJvbGU9XCJkaWFsb2dcIiBhcmlhLWxhYmVsbGVkYnk9XCJcIiBhcmlhLWhpZGRlbj1cInRydWVcIiBkYXRhLWJhY2tkcm9wPVwic3RhdGljXCIgZGF0YS1rZXlib2FyZD1cImZhbHNlXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWRpYWxvZyBtb2RhbC1zbVwiIHN0eWxlPXt7d2lkdGg6IHdpZHRofX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbC1jb250ZW50XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW9kYWwtaGVhZGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ3RpdGxlLWljb24nLCB0aXRsZUljb25DbGFzc05hbWUpfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibW9kYWwtdGl0bGVcIj57dGhpcy5zdGF0ZS50aXRsZX08L3NwYW4+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWJvZHlcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnN0YXRlLm1lc3NhZ2V9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWZvb3RlclwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3NOYW1lPXtjbGFzc05hbWVzKCdidG4nLCAnYnRuLW9rJywgb2tDbGFzc05hbWUpfSBvbkNsaWNrPXt0aGlzLm9uT2t9Pntva0xhYmVsfTwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge2NhbmNlbEJ1dHRvbn1cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuQWxlcnQucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xyXG5BbGVydC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBbGVydDsiLCIvKipcclxuICogVGVtcCBjb21wb25lbnRcclxuICpcclxuICogdmVyc2lvbiA8dHQ+JCBWZXJzaW9uOiAxLjAgJDwvdHQ+IGRhdGU6MjAxNi8xMC8yOVxyXG4gKiBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpocmFobkBua2lhLmNvLmtyXCI+QWhuIEh5dW5nLVJvPC9hPlxyXG4gKlxyXG4gKiBleGFtcGxlOlxyXG4gKiA8UHVmLkJ1dHRvbiBvcHRpb25zPXtvcHRpb25zfSAvPlxyXG4gKlxyXG4gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IFV0aWwgZnJvbSAnLi4vc2VydmljZXMvVXRpbCc7XHJcblxyXG5jb25zdCBwcm9wVHlwZXMgPSB7XHJcbiAgICB0eXBlOiBQcm9wVHlwZXMub25lT2YoWydidXR0b24nLCdhJ10pLmlzUmVxdWlyZWQsXHJcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBpY29uQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgdG9vbHRpcDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIHRvb2x0aXBQb3NpdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsnYm90dG9tJywgJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2NlbnRlciddKSxcclxuICAgIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3NtJywgJ21kJywgJ2xnJ10pLFxyXG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgaGlkZGVuOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XHJcbiAgICB0eXBlOiAnYnV0dG9uJyxcclxuICAgIGNsYXNzTmFtZTogJ2J0bi1kZWZhdWx0JyxcclxuICAgIHRvb2x0aXBQb3NpdGlvbjogJ2JvdHRvbSdcclxufTtcclxuXHJcbi8qKiBDbGFzcyByZXByZXNlbnRpbmcgYSBCdXR0b24uICovXHJcbmNsYXNzIEJ1dHRvbiBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgLy8gTWFudWFsbHkgYmluZCB0aGlzIG1ldGhvZCB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlLi4uXHJcbiAgICAgICAgdGhpcy5vbkNsaWNrID0gdGhpcy5vbkNsaWNrLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xyXG4gICAgICAgIC8vIOy1nOy0iCDroIzrjZTrp4HsnbQg7J287Ja064KY6riwIOyngeyghCjtlZzrsogg7Zi47LacKVxyXG4gICAgICAgIGxldCBpZCA9IHRoaXMucHJvcHMuaWQ7XHJcbiAgICAgICAgaWYodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZCA9IFV0aWwuZ2V0VVVJRCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIC8vIOy1nOy0iCDroIzrjZTrp4HsnbQg7J287Ja064KcIOuLpOydjCjtlZzrsogg7Zi47LacKVxyXG4gICAgICAgIHRoaXMuJGJ1dHRvbiA9ICQoJyMnICsgdGhpcy5pZCk7XHJcblxyXG4gICAgICAgIC8vIHRvb2x0aXBcclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy50b29sdGlwICE9PSAndW5kZWZpbmVkJykge1xyXG5cclxuICAgICAgICAgICAgdGhpcy50b29sdGlwID0gdGhpcy4kYnV0dG9uLmtlbmRvVG9vbHRpcCh7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5wcm9wcy50b29sdGlwUG9zaXRpb25cclxuICAgICAgICAgICAgfSkuZGF0YSgna2VuZG9Ub29sdGlwJyk7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcclxuICAgIC8vICAgICAvLyDsg4jroZzsmrQgcHJvcHPrgpggc3RhdGXrpbwg67Cb7JWY7J2EIOuVjCDroIzrjZTrp4Eg7KCE7JeQIO2YuOy2nCjstZzstIgg66CM642U66eBIOyLnOyXkOuKlCDtmLjstpzrkJjsp4Ag7JWK7J2MKVxyXG4gICAgLy8gICAgIC8vIGZhbHNlIOuptCByZW5kZXIg7Zi47Lac7ZWY7KeAIOyViuydjChjb21wb25lbnRXaWxsVXBkYXRlIOyZgCBjb21wb25lbnREaWRVcGRhdGUg7Jet7IucIO2YuOy2nOuQmOyngCDslYrsnYwpXHJcbiAgICAvLyAgICAgcmV0dXJuIGZhbHNlOyAgICAvLyBkZWZhdWx0IHRydWVcclxuICAgIC8vIH1cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBldmVudHNcclxuICAgIG9uQ2xpY2soZSkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuJGJ1dHRvbi5hdHRyKCdkaXNhYmxlZCcpKTtcclxuICAgICAgICAvLyBJReyXkOyEnOuKlCBkaXNhYmxlZCDsho3shLHsnbQg7J6I7Ja064+EIO2BtOumreydtOuypO2KuOqwgCDrsJzsg53tlZzri6QuXHJcbiAgICAgICAgaWYodGhpcy4kYnV0dG9uLmF0dHIoJ2Rpc2FibGVkJykgPT09ICdkaXNhYmxlZCcpIHJldHVybjtcclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkNsaWNrICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2xpY2soZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIG1ldGhvZHNcclxuICAgIGVuYWJsZShpc0Jvb2wpIHtcclxuICAgICAgICBpZih0eXBlb2YgaXNCb29sID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgdGhpcy4kYnV0dG9uLmF0dHIoJ2Rpc2FibGVkJywgIWlzQm9vbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNob3coaXNCb29sKSB7XHJcbiAgICAgICAgaWYodHlwZW9mIGlzQm9vbCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIGlmKGlzQm9vbCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kYnV0dG9uLnNob3coKTtcclxuICAgICAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kYnV0dG9uLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiByZW5kZXIgZnVuY3Rpb25cclxuICAgICAqL1xyXG4gICAgcmVuZGVyQnV0dG9uKCkge1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlckEoKSB7XHJcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCB0b29sdGlwLCBzaXplLCBkaXNhYmxlZCB9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICAgICAgdmFyIG9wdGlvbmFsID0ge30sXHJcbiAgICAgICAgICAgIHNpemVDbGFzc05hbWU7XHJcbiAgICAgICAgaWYodHlwZW9mIHNpemUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHNpemVDbGFzc05hbWUgPSAnYnRuLScgKyBzaXplO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYoaGlkZGVuID09PSB0cnVlKSB7XHJcbiAgICAgICAgLy8gICAgIG9wdGlvbmFsLnN0eWxlID0geyBkaXNwbGF5OiAnbm9uZScgfTtcclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxhIGhyZWY9XCIjXCIgY2xhc3NOYW1lPXtjbGFzc05hbWVzKCdidG4nLCBjbGFzc05hbWUsIHNpemVDbGFzc05hbWUsIHsgZGlzYWJsZWQ6IHRoaXMuc3RhdGUuZGlzYWJsZWQgfSl9IHJvbGU9XCJidXR0b25cIlxyXG4gICAgICAgICAgICAgICAgey4uLm9wdGlvbmFsfT5cclxuICAgICAgICAgICAgICAgIHt0aGlzLnJlbmRlckljb24oKX1cclxuICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cclxuICAgICAgICAgICAgPC9hPlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVySWNvbigpIHtcclxuICAgICAgICBjb25zdCB7IGljb25DbGFzc05hbWUgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgaWYoaWNvbkNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICAgICAgPGkgY2xhc3NOYW1lPXtjbGFzc05hbWVzKCdmYScsIGljb25DbGFzc05hbWUpfT48L2k+XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICAvLyDtlYTsiJgg7ZWt66qpXHJcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCB0b29sdGlwLCBzaXplLCBkaXNhYmxlZCwgaGlkZGVuIH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBvcHRpb25hbCA9IHt9LFxyXG4gICAgICAgICAgICBzaXplQ2xhc3NOYW1lO1xyXG4gICAgICAgIGlmKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBzaXplQ2xhc3NOYW1lID0gJ2J0bi0nICsgc2l6ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRpc2FibGVkXHJcbiAgICAgICAgaWYodHlwZW9mIGRpc2FibGVkID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgb3B0aW9uYWwuZGlzYWJsZWQgPSBkaXNhYmxlZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGhpZGRlblxyXG4gICAgICAgIGlmKHR5cGVvZiBoaWRkZW4gPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICBpZihoaWRkZW4gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbmFsLnN0eWxlID0geyBkaXNwbGF5OiAnbm9uZScgfTtcclxuICAgICAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9uYWwuc3R5bGUgPSB7IGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHsnXFx1MDBBMCd9XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGJ1dHRvbiBpZD17dGhpcy5pZH0gdHlwZT1cImJ1dHRvblwiIGNsYXNzTmFtZT17Y2xhc3NOYW1lcygnYnRuJywgY2xhc3NOYW1lLCBzaXplQ2xhc3NOYW1lKX0gb25DbGljaz17dGhpcy5vbkNsaWNrfSBcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZT17dG9vbHRpcH1cclxuICAgICAgICAgICAgICAgICAgICB7Li4ub3B0aW9uYWx9PlxyXG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVySWNvbigpfVxyXG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5CdXR0b24ucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xyXG5CdXR0b24uZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uO1xyXG4iLCIvKipcclxuICogQnV0dG9uRHJvcGRvd24gY29tcG9uZW50XHJcbiAqXHJcbiAqIHZlcnNpb24gPHR0PiQgVmVyc2lvbjogMS4wICQ8L3R0PiBkYXRlOjIwMTYvMTAvMDdcclxuICogYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86aHJhaG5AbmtpYS5jby5rclwiPkFobiBIeXVuZy1SbzwvYT5cclxuICpcclxuICogZXhhbXBsZTpcclxuICogPFB1Zi5CdXR0b25Ecm9wZG93biBvcHRpb25zPXtvcHRpb25zfSAvPlxyXG4gKlxyXG4gKiBCb290c3RyYXAg65287J2067iM65+s66as7JeQIOyiheyGjeyggeydtOuLpC5cclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcbmltcG9ydCBVdGlsIGZyb20gJy4uL3NlcnZpY2VzL1V0aWwnO1xyXG5cclxuY29uc3QgcHJvcFR5cGVzID0ge1xyXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBsYWJlbDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGRyb3Bkb3duVGVtcGxhdGU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBzcGxpdDogUHJvcFR5cGVzLmJvb2xcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcclxuICAgIGNsYXNzTmFtZTogJ2J0biBidG4tZGVmYXVsdCcsIFxyXG4gICAgbGFiZWw6ICdidXR0b24nLCBcclxuICAgIHNwbGl0OiBmYWxzZVxyXG59O1xyXG5cclxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIEJ1dHRvbkRyb3Bkb3duLiAqL1xyXG5jbGFzcyBCdXR0b25Ecm9wZG93biBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgLy8gT3BlcmF0aW9ucyB1c3VhbGx5IGNhcnJpZWQgb3V0IGluIGNvbXBvbmVudFdpbGxNb3VudCBnbyBoZXJlXHJcbiAgICAgICAgbGV0IGlkID0gcHJvcHMuaWQ7XHJcbiAgICAgICAgaWYodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZCA9IFV0aWwuZ2V0VVVJRCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgcmVuZGVyQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICAvLyBjaGlsZHJlbiDsnbQg7KG07J6sIO2VmOyngCDslYrripTri6TrqbQg642w7J207YSw66W8IOuwm+yVhOyEnCBsaSDsg53shLHtlZjripQg6rKDIOunjOuTpOyWtOykjFxyXG4gICAgICAgIC8vIGxpIO2DnOq3uOyViOydmCBjb250ZW5064qUIHRlbXBsYXRlIO2Yle2DnOuhnCDrsJvslYTshJwg7LKY66asIChkZWZhdWx0IHRlbXBsYXRl7J2AIGEgdGFnKVxyXG4gICAgICAgIC8vIOqwgSDslYTsnbTthZwg7YG066at7IucIOydtOuypO2KuCDsspjrpqzrj4Qg7ZW07JW8IO2VqFxyXG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcclxuICAgIH1cclxuXHRcclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICAvLyDtlYTsiJgg7ZWt66qpXHJcbiAgICAgICAgY29uc3QgeyBjbGFzc05hbWUsIGxhYmVsLCBzcGxpdCB9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICAgICAgdmFyIGJ0biwgc3BsaXRCdG47XHJcbiAgICAgICAgaWYoc3BsaXQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgYnRuID0gKFxyXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3NOYW1lPXtjbGFzc05hbWVzKGNsYXNzTmFtZSl9PntsYWJlbH08L2J1dHRvbj5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgc3BsaXRCdG4gPSAoXHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoY2xhc3NOYW1lLCAnZHJvcGRvd24tdG9nZ2xlJyl9IGRhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIiBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiIGFyaWEtZXhwYW5kZWQ9XCJmYWxzZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImNhcmV0XCI+PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInNyLW9ubHlcIj5Ub2dnbGUgRHJvcGRvd248L3NwYW4+XHJcbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIGJ0biA9IChcclxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhjbGFzc05hbWUsICdkcm9wZG93bi10b2dnbGUnKX0gZGF0YS10b2dnbGU9XCJkcm9wZG93blwiIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCI+XHJcbiAgICAgICAgICAgICAgICAgICAge2xhYmVsfSA8c3BhbiBjbGFzc05hbWU9XCJjYXJldFwiPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBpZD17dGhpcy5pZH0gY2xhc3NOYW1lPVwiYnRuLWdyb3VwXCI+XHJcbiAgICAgICAgICAgICAgICB7YnRufVxyXG4gICAgICAgICAgICAgICAge3NwbGl0QnRufVxyXG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzTmFtZT1cImRyb3Bkb3duLW1lbnVcIj5cclxuICAgICAgICAgICAgICAgICAgICB7dGhpcy5yZW5kZXJDaGlsZHJlbigpfVxyXG4gICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuQnV0dG9uRHJvcGRvd24ucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xyXG5CdXR0b25Ecm9wZG93bi5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCdXR0b25Ecm9wZG93bjsiLCIvKipcclxuICogQ2hlY2tCb3ggY29tcG9uZW50XHJcbiAqXHJcbiAqIHZlcnNpb24gPHR0PiQgVmVyc2lvbjogMS4wICQ8L3R0PiBkYXRlOjIwMTYvMDMvMTRcclxuICogYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86aHJhaG5AbmtpYS5jby5rclwiPkFobiBIeXVuZy1SbzwvYT5cclxuICpcclxuICogZXhhbXBsZTpcclxuICogPFB1bS5DaGVja0JveCBuYW1lPVwibmFtZTFcIiB2YWx1ZT1cInZhbHVlMVwiIG9uQ2hhbmdlPXt0aGlzLm9uQ2hhbmdlfSBjaGVja2VkPXt0cnVlfT4g7LK07YGs67CV7IqkPC9QdW0uQ2hlY2tCb3g+XHJcbiAqXHJcbiAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQgVXRpbCBmcm9tICcuLi9zZXJ2aWNlcy9VdGlsJztcclxuXHJcbmNvbnN0IHByb3BUeXBlcyA9IHtcclxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgY2hlY2tlZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBkaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ2gnLCd2J10pLFxyXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XHJcbiAgICBkaXJlY3Rpb246ICd2J1xyXG59O1xyXG5cclxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIENoZWNrYm94LiAqL1xyXG5jbGFzcyBDaGVja2JveCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuX19zZXRTdGF0ZU9iamVjdChwcm9wcyk7XHJcblxyXG4gICAgICAgIC8vIE9wZXJhdGlvbnMgdXN1YWxseSBjYXJyaWVkIG91dCBpbiBjb21wb25lbnRXaWxsTW91bnQgZ28gaGVyZVxyXG4gICAgICAgIGxldCBpZCA9IHByb3BzLmlkO1xyXG4gICAgICAgIGlmKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWQgPSBVdGlsLmdldFVVSUQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHJcbiAgICAgICAgLy8gTWFudWFsbHkgYmluZCB0aGlzIG1ldGhvZCB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlLi4uXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAvLyDstZzstIgg66CM642U66eB7J20IOydvOyWtOuCnCDri6TsnYwo7ZWc67KIIO2YuOy2nClcclxuICAgICAgICB0aGlzLiRjaGVja2JveCA9ICQoJ2lucHV0OmNoZWNrYm94W25hbWU9XCInICsgdGhpcy5wcm9wcy5uYW1lICsgJ1wiXScpO1xyXG5cclxuICAgICAgICBpZih0aGlzLnByb3BzLmRpcmVjdGlvbiA9PT0gJ2gnKSB7XHJcbiAgICAgICAgICAgIGxldCAkZGl2ID0gJCgnIycrdGhpcy5pZCksXHJcbiAgICAgICAgICAgICAgICAkbGFiZWwgPSAkZGl2LmNoaWxkcmVuKCk7XHJcbiAgICAgICAgICAgICRsYWJlbC5hZGRDbGFzcygnY2hlY2tib3gtaW5saW5lJyk7XHJcbiAgICAgICAgICAgICRkaXYucmVwbGFjZVdpdGgoJGxhYmVsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX19zZXRWYWx1ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XHJcbiAgICAgICAgLy8g7Lu07Y+s64SM7Yq46rCAIOyDiOuhnOyatCBwcm9wc+ulvCDrsJvsnYQg65WMIO2YuOy2nCjstZzstIgg66CM642U66eBIOyLnOyXkOuKlCDtmLjstpzrkJjsp4Ag7JWK7J2MKVxyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy5fX3NldFN0YXRlT2JqZWN0KG5leHRQcm9wcykpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xyXG4gICAgICAgIC8vIOy7tO2PrOuEjO2KuOydmCDsl4XrjbDsnbTtirjqsIAgRE9N7JeQIOuwmOyYgeuQnCDsp4Htm4Tsl5Ag7Zi47LacKOy1nOy0iCDroIzrjZTrp4Eg7Iuc7JeQ64qUIO2YuOy2nOuQmOyngCDslYrsnYwpXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhwcmV2UHJvcHMpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2cocHJldlN0YXRlKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMuc3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX19zZXRWYWx1ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX19zZXRTdGF0ZU9iamVjdChwcm9wcykge1xyXG4gICAgICAgIC8vbGV0IHZhbHVlID0gcHJvcHMudmFsdWU7XHJcbiAgICAgICAgLy9pZih0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgLy8gICAgdmFsdWUgPSBudWxsO1xyXG4gICAgICAgIC8vfVxyXG5cclxuICAgICAgICBsZXQgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XHJcbiAgICAgICAgaWYodHlwZW9mIGNoZWNrZWQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGNoZWNrZWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8vdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICBjaGVja2VkOiBjaGVja2VkXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9fc2V0VmFsdWUoKSB7XHJcbiAgICAgICAgdmFyIGNoZWNrZWQgPSB0aGlzLnN0YXRlLmNoZWNrZWQ7LyosXHJcbiAgICAgICAgICAgICRjaGVja2JveCA9ICQoJ2lucHV0OmNoZWNrYm94W25hbWU9XCInICsgdGhpcy5wcm9wcy5uYW1lICsgJ1wiXScpOyovXHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMudmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8vIHRydWUvZmFsc2Ug7ISk7KCVXHJcbiAgICAgICAgICAgIHRoaXMuJGNoZWNrYm94LnZhbChjaGVja2VkKTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIGlmKGNoZWNrZWQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJGNoZWNrYm94LnZhbCh0aGlzLnByb3BzLnZhbHVlKTtcclxuICAgICAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kY2hlY2tib3gudmFsKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGV2ZW50c1xyXG4gICAgb25DaGFuZ2UoZSkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coZSk7XHJcbiAgICAgICAgdmFyIGNoZWNrZWQgPSAhdGhpcy5zdGF0ZS5jaGVja2VkO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coY2hlY2tlZCk7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7Y2hlY2tlZDogY2hlY2tlZH0pO1xyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uQ2hhbmdlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoZSwgY2hlY2tlZCwgdGhpcy4kY2hlY2tib3gudmFsKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgLy8g7ZWE7IiYIO2VreuqqVxyXG4gICAgICAgIGNvbnN0IHtjbGFzc05hbWUsIG5hbWUsIGNoaWxkcmVufSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjaGVja2JveFwiIGlkPXt0aGlzLmlkfT5cclxuICAgICAgICAgICAgICAgIDxsYWJlbD5cclxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2xhc3NOYW1lPXtjbGFzc05hbWV9IG5hbWU9e25hbWV9IGNoZWNrZWQ9e3RoaXMuc3RhdGUuY2hlY2tlZH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMub25DaGFuZ2V9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibGJsXCI+e2NoaWxkcmVufTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICB7Lyo8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9e3RoaXMucHJvcHMubmFtZX0gdmFsdWU9e3RoaXMuc3RhdGUudmFsdWV9PiovfVxyXG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuQ2hlY2tib3gucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xyXG5DaGVja2JveC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDaGVja2JveDsiLCIvKipcclxuICogRmllbGRzZXQgY29tcG9uZW50XHJcbiAqXHJcbiAqIHZlcnNpb24gPHR0PiQgVmVyc2lvbjogMS4wICQ8L3R0PiBkYXRlOjIwMTYvMDMvMzBcclxuICogYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86aHJhaG5AbmtpYS5jby5rclwiPkFobiBIeXVuZy1SbzwvYT5cclxuICpcclxuICogZXhhbXBsZTpcclxuICogPFB1bS5GaWVsZHNldCAvPlxyXG4gKlxyXG4gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IFV0aWwgZnJvbSAnLi4vc2VydmljZXMvVXRpbCc7XHJcblxyXG5jb25zdCBwcm9wVHlwZXMgPSB7XHJcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGxlZ2VuZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGV4cGFuZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBjb2xsYXBzaWJsZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBvblRvZ2dsZTogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICBvbkluaXQ6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XHJcbiAgICBsZWdlbmQ6ICdUaXRsZScsIFxyXG4gICAgY29sbGFwc2libGU6IHRydWUsIFxyXG4gICAgZXhwYW5kOiB0cnVlXHJcbn07XHJcblxyXG4vKiogQ2xhc3MgcmVwcmVzZW50aW5nIGEgRmllbGRzZXQuICovXHJcbmNsYXNzIEZpZWxkc2V0IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICBleHBhbmQ6IHByb3BzLmV4cGFuZFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIE9wZXJhdGlvbnMgdXN1YWxseSBjYXJyaWVkIG91dCBpbiBjb21wb25lbnRXaWxsTW91bnQgZ28gaGVyZVxyXG4gICAgICAgIGxldCBpZCA9IHByb3BzLmlkO1xyXG4gICAgICAgIGlmKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWQgPSBVdGlsLmdldFVVSUQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHJcbiAgICAgICAgLy8gTWFudWFsbHkgYmluZCB0aGlzIG1ldGhvZCB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlLi4uXHJcbiAgICAgICAgdGhpcy5vblRvZ2dsZSA9IHRoaXMub25Ub2dnbGUuYmluZCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgIC8vICAgICAvLyDstZzstIgg66CM642U66eB7J20IOydvOyWtOuCnCDri6TsnYwo7ZWc67KIIO2YuOy2nClcclxuICAgIC8vICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkluaXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIC8vICAgICAgICAgdmFyIGRhdGEgPSB7fTtcclxuICAgIC8vICAgICAgICAgZGF0YS5leHBhbmQgPSB0aGlzLnN0YXRlLmV4cGFuZDtcclxuICAgIC8vICAgICAgICAgdGhpcy5wcm9wcy5vbkluaXQoZGF0YSk7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XHJcbiAgICAgICAgLy8g7Lu07Y+s64SM7Yq46rCAIOyDiOuhnOyatCBwcm9wc+ulvCDrsJvsnYQg65WMIO2YuOy2nCjstZzstIgg66CM642U66eBIOyLnOyXkOuKlCDtmLjstpzrkJjsp4Ag7JWK7J2MKVxyXG4gICAgICAgIHRoaXMudG9nZ2xlKG5leHRQcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB0b2dnbGUocHJvcHMpIHtcclxuICAgICAgICBpZih0aGlzLnByb3BzLmNvbGxhcHNpYmxlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGlmKHR5cGVvZiBwcm9wcy5leHBhbmQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgZXhwYW5kOiBwcm9wcy5leHBhbmQgfSk7XHJcbiAgICAgICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBleHBhbmQ6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gZXZlbnRzXHJcbiAgICBvblRvZ2dsZShldmVudCkge1xyXG4gICAgICAgIHZhciBleHBhbmQgPSAhdGhpcy5zdGF0ZS5leHBhbmQ7XHJcbiAgICAgICAgdGhpcy50b2dnbGUoeyBleHBhbmQ6IGV4cGFuZCB9KTtcclxuXHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMub25Ub2dnbGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblRvZ2dsZShleHBhbmQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHRcclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICAvLyDtlYTsiJgg7ZWt66qpXHJcbiAgICAgICAgY29uc3Qge2NsYXNzTmFtZSwgbGVnZW5kLCBjb2xsYXBzaWJsZX0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICB2YXIgZGlzcGxheSwgY29sbGFwc2VkID0gZmFsc2U7XHJcbiAgICAgICAgaWYodGhpcy5zdGF0ZS5leHBhbmQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICBkaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICBpZihjb2xsYXBzaWJsZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29sbGFwc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGZpZWxkc2V0IGNsYXNzTmFtZT17Y2xhc3NOYW1lcygnZmllbGRzZXQnLCBjbGFzc05hbWUsIHtjb2xsYXBzaWJsZTogY29sbGFwc2libGUsIGNvbGxhcHNlZDogY29sbGFwc2VkfSl9PlxyXG4gICAgICAgICAgICAgICAgPGxlZ2VuZCBvbkNsaWNrPXt0aGlzLm9uVG9nZ2xlfSBuYW1lPXt0aGlzLmlkfT4ge2xlZ2VuZH08L2xlZ2VuZD5cclxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3tkaXNwbGF5OiBkaXNwbGF5fX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBpZD17dGhpcy5pZH0gPnt0aGlzLnByb3BzLmNoaWxkcmVufTwvZGl2PlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZmllbGRzZXQ+XHJcblxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbkZpZWxkc2V0LnByb3BUeXBlcyA9IHByb3BUeXBlcztcclxuRmllbGRzZXQuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRmllbGRzZXQ7IiwiLyoqXHJcbiAqIEZpbmVVcGxvYWRlciBjb21wb25lbnRcclxuICpcclxuICogdmVyc2lvbiA8dHQ+JCBWZXJzaW9uOiAxLjAgJDwvdHQ+IGRhdGU6MjAxNi8wOS8yN1xyXG4gKiBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpqeXRAbmtpYS5jby5rclwiPkp1bmcgWW91bmctVGFpPC9hPlxyXG4gKlxyXG4gKiBleGFtcGxlOlxyXG4gKiA8UHVmLkZpbmVVcGxvYWRlciBvcHRpb25zPXtvcHRpb25zfSAvPlxyXG4gKlxyXG4gKiBGaW5lVXBsb2FkZXIg65287J2067iM65+s66as7JeQIOyiheyGjeyggeydtOuLpC5cclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcbmltcG9ydCBVdGlsIGZyb20gJy4uL3NlcnZpY2VzL1V0aWwnO1xyXG5cclxuY29uc3QgcHJvcFR5cGVzID0ge1xyXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBob3N0OiBQcm9wVHlwZXMuc3RyaW5nLCAvLyDshJzrsoQg7KCV67O0KENyb3NzIEJyb3dzZXIgQWNjZXNzKVxyXG4gICAgc2Vzc2lvblVybDogUHJvcFR5cGVzLnN0cmluZywgICAvLyDsl4XroZzrk5zrkJwg7LSI6riwIO2MjOydvCBHZXQgVXJsXHJcbiAgICB1cGxvYWRVcmw6IFByb3BUeXBlcy5zdHJpbmcsICAgIC8vIO2MjOydvCDsl4XroZzrk5wgVVJMXHJcbiAgICBkZWxldGVVcmw6IFByb3BUeXBlcy5zdHJpbmcsICAgIC8vIO2MjOydvCDsgq3soJwgVVJMXHJcbiAgICBwYXJhbXM6IFByb3BUeXBlcy5vYmplY3QsICAgICAgIC8vIO2MjOydvCDsl4XroZzrk5wg7YyM652866+47YSwXHJcbiAgICBzZXNzaW9uUGFyYW1zOiBQcm9wVHlwZXMub2JqZWN0LCAgICAvLyDsl4XroZzrk5zrkJwg7LSI6riwIO2MjOydvCBTZXNzaW9uIFBhcmFtZXRlclxyXG4gICAgYXV0b1VwbG9hZDogUHJvcFR5cGVzLmJvb2wsICAgICAvLyBBdXRvIFVwbG9hZFxyXG4gICAgbXVsdGlwbGU6IFByb3BUeXBlcy5ib29sLCAgICAgICAvLyDssqjrtoDtjIzsnbwg7Jes65+s6rCcIOuTseuhnSjshKDtg50pIOqwgOuKpSDsl6zrtoBcclxuICAgIHVwbG9hZGVkRmlsZUxpc3Q6IFByb3BUeXBlcy5hcnJheSwgIC8vIOyXheuhnOuTnCDtjIzsnbwg66qp66GdXHJcbiAgICBhbGxvd2VkRXh0ZW5zaW9uczogUHJvcFR5cGVzLmFycmF5LCAvLyDssqjrtoDtjIzsnbwg7ZeI7Jqp7ZmV7J6l7J6QXHJcbiAgICBpdGVtTGltaXQ6IFByb3BUeXBlcy5udW1iZXIsICAgIC8vIOyyqOu2gO2MjOydvCDsiJgg7KCc7ZWcXHJcbiAgICBzaXplTGltaXQ6IFByb3BUeXBlcy5udW1iZXIsICAgIC8vIOyyqOu2gO2MjOydvCDsgqzsnbTspogg7KCc7ZWcXHJcbiAgICBlbXB0eUVycm9yOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgbm9GaWxlc0Vycm9yOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgc2l6ZUVycm9yOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgdG9vTWFueUl0ZW1zRXJyb3I6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICB0eXBlRXJyb3I6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBvbkRlbGV0ZTogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICBvbkRlbGV0ZUNvbXBsZXRlOiBQcm9wVHlwZXMuZnVuYyxcclxuICAgIG9uQ29tcGxldGU6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25FcnJvcjogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICBvblNlc3Npb25SZXF1ZXN0Q29tcGxldGU6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XHJcbiAgICBhdXRvVXBsb2FkOiB0cnVlLCBcclxuICAgIG11bHRpcGxlOiB0cnVlLCBcclxuICAgIHBhcmFtczoge30sIFxyXG4gICAgdXBsb2FkZWRGaWxlTGlzdDogW10sIFxyXG4gICAgYWxsb3dlZEV4dGVuc2lvbnM6IFtdLCBcclxuICAgIGl0ZW1MaW1pdDogMCwgXHJcbiAgICBzaXplTGltaXQ6IDAsIFxyXG4gICAgZW1wdHlFcnJvcjogJzBrYuydmCDsnpjrqrvrkJwg7YyM7J287J6F64uI64ukLicsIFxyXG4gICAgbm9GaWxlc0Vycm9yOiAn7LKo67aA65CcIO2MjOydvOydtCDsl4bsirXri4jri6QuJywgXHJcbiAgICBzaXplRXJyb3I6ICd7ZmlsZX0gaXMgdG9vIGxhcmdlLCBtYXhpbXVtIGZpbGUgc2l6ZSBpcyB7c2l6ZUxpbWl0fSEhLicsIFxyXG4gICAgdG9vTWFueUl0ZW1zRXJyb3I6ICdUb28gbWFueSBpdGVtcyAoe25ldEl0ZW1zfSkgd291bGQgYmUgdXBsb2FkZWQuIEl0ZW0gbGltaXQgaXMge2l0ZW1MaW1pdH0hIS4nLCBcclxuICAgIHR5cGVFcnJvcjogJ3tmaWxlfSBoYXMgYW4gaW52YWxpZCBleHRlbnNpb24uIFZhbGlkIGV4dGVuc2lvbihzKToge2V4dGVuc2lvbnN9LiEhJ1xyXG59O1xyXG5cclxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIEZpbmVVcGxvYWRlci4gKi9cclxuY2xhc3MgRmluZVVwbG9hZGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG5cclxuICAgICAgICAvLyBPcGVyYXRpb25zIHVzdWFsbHkgY2FycmllZCBvdXQgaW4gY29tcG9uZW50V2lsbE1vdW50IGdvIGhlcmVcclxuICAgICAgICBsZXQgaWQgPSBwcm9wcy5pZDtcclxuICAgICAgICBpZih0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGlkID0gVXRpbC5nZXRVVUlEKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgLy8g7LWc7LSIIOugjOuNlOungeydtCDsnbzslrTrgpwg64uk7J2MKO2VnOuyiCDtmLjstpwpXHJcbiAgICAgICAgdGhpcy4kZmluZVVwbG9hZGVyID0gJCgnIycrdGhpcy5pZClbMF07XHJcbiAgICAgICAgbGV0IHNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICBlbGVtZW50OiB0aGlzLiRmaW5lVXBsb2FkZXJcclxuICAgICAgICB9O1xyXG4gICAgICAgICQuZXh0ZW5kKHNldHRpbmdzLCB0aGlzLm9wdGlvbnModGhpcy5wcm9wcykpO1xyXG4gICAgICAgIHRoaXMuZmluZVVwbG9hZGVyID0gbmV3IHFxLkZpbmVVcGxvYWRlcihzZXR0aW5ncyk7XHJcbiAgICB9XHJcblxyXG4gICAgb3B0aW9ucyhwcm9wcykge1xyXG4gICAgICAgIGxldCBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgY29uc3Qge2hvc3QsIHNlc3Npb25VcmwsIHVwbG9hZFVybCwgZGVsZXRlVXJsLCBhdXRvVXBsb2FkLCBtdWx0aXBsZSwgcGFyYW1zLCBzZXNzaW9uUGFyYW1zLCB1cGxvYWRlZEZpbGVMaXN0LCBhbGxvd2VkRXh0ZW5zaW9ucywgaXRlbUxpbWl0LCBzaXplTGltaXQsIGVtcHR5RXJyb3IsIG5vRmlsZXNFcnJvciwgc2l6ZUVycm9yLCB0b29NYW55SXRlbXNFcnJvciwgdHlwZUVycm9yLCBvbkRlbGV0ZSwgb25EZWxldGVDb21wbGV0ZSwgb25Db21wbGV0ZSwgb25FcnJvciwgb25TZXNzaW9uUmVxdWVzdENvbXBsZXRlfSA9IHByb3BzO1xyXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBhdXRvVXBsb2FkOiBhdXRvVXBsb2FkLFxyXG4gICAgICAgICAgICBtdWx0aXBsZTogbXVsdGlwbGUsXHJcbiAgICAgICAgICAgIHJlcXVlc3Q6IHtcclxuICAgICAgICAgICAgICAgIGVuZHBvaW50OiAoaG9zdCAmJiBob3N0ICE9PSBudWxsICYmIGhvc3QubGVuZ3RoID4gMCkgPyBob3N0ICsgdXBsb2FkVXJsIDogdXBsb2FkVXJsLFxyXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdmFsaWRhdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgYWxsb3dlZEV4dGVuc2lvbnM6IGFsbG93ZWRFeHRlbnNpb25zLFxyXG4gICAgICAgICAgICAgICAgaXRlbUxpbWl0OiBpdGVtTGltaXQsXHJcbiAgICAgICAgICAgICAgICBzaXplTGltaXQ6IHNpemVMaW1pdCxcclxuICAgICAgICAgICAgICAgIHRvb01hbnlJdGVtc0Vycm9yOiB0b29NYW55SXRlbXNFcnJvcixcclxuICAgICAgICAgICAgICAgIHR5cGVFcnJvcjogdHlwZUVycm9yXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG1lc3NhZ2VzOiB7XHJcbiAgICAgICAgICAgICAgICBlbXB0eUVycm9yOiBlbXB0eUVycm9yLFxyXG4gICAgICAgICAgICAgICAgbm9GaWxlc0Vycm9yOiBub0ZpbGVzRXJyb3IsXHJcbiAgICAgICAgICAgICAgICBzaXplRXJyb3I6IHNpemVFcnJvclxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXNzaW9uOntcclxuICAgICAgICAgICAgICAgIGVuZHBvaW50OiAoaG9zdCAmJiBob3N0ICE9PSBudWxsICYmIGhvc3QubGVuZ3RoID4gMCkgPyBob3N0ICsgc2Vzc2lvblVybCA6IHNlc3Npb25VcmwsXHJcbiAgICAgICAgICAgICAgICByZWZyZXNoT25SZXF1ZXN0OnRydWVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGVsZXRlRmlsZTp7XHJcbiAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgICBlbmRwb2ludDogKGhvc3QgJiYgaG9zdCAhPT0gbnVsbCAmJiBob3N0Lmxlbmd0aCA+IDApID8gaG9zdCArIGRlbGV0ZVVybCA6IGRlbGV0ZVVybFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjYWxsYmFja3M6IHtcclxuICAgICAgICAgICAgICAgIG9uRGVsZXRlOiBmdW5jdGlvbihpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBvbkRlbGV0ZSA9PT0gJ2Z1bmN0aW9uJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRGVsZXRlKGlkKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy8g7IKt7KCcIOuyhO2KvCDtgbTrpq3si5wgRXZlbnRcclxuICAgICAgICAgICAgICAgIG9uU3VibWl0RGVsZXRlOiBmdW5jdGlvbihpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZpbmVVcGxvYWRlci5zZXREZWxldGVGaWxlUGFyYW1zKHtmaWxlbmFtZTogX3RoaXMuZmluZVVwbG9hZGVyLmdldE5hbWUoaWQpfSwgaWQpO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIOyCreygnCDsmYTro4zsi5wgRXZlbnRcclxuICAgICAgICAgICAgICAgIG9uRGVsZXRlQ29tcGxldGU6IGZ1bmN0aW9uKGlkLCB4aHIsIGlzRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZih4aHIucmVzcG9uc2VUZXh0KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoXCJmaWxlX25hbWVcIiBpbiByZXNwb25zZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRlZEZpbGVMaXN0LnNvbWUoKGZpbGVOYW1lLCBpZHgpID0+e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZpbGVOYW1lID09IHJlc3BvbnNlLmZpbGVfbmFtZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1cGxvYWRlZEZpbGVMaXN0LnNwbGljZShpZHgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBvbkRlbGV0ZUNvbXBsZXRlID09PSAnZnVuY3Rpb24nKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25EZWxldGVDb21wbGV0ZShpZCwgeGhyLCBpc0Vycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy8g7JeF66Gc65OcIOyZhOujjOyLnCBFdmVudFxyXG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24oaWQsIG5hbWUsIHJlc3BvbnNlLCB4aHIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKFwiZmlsZV9uYW1lXCIgaW4gcmVzcG9uc2Upe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5maW5lVXBsb2FkZXIuc2V0VXVpZChpZCwgcmVzcG9uc2UuZmlsZV9uYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBsb2FkZWRGaWxlTGlzdC5wdXNoKHJlc3BvbnNlLmZpbGVfbmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBvbkNvbXBsZXRlID09PSAnZnVuY3Rpb24nKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZShpZCwgbmFtZSwgcmVzcG9uc2UsIHhocik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIEVycm9yIOuwnOyDnSDsnbTrsqTtirhcclxuICAgICAgICAgICAgICAgIG9uRXJyb3I6IGZ1bmN0aW9uKGlkLCBuYW1lLCBlcnJvclJlYXNvbiwgeGhyKXtcclxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoaWQsIG5hbWUsIGVycm9yUmVhc29uLCB4aHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvLyDstIjquLAgRmlsZSDrqqnroZ0g7JqU7LKtIOyZhOujjOyLnFxyXG4gICAgICAgICAgICAgICAgb25TZXNzaW9uUmVxdWVzdENvbXBsZXRlOiBmdW5jdGlvbihyZXNwb25zZSwgc3VjY2VzcywgeGhyKXtcclxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2Ygb25TZXNzaW9uUmVxdWVzdENvbXBsZXRlID09PSAnZnVuY3Rpb24nKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25TZXNzaW9uUmVxdWVzdENvbXBsZXRlKHJlc3BvbnNlLCBzdWNjZXNzLCB4aHIsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmKGhvc3QgJiYgaG9zdCAhPT0gbnVsbCAmJiBob3N0Lmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7Y29yczoge1xyXG4gICAgICAgICAgICAgICAgLy9hbGwgcmVxdWVzdHMgYXJlIGV4cGVjdGVkIHRvIGJlIGNyb3NzLWRvbWFpbiByZXF1ZXN0c1xyXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRydWVcclxuICAgICAgICAgICAgICAgIC8vaWYgeW91IHdhbnQgY29va2llcyB0byBiZSBzZW50IGFsb25nIHdpdGggdGhlIHJlcXVlc3RcclxuICAgICAgICAgICAgICAgIC8vc2VuZENyZWRlbnRpYWxzOiB0cnVlXHJcbiAgICAgICAgICAgIH19KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBtZXRob2RzXHJcbiAgICAvLyDssqjrtoDtjIzsnbwg7JeF66Gc65OcIEZ1bmN0aW9uXHJcbiAgICB1cGxvYWRGaWxlcygpIHtcclxuICAgICAgICB0aGlzLmZpbmVVcGxvYWRlci51cGxvYWRTdG9yZWRGaWxlcygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIOyyqOu2gO2MjOydvCDstIjquLDtmZQg67CPIOuNsOydtO2EsCDroZzrk5xcclxuICAgIHJlZnJlc2hTZXNzaW9uKHNlc3Npb25QYXJhbXMpIHtcclxuICAgICAgICB0aGlzLmZpbmVVcGxvYWRlci5jbGVhclN0b3JlZEZpbGVzKCk7XHJcbiAgICAgICAgdGhpcy5maW5lVXBsb2FkZXIuX3Nlc3Npb24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZmluZVVwbG9hZGVyLl9vcHRpb25zLnNlc3Npb24ucGFyYW1zID0gc2Vzc2lvblBhcmFtcztcclxuICAgICAgICB0aGlzLmZpbmVVcGxvYWRlci5yZXNldCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICAvLyDtlYTsiJgg7ZWt66qpXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgaWQ9e3RoaXMuaWR9PjwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5GaW5lVXBsb2FkZXIucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xyXG5GaW5lVXBsb2FkZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRmluZVVwbG9hZGVyOyIsIi8qKlxyXG4gKiBIaWRkZW5Db250ZW50IGNvbXBvbmVudFxyXG4gKlxyXG4gKiB2ZXJzaW9uIDx0dD4kIFZlcnNpb246IDEuMCAkPC90dD4gZGF0ZToyMDE2LzAzLzEwXHJcbiAqIGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmhyYWhuQG5raWEuY28ua3JcIj5BaG4gSHl1bmctUm88L2E+XHJcbiAqXHJcbiAqIGV4YW1wbGU6XHJcbiAqIDxQdW0uSGlkZGVuQ29udGVudCBpZD17aWR9IC8+XHJcbiAqXHJcbiAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQgVXRpbCBmcm9tICcuLi9zZXJ2aWNlcy9VdGlsJztcclxuXHJcbmNvbnN0IHByb3BUeXBlcyA9IHtcclxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgZXhwYW5kTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBjb2xsYXBzZUxhYmVsOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgZXhwYW5kSWNvbjogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGNvbGxhcHNlSWNvbjogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGlzQm90dG9tOiBQcm9wVHlwZXMuYm9vbFxyXG59O1xyXG5cclxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xyXG4gICAgXHJcbn07XHJcblxyXG4vKiogQ2xhc3MgcmVwcmVzZW50aW5nIGEgSGlkZGVuQ29udGVudC4gKi9cclxuY2xhc3MgSGlkZGVuQ29udGVudCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgbGV0IGxhYmVsID0gcHJvcHMuZXhwYW5kTGFiZWw7XHJcbiAgICAgICAgaWYodHlwZW9mIGxhYmVsID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBsYWJlbCA9ICdFeHBhbmQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaWNvbiA9IHByb3BzLmV4cGFuZEljb247XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgbGFiZWw6IGxhYmVsLCBcclxuICAgICAgICAgICAgaWNvbjogaWNvblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIE9wZXJhdGlvbnMgdXN1YWxseSBjYXJyaWVkIG91dCBpbiBjb21wb25lbnRXaWxsTW91bnQgZ28gaGVyZVxyXG4gICAgICAgIGxldCBpZCA9IHByb3BzLmlkO1xyXG4gICAgICAgIGlmKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWQgPSBVdGlsLmdldFVVSUQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuXHJcbiAgICAgICAgLy8gTWFudWFsbHkgYmluZCB0aGlzIG1ldGhvZCB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlLi4uXHJcbiAgICAgICAgdGhpcy5vbkV4cGFuZENvbGxhcHNlID0gdGhpcy5vbkV4cGFuZENvbGxhcHNlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbkJvdHRvbUNvbGxhcHNlID0gdGhpcy5vbkJvdHRvbUNvbGxhcHNlLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gZXZlbnRzXHJcbiAgICBvbkV4cGFuZENvbGxhcHNlKGUpIHtcclxuICAgICAgICAvL3ZhciBub2RlID0gZS50YXJnZXQsXHJcbiAgICAgICAgLy8gICAgYVRhZyA9IG5vZGUucGFyZW50Tm9kZTtcclxuICAgICAgICB2YXIgYVRhZyA9IGUudGFyZ2V0O1xyXG4gICAgICAgIGlmKCQoYVRhZykubmV4dCgpLmNzcygnZGlzcGxheScpID09PSAnbm9uZScpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGxhYmVsOiB0aGlzLnByb3BzLmNvbGxhcHNlTGFiZWwsIGljb246IHRoaXMucHJvcHMuY29sbGFwc2VJY29uIH0pO1xyXG4gICAgICAgICAgICAkKGFUYWcpLm5leHQoKS5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBsYWJlbDogdGhpcy5wcm9wcy5leHBhbmRMYWJlbCwgaWNvbjogdGhpcy5wcm9wcy5leHBhbmRJY29uIH0pO1xyXG4gICAgICAgICAgICAkKGFUYWcpLm5leHQoKS5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgb25Cb3R0b21Db2xsYXBzZShlKSB7XHJcbiAgICAgICAgbGV0IG5vZGUgPSBlLnRhcmdldCxcclxuICAgICAgICAgICAgZGl2ID0gbm9kZS5wYXJlbnROb2RlOy8vLnBhcmVudE5vZGU7XHJcbiAgICAgICAgJChkaXYpLmNzcygnZGlzcGxheScsICdub25lJyk7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGxhYmVsOiB0aGlzLnByb3BzLmV4cGFuZExhYmVsLCBpY29uOiB0aGlzLnByb3BzLmV4cGFuZEljb24gfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICAvLyDtlYTsiJgg7ZWt66qpXHJcbiAgICAgICAgdmFyIEljb247XHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMuc3RhdGUuaWNvbiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgSWNvbiA9IDxpIGNsYXNzTmFtZT17dGhpcy5zdGF0ZS5pY29ufT57J1xcdTAwQTAnfTwvaT47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyDrp6gg7JWE656YIOygkeq4sOuyhO2KvCDsspjrpqxcclxuICAgICAgICB2YXIgQm90dG9tQnV0dG9uO1xyXG4gICAgICAgIGlmKHRoaXMucHJvcHMuaXNCb3R0b20gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgbGV0IENvbGxhcHNlSWNvbjtcclxuICAgICAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMuY29sbGFwc2VJY29uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgQ29sbGFwc2VJY29uID0gPGkgY2xhc3NOYW1lPXt0aGlzLnByb3BzLmNvbGxhcHNlSWNvbn0+eydcXHUwMEEwJ308L2k+O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyAjIOyZgCByZWFjdC1yb3V0ZXIg7Lap64+M66y47KCcIO2VtOqysO2VtOyVvCDtlahcclxuICAgICAgICAgICAgQm90dG9tQnV0dG9uID0gPGEgaHJlZj17JyMnICsgdGhpcy5pZH0gb25DbGljaz17dGhpcy5vbkJvdHRvbUNvbGxhcHNlfT57Q29sbGFwc2VJY29ufXt0aGlzLnByb3BzLmNvbGxhcHNlTGFiZWx9PC9hPlxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ2hpZGRlbi1jb250ZW50JywgdGhpcy5wcm9wcy5jbGFzc05hbWUpfT5cclxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMClcIiBvbkNsaWNrPXt0aGlzLm9uRXhwYW5kQ29sbGFwc2V9IG5hbWU9e3RoaXMuaWR9PntJY29ufXt0aGlzLnN0YXRlLmxhYmVsfTwvYT5cclxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3tkaXNwbGF5OiAnbm9uZSd9fT5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGlkPXt0aGlzLmlkfT57dGhpcy5wcm9wcy5jaGlsZHJlbn08L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICB7Qm90dG9tQnV0dG9ufVxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbkhpZGRlbkNvbnRlbnQucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xyXG5IaWRkZW5Db250ZW50LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEhpZGRlbkNvbnRlbnQ7IiwiLyoqXHJcbiAqIFNwbGl0dGVyIGNvbXBvbmVudFxyXG4gKlxyXG4gKiB2ZXJzaW9uIDx0dD4kIFZlcnNpb246IDEuMCAkPC90dD4gZGF0ZToyMDE2LzAzLzAzXHJcbiAqIGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmhyYWhuQG5raWEuY28ua3JcIj5BaG4gSHl1bmctUm88L2E+XHJcbiAqXHJcbiAqIGV4YW1wbGU6XHJcbiAqIDxQdWYuU3BsaXR0ZXIgLz5cclxuICpcclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcbmltcG9ydCBVdGlsIGZyb20gJy4uL3NlcnZpY2VzL1V0aWwnO1xyXG5cclxuY29uc3QgcHJvcFR5cGVzID0ge1xyXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICB0eXBlOiBQcm9wVHlwZXMub25lT2YoWydoJywgJ3YnXSkuaXNSZXF1aXJlZCxcclxuICAgIHBvc2l0aW9uOiBQcm9wVHlwZXMub25lT2YoWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXSkuaXNSZXF1aXJlZCxcclxuICAgIC8vbGVmdFBhbmU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICAvL3JpZ2h0UGFuZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIG1pbkxlZnQ6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZCxcclxuICAgIG1pblJpZ2h0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXHJcbiAgICBtYXhMZWZ0OiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXHJcbiAgICBtYXhSaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxyXG4gICAgcmVzaXphYmxlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGhpZGRlbjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBvblJlc2l6ZTogUHJvcFR5cGVzLmZ1bmNcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcclxuICAgIHR5cGU6ICdoJywgXHJcbiAgICBwb3NpdGlvbjogJ2xlZnQnLCBcclxuICAgIG1pbkxlZnQ6IDUwLCBcclxuICAgIG1pblJpZ2h0OiA1MCwgXHJcbiAgICBtYXhMZWZ0OiA1MDAsIFxyXG4gICAgbWF4UmlnaHQ6IDUwMCxcclxuICAgIHJlc2l6YWJsZTogdHJ1ZVxyXG59O1xyXG5cclxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIE1haW5GcmFtZVNwbGl0dGVyLiAqL1xyXG5jbGFzcyBNYWluRnJhbWVTcGxpdHRlciBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgZXhwYW5kOiB0cnVlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5zcGxpdHRlckFjdGl2ZUZsYWcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNwbGl0dGVyT2JqID0gZmFsc2U7XHJcblxyXG4gICAgICAgIC8vIE1hbnVhbGx5IGJpbmQgdGhpcyBtZXRob2QgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZS4uLlxyXG4gICAgICAgIHRoaXMub25SZXNpemUgPSB0aGlzLm9uUmVzaXplLmJpbmQodGhpcyk7XHJcblxyXG4gICAgICAgIHRoaXMuc3BsaXR0ZXJNb3VzZVVwID0gdGhpcy5zcGxpdHRlck1vdXNlVXAuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnNwbGl0dGVyTW91c2VEb3duID0gdGhpcy5zcGxpdHRlck1vdXNlRG93bi5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc3BsaXR0ZXJNb3VzZU1vdmUgPSB0aGlzLnNwbGl0dGVyTW91c2VNb3ZlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5leHBhbmRDb2xsYXBzZSA9IHRoaXMuZXhwYW5kQ29sbGFwc2UuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlc2l6ZVNwbGl0dGVyUG9zID0gdGhpcy5yZXNpemVTcGxpdHRlclBvcy5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcclxuICAgICAgICAvLyDstZzstIgg66CM642U66eB7J20IOydvOyWtOuCmOq4sCDsp4HsoIQo7ZWc67KIIO2YuOy2nClcclxuICAgICAgICBsZXQgaWQgPSB0aGlzLnByb3BzLmlkO1xyXG4gICAgICAgIGlmKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWQgPSBVdGlsLmdldFVVSUQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAvLyDstZzstIgg66CM642U66eB7J20IOydvOyWtOuCnCDri6TsnYwo7ZWc67KIIO2YuOy2nClcclxuICAgICAgICB0aGlzLiRzcGxpdHRlciA9ICQoJyMnK3RoaXMuaWQpO1xyXG5cclxuICAgICAgICBpZih0aGlzLnByb3BzLnJlc2l6YWJsZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy4kc3BsaXR0ZXIuY3NzKCdjdXJzb3InLCAnZGVmYXVsdCcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMuaGlkZGVuID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmxlKCF0aGlzLnByb3BzLmhpZGRlbik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBFdmVudHNcclxuICAgICAgICB0aGlzLiRzcGxpdHRlci5vbigncmVzaXplJywgdGhpcy5vblJlc2l6ZSk7XHJcblxyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUnLCBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIC8vIHNwbGl0dGVy7JeQ7IScIOuwnOyDneyLnO2CpOuKlCByZXNpemUg7J2067Kk7Yq47JmAIOq1rOuzhFxyXG4gICAgICAgICAgICBpZihlLnRhcmdldCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgLy9fdGhpcy5yZXNpemVTcGxpdHRlclBvcygpO1xyXG4gICAgICAgICAgICAgICAgLy8gc3BsaXR0ZXJPcGVuL3NwbGl0dGVyQ2xvc2Ug7ZWo7IiYIOyLpO2WieqzvCDsi5zqsITssKjrpbwg65GQ7Ja07JW8IOyggeyaqeuQqFxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChfdGhpcy5yZXNpemVTcGxpdHRlclBvcywgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBldmVudHNcclxuICAgIG9uUmVzaXplKGUpIHtcclxuICAgICAgICBpZih0aGlzLnByb3BzLm9uUmVzaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25SZXNpemUoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIG1ldGhvZHNcclxuICAgIG9wZW4oKSB7XHJcbiAgICAgICAgdGhpcy5zcGxpdHRlck9wZW4oKTtcclxuICAgIH1cclxuXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICBjb25zdCB7IHR5cGUsIHBvc2l0aW9uIH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICB0aGlzLnNwbGl0dGVyQ2xvc2UoKTtcclxuICAgICAgICBpZih0eXBlID09PSAnaCcpIHtcclxuXHJcbiAgICAgICAgICAgIGlmKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuJHNwbGl0dGVyLm5leHQoKS5vZmZzZXQoeyBsZWZ0OiAwIH0pO1xyXG4gICAgICAgICAgICB9ZWxzZSBpZihwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kc3BsaXR0ZXIucHJldigpLmNzcygncmlnaHQnLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2aXNpYmxlKGlzQm9vbCkge1xyXG4gICAgICAgIGlmKGlzQm9vbCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy4kc3BsaXR0ZXIuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuJHNwbGl0dGVyLmNzcygnZGlzcGxheScsICcnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gcHJpdmF0ZVxyXG4gICAgLy8gc3BsaXR0ZXJBY3RpdmVGbGFnOiBmYWxzZSxcclxuICAgIC8vIHNwbGl0dGVyT2JqOiBmYWxzZSxcclxuICAgIHNwbGl0dGVyTW91c2VEb3duKGUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc3BsaXR0ZXJBY3RpdmVGbGFnICYmIHRoaXMuc3RhdGUuZXhwYW5kID09PSB0cnVlICYmIHRoaXMucHJvcHMucmVzaXphYmxlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpXHJcbiAgICAgICAgICAgIGlmICh0aGlzLiRzcGxpdHRlclswXS5zZXRDYXB0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRzcGxpdHRlclswXS5zZXRDYXB0dXJlKCk7XHJcbiAgICAgICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLnNwbGl0dGVyTW91c2VVcCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLnNwbGl0dGVyTW91c2VNb3ZlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNwbGl0dGVyQWN0aXZlRmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXR0ZXJPYmogPSB0aGlzLiRzcGxpdHRlclswXTtcclxuXHJcbiAgICAgICAgICAgIC8vbGVmdHNpZGViYXJDb2xsYXBzZVdpZHRoID0gJCgnLmxlZnRzaWRlYmFyLWNvbGxhcHNlJykub3V0ZXJXaWR0aCh0cnVlKTtcclxuICAgICAgICAgICAgdGhpcy5zcGxpdHRlcldpZHRoID0gdGhpcy4kc3BsaXR0ZXIub3V0ZXJXaWR0aCh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgIC8qc3BsaXR0ZXJQYXJlbnRPYmogPSBiLnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICBjb25zb2xlLmxvZyhzcGxpdHRlck9iai5vZmZzZXRMZWZ0KTtcclxuICAgICAgICAgICAgIGNvbnNvbGUubG9nKHNwbGl0dGVyT2JqLnBhcmVudEVsZW1lbnQub2Zmc2V0TGVmdCk7Ki9cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3BsaXR0ZXJNb3VzZVVwKGUpIHtcclxuICAgICAgICBpZiAodGhpcy5zcGxpdHRlckFjdGl2ZUZsYWcpIHtcclxuICAgIC8vICAgICAgICB2YXIgYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidG9jXCIpO1xyXG4gICAgLy8gICAgICAgIHZhciBjID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb250ZW50XCIpO1xyXG4gICAgLy8gICAgICAgIGNoYW5nZVFTZWFyY2hib3hXaWR0aCgpO1xyXG4gICAgLy8gICAgICAgIGEuc3R5bGUud2lkdGggPSAoc3BsaXR0ZXJPYmoub2Zmc2V0TGVmdCAtIDIwKSArIFwicHhcIjtcclxuICAgIC8vICAgICAgICBjLnN0eWxlLmxlZnQgPSAoc3BsaXR0ZXJPYmoub2Zmc2V0TGVmdCArIDEwKSArIFwicHhcIjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSwgcG9zaXRpb24gfSA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgICAgICBpZih0eXBlID09PSAnaCcpIHtcclxuICAgICAgICAgICAgICAgIGlmKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRzcGxpdHRlci5wcmV2KCkub3V0ZXJXaWR0aCh0aGlzLnNwbGl0dGVyT2JqLm9mZnNldExlZnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHNwbGl0dGVyLm5leHQoKS5vZmZzZXQoeyBsZWZ0OiAodGhpcy5zcGxpdHRlck9iai5vZmZzZXRMZWZ0ICsgdGhpcy5zcGxpdHRlcldpZHRoKSB9KTtcclxuICAgICAgICAgICAgICAgIH1lbHNlIGlmKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oUmlnaHRTcGxpdHRlck9mZnNldFJpZ2h0ID0gdGhpcy4kc3BsaXR0ZXIucGFyZW50KCkub3V0ZXJXaWR0aCh0cnVlKSAtIHRoaXMuc3BsaXR0ZXJPYmoub2Zmc2V0TGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRzcGxpdHRlci5wcmV2KCkuY3NzKCdyaWdodCcsIHRoaXMuaFJpZ2h0U3BsaXR0ZXJPZmZzZXRSaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kc3BsaXR0ZXIubmV4dCgpLm91dGVyV2lkdGgodGhpcy5oUmlnaHRTcGxpdHRlck9mZnNldFJpZ2h0IC0gdGhpcy5zcGxpdHRlcldpZHRoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzLiRzcGxpdHRlci5wcmV2KCkub2Zmc2V0KHsgcmlnaHQ6IHRoaXMuc3BsaXR0ZXJPYmoub2Zmc2V0UmlnaHQgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzLiRzcGxpdHRlci5uZXh0KCkub3V0ZXJXaWR0aCh0aGlzLnNwbGl0dGVyT2JqLm9mZnNldFJpZ2h0IC0gdGhpcy5zcGxpdHRlcldpZHRoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3BsaXR0ZXJPYmoucmVsZWFzZUNhcHR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3BsaXR0ZXJPYmoucmVsZWFzZUNhcHR1cmUoKTtcclxuICAgICAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuc3BsaXR0ZXJNb3VzZVVwLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuc3BsaXR0ZXJNb3VzZU1vdmUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXR0ZXJBY3RpdmVGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuc2F2ZVNwbGl0dGVyUG9zKCk7XHJcbiAgICAgICAgICAgIC8vdGhpcy5vblJlc2l6ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLiRzcGxpdHRlci50cmlnZ2VyKCdyZXNpemUnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3BsaXR0ZXJNb3VzZU1vdmUoZSkge1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcG9zaXRpb24sIG1pbkxlZnQsIG1pblJpZ2h0LCBtYXhMZWZ0LCBtYXhSaWdodCB9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuc3BsaXR0ZXJBY3RpdmVGbGFnKSB7XHJcbiAgICAgICAgICAgIGlmKHR5cGUgPT09ICdoJykge1xyXG4gICAgICAgICAgICAgICAgaWYocG9zaXRpb24gPT09ICdsZWZ0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmNsaWVudFggPj0gbWluTGVmdCAmJiBlLmNsaWVudFggPD0gbWF4TGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwbGl0dGVyT2JqLnN0eWxlLmxlZnQgPSBlLmNsaWVudFggKyAncHgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighdGhpcy5zcGxpdHRlck9iai5yZWxlYXNlQ2FwdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfWVsc2UgaWYocG9zaXRpb24gPT09ICdyaWdodCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jbGllbnRYIDw9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCAtIG1pblJpZ2h0ICYmIGUuY2xpZW50WCA+PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggLSBtYXhSaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwbGl0dGVyT2JqLnN0eWxlLmxlZnQgPSBlLmNsaWVudFggKyAncHgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighdGhpcy5zcGxpdHRlck9iai5yZWxlYXNlQ2FwdHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIGlmIChlLmNsaWVudFggPj0gdGhpcy5wcm9wcy5taW5MZWZ0ICYmIGUuY2xpZW50WCA8PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggLSB0aGlzLnByb3BzLm1pblJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNwbGl0dGVyT2JqLnN0eWxlLmxlZnQgPSBlLmNsaWVudFggKyAncHgnO1xyXG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuc3BsaXR0ZXJPYmoucmVsZWFzZUNhcHR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgKi9cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc3BsaXR0ZXJPcGVuKCkge1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcG9zaXRpb24gfSA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgIGlmKHR5cGUgPT09ICdoJykge1xyXG4gICAgICAgICAgICBpZihwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRzcGxpdHRlci5wcmV2KCkub2Zmc2V0KHsgbGVmdDogMCB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuJHNwbGl0dGVyLm9mZnNldCh7IGxlZnQ6IHRoaXMubGVmdEZyYW1lV2lkdGggfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRzcGxpdHRlci5uZXh0KCkub2Zmc2V0KHsgbGVmdDogKHRoaXMubGVmdEZyYW1lV2lkdGggKyB0aGlzLnNwbGl0dGVyV2lkdGgpIH0pO1xyXG4gICAgICAgICAgICB9ZWxzZSBpZihwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kc3BsaXR0ZXIucHJldigpLmNzcygncmlnaHQnLCAodGhpcy5yaWdodEZyYW1lV2lkdGggKyB0aGlzLnNwbGl0dGVyV2lkdGgpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuJHNwbGl0dGVyLm9mZnNldCh7IGxlZnQ6ICh0aGlzLiRzcGxpdHRlci5wYXJlbnQoKS5vdXRlcldpZHRoKHRydWUpIC0gdGhpcy5yaWdodEZyYW1lV2lkdGggLSB0aGlzLnNwbGl0dGVyV2lkdGgpIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kc3BsaXR0ZXIubmV4dCgpLm91dGVyV2lkdGgodGhpcy5yaWdodEZyYW1lV2lkdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLiRzcGxpdHRlci5jc3MoJ2N1cnNvcicsICdlLXJlc2l6ZScpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgIHRoaXMuJHNwbGl0dGVyLnByZXYoKS5vbignd2Via2l0VHJhbnNpdGlvbkVuZCBvdHJhbnNpdGlvbmVuZCBvVHJhbnNpdGlvbkVuZCBtc1RyYW5zaXRpb25FbmQgdHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgdGhpcy4kc3BsaXR0ZXIuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtleHBhbmQ6IHRydWV9KTtcclxuICAgICAgICB0aGlzLiRzcGxpdHRlci50cmlnZ2VyKCdyZXNpemUnKTtcclxuICAgIH1cclxuXHJcbiAgICBzcGxpdHRlckNsb3NlKCkge1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcG9zaXRpb24gfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYodHlwZSA9PT0gJ2gnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXR0ZXJXaWR0aCA9IHRoaXMuJHNwbGl0dGVyLm91dGVyV2lkdGgodHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICBpZihwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnRGcmFtZVdpZHRoID0gdGhpcy4kc3BsaXR0ZXIucHJldigpLm91dGVyV2lkdGgodHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgdGhpcy4kc3BsaXR0ZXIucHJldigpLm9mZnNldCh7IGxlZnQ6ICh0aGlzLmxlZnRGcmFtZVdpZHRoICogLTEpIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kc3BsaXR0ZXIub2Zmc2V0KHsgbGVmdDogMCB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuJHNwbGl0dGVyLm5leHQoKS5vZmZzZXQoeyBsZWZ0OiB0aGlzLnNwbGl0dGVyV2lkdGggfSk7XHJcbiAgICAgICAgICAgIH1lbHNlIGlmKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0RnJhbWVXaWR0aCA9IHRoaXMuJHNwbGl0dGVyLm5leHQoKS5vdXRlcldpZHRoKHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMuJHNwbGl0dGVyLnByZXYoKS5jc3MoJ3JpZ2h0JywgdGhpcy5zcGxpdHRlcldpZHRoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuJHNwbGl0dGVyLm9mZnNldCh7IGxlZnQ6ICh0aGlzLiRzcGxpdHRlci5wYXJlbnQoKS5vdXRlcldpZHRoKHRydWUpIC0gdGhpcy5zcGxpdHRlcldpZHRoKSB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuJHNwbGl0dGVyLm5leHQoKS5vdXRlcldpZHRoKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLiRzcGxpdHRlci5jc3MoJ2N1cnNvcicsICdkZWZhdWx0Jyk7XHJcbiAgICAgICAgLy90aGlzLiRzcGxpdHRlci5wcmV2KCkub2ZmKCd3ZWJraXRUcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kIG9UcmFuc2l0aW9uRW5kIG1zVHJhbnNpdGlvbkVuZCB0cmFuc2l0aW9uZW5kJyk7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGV4cGFuZDogZmFsc2UgfSk7XHJcbiAgICAgICAgdGhpcy4kc3BsaXR0ZXIudHJpZ2dlcigncmVzaXplJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZXhwYW5kQ29sbGFwc2UoZSkge1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHRoaXMuc3RhdGUuZXhwYW5kID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3BsaXR0ZXJDbG9zZSgpO1xyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zcGxpdHRlck9wZW4oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2F2ZVNwbGl0dGVyUG9zKCkge1xyXG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcG9zaXRpb24gfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLiRzcGxpdHRlclswXTsvL2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpO1xyXG4gICAgICAgIGlmKGEpIHtcclxuICAgICAgICAgICAgaWYodHlwZSA9PT0gJ2gnKSB7XHJcbiAgICAgICAgICAgICAgICBpZihwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVXRpbC5zZXRDb29raWUoJ2hzcGxpdHRlckxlZnRQb3NpdGlvbicsIGEub2Zmc2V0TGVmdCwgMzY1KTtcclxuICAgICAgICAgICAgICAgIH1lbHNlIGlmKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVXRpbC5zZXRDb29raWUoJ2hzcGxpdHRlclJpZ2h0UG9zaXRpb24nLCB0aGlzLmhSaWdodFNwbGl0dGVyT2Zmc2V0UmlnaHQsIDM2NSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVzaXplU3BsaXR0ZXJQb3MoKSB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCBwb3NpdGlvbiB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBpZih0eXBlID09PSAnaCcpIHtcclxuICAgICAgICAgICAgaWYocG9zaXRpb24gPT09ICdyaWdodCcpIHtcclxuICAgICAgICAgICAgICAgIHZhciByaWdodEZyYW1lV2lkdGggPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5zdGF0ZS5leHBhbmQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByaWdodEZyYW1lV2lkdGggPSB0aGlzLiRzcGxpdHRlci5uZXh0KCkub3V0ZXJXaWR0aCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuJHNwbGl0dGVyLm9mZnNldCh7IGxlZnQ6ICh0aGlzLiRzcGxpdHRlci5wYXJlbnQoKS5vdXRlcldpZHRoKHRydWUpIC0gcmlnaHRGcmFtZVdpZHRoIC0gdGhpcy5zcGxpdHRlcldpZHRoKSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHRcclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICAvLyDtlYTsiJgg7ZWt66qpXHJcbiAgICAgICAgY29uc3QgeyBjbGFzc05hbWUsIHR5cGUsIHBvc2l0aW9uLCByZXNpemFibGUgfSA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgIHZhciBoID0gdHJ1ZTtcclxuICAgICAgICBpZih0eXBlICE9PSAnaCcpIHtcclxuICAgICAgICAgICAgaCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGwgPSB0cnVlO1xyXG4gICAgICAgIGlmKHBvc2l0aW9uICE9PSAnbGVmdCcpIHtcclxuICAgICAgICAgICAgbCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgIGlmKCF0aGlzLnN0YXRlLmV4cGFuZCB8fCAhcmVzaXphYmxlKSB7XHJcbiAgICAgICAgICAgIGRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2IGlkPXt0aGlzLmlkfSBjbGFzc05hbWU9e2NsYXNzTmFtZXMoeydtYWluZnJhbWUtc3BsaXR0ZXInOiB0cnVlLCAnaC1zcGxpdHRlcic6IGgsICd2LXNwbGl0dGVyJzogIWgsICdsZWZ0LXNwbGl0dGVyJzogbCwgJ3JpZ2h0LXNwbGl0dGVyJzogIWx9LCBjbGFzc05hbWUpfVxyXG4gICAgICAgICAgICAgICAgb25Nb3VzZURvd249e3RoaXMuc3BsaXR0ZXJNb3VzZURvd259IG9uTW91c2VVcD17dGhpcy5zcGxpdHRlck1vdXNlVXB9IG9uTW91c2VNb3ZlPXt0aGlzLnNwbGl0dGVyTW91c2VNb3ZlfT5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKHsnc3BsaXR0ZXItY29sbGFwc2UnOiB0aGlzLnN0YXRlLmV4cGFuZCwgJ3NwbGl0dGVyLWV4cGFuZCc6ICF0aGlzLnN0YXRlLmV4cGFuZH0pfSBvbkNsaWNrPXt0aGlzLmV4cGFuZENvbGxhcHNlfT48L2Rpdj5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BsaXR0ZXItcmVzaXplLWhhbmRsZVwiIHN0eWxlPXt7ZGlzcGxheTogZGlzcGxheX19PjwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5NYWluRnJhbWVTcGxpdHRlci5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XHJcbk1haW5GcmFtZVNwbGl0dGVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1haW5GcmFtZVNwbGl0dGVyOyIsIi8qKlxuICogTW9kYWwgY29tcG9uZW50XG4gKlxuICogdmVyc2lvbiA8dHQ+JCBWZXJzaW9uOiAxLjAgJDwvdHQ+IGRhdGU6MjAxNi8wMy8yNVxuICogYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86aHJhaG5AbmtpYS5jby5rclwiPkFobiBIeXVuZy1SbzwvYT5cbiAqXG4gKiBleGFtcGxlOlxuICogPFB1Zi5Nb2RhbCByZWY9XCJtb2RhbFwiIHdpZHRoPVwiNzAwcHhcIj5cbiAqICAgPFB1Zi5Nb2RhbEhlYWRlcj5Nb2RhbCBUaXRsZTwvUHVmLk1vZGFsSGVhZGVyPlxuICogICA8UHVmLk1vZGFsQm9keT5Nb2RhbCBCb2R5PC9QdWYuTW9kYWxCb2R5PlxuICogICA8UHVmLk1vZGFsRm9vdGVyPk1vZGFsIEZvb3RlcjwvUHVmLk1vZGFsRm9vdGVyPlxuICogPC9QdWYuTW9kYWw+XG4gKlxuICogYm9vdHN0cmFwIGNvbXBvbmVudFxuICovXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xuaW1wb3J0IFV0aWwgZnJvbSAnLi4vc2VydmljZXMvVXRpbCc7XG5cbmNvbnN0IHByb3BUeXBlc01vZGFsSGVhZGVyID0ge1xuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIE1vZGFsSGVhZGVyLiAqL1xuY2xhc3MgTW9kYWxIZWFkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICB9XG4gICAgXG4gICAgcmVuZGVyKCkge1xuICAgICAgICAvLyDtlYTsiJgg7ZWt66qpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3NOYW1lcygnbW9kYWwtaGVhZGVyJywgdGhpcy5wcm9wcy5jbGFzc05hbWUpfT5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzc05hbWU9XCJjbG9zZVwiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCI+PHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvc3Bhbj48c3BhbiBjbGFzc05hbWU9XCJzci1vbmx5XCI+Q2xvc2U8L3NwYW4+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwibW9kYWwtdGl0bGVcIj57dGhpcy5wcm9wcy5jaGlsZHJlbn08L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmNvbnN0IHByb3BUeXBlc01vZGFsQm9keSA9IHtcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmdcbn07XG5cbi8qKiBDbGFzcyByZXByZXNlbnRpbmcgYSBNb2RhbEJvZHkuICovXG5jbGFzcyBNb2RhbEJvZHkgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8vIO2VhOyImCDtla3rqqlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKCdtb2RhbC1ib2R5JywgdGhpcy5wcm9wcy5jbGFzc05hbWUpfT57dGhpcy5wcm9wcy5jaGlsZHJlbn08L2Rpdj5cbiAgICAgICAgKTtcbiAgICB9XG59XG5cbmNvbnN0IHByb3BUeXBlc01vZGFsRm9vdGVyID0ge1xuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZ1xufTtcblxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIE1vZGFsRm9vdGVyLiAqL1xuY2xhc3MgTW9kYWxGb290ZXIgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8vIO2VhOyImCDtla3rqqlcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKCdtb2RhbC1mb290ZXInLCB0aGlzLnByb3BzLmNsYXNzTmFtZSl9Pnt0aGlzLnByb3BzLmNoaWxkcmVufTwvZGl2PlxuICAgICAgICApO1xuICAgIH1cbn1cblxuY29uc3QgcHJvcFR5cGVzTW9kYWwgPSB7XG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIHdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgICAgUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgICAgUHJvcFR5cGVzLm51bWJlclxuICAgIF0pLFxuICAgIGJhY2tkcm9wOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBvblNob3c6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uSGlkZTogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmNvbnN0IGRlZmF1bHRQcm9wc01vZGFsID0ge1xuICAgIGJhY2tkcm9wOiBmYWxzZVxufTtcblxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIE1vZGFsLiAqL1xuY2xhc3MgTW9kYWwgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcblxuICAgICAgICAvLyBNYW51YWxseSBiaW5kIHRoaXMgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuLi5cbiAgICAgICAgdGhpcy5vblNob3cgPSB0aGlzLm9uU2hvdy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uSGlkZSA9IHRoaXMub25IaWRlLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgICAgICAvLyDstZzstIgg66CM642U66eB7J20IOydvOyWtOuCmOq4sCDsp4HsoIQo7ZWc67KIIO2YuOy2nClcbiAgICAgICAgbGV0IGlkID0gdGhpcy5wcm9wcy5pZDtcbiAgICAgICAgaWYodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWQgPSBVdGlsLmdldFVVSUQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgLy8g7LWc7LSIIOugjOuNlOungeydtCDsnbzslrTrgpwg64uk7J2MKO2VnOuyiCDtmLjstpwpXG4gICAgICAgIHRoaXMuJG1vZGFsID0gJCgnIycrdGhpcy5pZCk7XG4gICAgICAgIGlmKHRoaXMucHJvcHMuYmFja2Ryb3AgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLiRtb2RhbC5hdHRyKCdkYXRhLWJhY2tkcm9wJywgJ3N0YXRpYycpO1xuICAgICAgICAgICAgdGhpcy4kbW9kYWwuYXR0cignZGF0YS1rZXlib2FyZCcsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV2ZW50c1xuICAgICAgICB0aGlzLiRtb2RhbC5vbignc2hvd24uYnMubW9kYWwnLCB0aGlzLm9uU2hvdyk7XG4gICAgICAgIHRoaXMuJG1vZGFsLm9uKCdoaWRkZW4uYnMubW9kYWwnLCB0aGlzLm9uSGlkZSk7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGV2ZW50c1xuICAgIG9uU2hvdyhldmVudCkge1xuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vblNob3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25TaG93KGV2ZW50KTtcbiAgICAgICAgICAgIC8vZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkhpZGUoZXZlbnQpIHtcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMub25IaWRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uSGlkZShldmVudCk7XG4gICAgICAgICAgICAvL2V2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBtZXRob2RzXG4gICAgc2hvdygpIHtcbiAgICAgICAgdGhpcy4kbW9kYWwubW9kYWwoJ3Nob3cnKTtcbiAgICAgICAgLypcbiAgICAgICAgaWYodGhpcy5wcm9wcy5iYWNrZHJvcCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgYWxlcnQubW9kYWwoJ3Nob3cnKTtcbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgYWxlcnQubW9kYWwoe1xuICAgICAgICAgICAgICAgIGJhY2tkcm9wOiAnc3RhdGljJyxcbiAgICAgICAgICAgICAgICBrZXlib2FyZDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgICovXG4gICAgfVxuXG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy4kbW9kYWwubW9kYWwoJ2hpZGUnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIHJlbmRlciBmdW5jdGlvblxuICAgICAqL1xuICAgIHJlbmRlckNoaWxkcmVuKCkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xuXG4gICAgICAgIHJldHVybiBSZWFjdC5DaGlsZHJlbi5tYXAoY2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgaWYoY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge30pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8vIO2VhOyImCDtla3rqqlcbiAgICAgICAgY29uc3QgeyBjbGFzc05hbWUsIHdpZHRoIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8ZGl2IGlkPXt0aGlzLmlkfSBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ21vZGFsJywgJ2ZhZGUnLCBjbGFzc05hbWUpfSByb2xlPVwiZGlhbG9nXCIgYXJpYS1sYWJlbGxlZGJ5PVwiXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbC1kaWFsb2dcIiBzdHlsZT17e3dpZHRoOiB3aWR0aH19PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt0aGlzLnJlbmRlckNoaWxkcmVuKCl9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5cbk1vZGFsSGVhZGVyLnByb3BUeXBlcyA9IHByb3BUeXBlc01vZGFsSGVhZGVyO1xuTW9kYWxCb2R5LnByb3BUeXBlcyA9IHByb3BUeXBlc01vZGFsQm9keTtcbk1vZGFsRm9vdGVyLnByb3BUeXBlcyA9IHByb3BUeXBlc01vZGFsRm9vdGVyO1xuTW9kYWwucHJvcFR5cGVzID0gcHJvcFR5cGVzTW9kYWw7XG5Nb2RhbC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHNNb2RhbDtcblxuZXhwb3J0IHsgTW9kYWwsIE1vZGFsSGVhZGVyLCBNb2RhbEJvZHksIE1vZGFsRm9vdGVyIH07IiwiLyoqXHJcbiAqIFBhbmVsIGNvbXBvbmVudFxyXG4gKlxyXG4gKiB2ZXJzaW9uIDx0dD4kIFZlcnNpb246IDEuMCAkPC90dD4gZGF0ZToyMDE2LzAzLzMwXHJcbiAqIGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmhyYWhuQG5raWEuY28ua3JcIj5BaG4gSHl1bmctUm88L2E+XHJcbiAqXHJcbiAqIGV4YW1wbGU6XHJcbiAqIDxQdW0uUGFuZWwgIC8+XHJcbiAqXHJcbiAqIGJvb3RzdHJhcCBjb21wb25lbnRcclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcbmltcG9ydCBVdGlsIGZyb20gJy4uL3NlcnZpY2VzL1V0aWwnO1xyXG5cclxuY29uc3QgcHJvcFR5cGVzUGFuZWxIZWFkZXIgPSB7XHJcbiAgICB3aWR0aDogUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLnN0cmluZyxcclxuICAgICAgICBQcm9wVHlwZXMubnVtYmVyXHJcbiAgICBdKSxcclxuICAgIGhlaWdodDogUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLnN0cmluZyxcclxuICAgICAgICBQcm9wVHlwZXMubnVtYmVyXHJcbiAgICBdKVxyXG59O1xyXG5cclxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIFBhbmVsSGVhZGVyLiAqL1xyXG5jbGFzcyBQYW5lbEhlYWRlciBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IHByb3BzLndpZHRoLCBcclxuICAgICAgICAgICAgaGVpZ2h0OiBwcm9wcy5oZWlnaHRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xyXG4gICAgICAgIC8vIOy7tO2PrOuEjO2KuOqwgCDsg4jroZzsmrQgcHJvcHPrpbwg67Cb7J2EIOuVjCDtmLjstpwo7LWc7LSIIOugjOuNlOungSDsi5zsl5DripQg7Zi47Lac65CY7KeAIOyViuydjClcclxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG5leHRQcm9wcztcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgLy8g7ZWE7IiYIO2VreuqqVxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicGFuZWwtaGVhZGluZ1wiIHN0eWxlPXt7d2lkdGg6IHRoaXMuc3RhdGUud2lkdGgsIGhlaWdodDogdGhpcy5zdGF0ZS5oZWlnaHR9fT5cclxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicGFuZWwtdGl0bGVcIj57dGhpcy5wcm9wcy5jaGlsZHJlbn08L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgcHJvcFR5cGVzUGFuZWxCb2R5ID0ge1xyXG4gICAgd2lkdGg6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xyXG4gICAgICAgIFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICAgICAgUHJvcFR5cGVzLm51bWJlclxyXG4gICAgXSksXHJcbiAgICBoZWlnaHQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xyXG4gICAgICAgIFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICAgICAgUHJvcFR5cGVzLm51bWJlclxyXG4gICAgXSlcclxufTtcclxuXHJcbi8qKiBDbGFzcyByZXByZXNlbnRpbmcgYSBQYW5lbEJvZHkuICovXHJcbmNsYXNzIFBhbmVsQm9keSBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IHByb3BzLndpZHRoLCBcclxuICAgICAgICAgICAgaGVpZ2h0OiBwcm9wcy5oZWlnaHRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xyXG4gICAgICAgIC8vIOy7tO2PrOuEjO2KuOqwgCDsg4jroZzsmrQgcHJvcHPrpbwg67Cb7J2EIOuVjCDtmLjstpwo7LWc7LSIIOugjOuNlOungSDsi5zsl5DripQg7Zi47Lac65CY7KeAIOyViuydjClcclxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG5leHRQcm9wcztcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgLy8g7ZWE7IiYIO2VreuqqVxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicGFuZWwtYm9keVwiIHN0eWxlPXt7d2lkdGg6IHRoaXMuc3RhdGUud2lkdGgsIGhlaWdodDogdGhpcy5zdGF0ZS5oZWlnaHR9fT57dGhpcy5wcm9wcy5jaGlsZHJlbn08L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBwcm9wVHlwZXNQYW5lbEZvb3RlciA9IHtcclxuICAgIHdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgICAgIFByb3BUeXBlcy5udW1iZXJcclxuICAgIF0pLFxyXG4gICAgaGVpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgICAgIFByb3BUeXBlcy5udW1iZXJcclxuICAgIF0pXHJcbn07XHJcblxyXG4vKiogQ2xhc3MgcmVwcmVzZW50aW5nIGEgUGFuZWxGb290ZXIuICovXHJcbmNsYXNzIFBhbmVsRm9vdGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICB3aWR0aDogcHJvcHMud2lkdGgsIFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHByb3BzLmhlaWdodFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XHJcbiAgICAgICAgLy8g7Lu07Y+s64SM7Yq46rCAIOyDiOuhnOyatCBwcm9wc+ulvCDrsJvsnYQg65WMIO2YuOy2nCjstZzstIgg66CM642U66eBIOyLnOyXkOuKlCDtmLjstpzrkJjsp4Ag7JWK7J2MKVxyXG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gbmV4dFByb3BzO1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICAvLyDtlYTsiJgg7ZWt66qpXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwYW5lbC1mb290ZXJcIiBzdHlsZT17e3dpZHRoOiB0aGlzLnN0YXRlLndpZHRoLCBoZWlnaHQ6IHRoaXMuc3RhdGUuaGVpZ2h0fX0+e3RoaXMucHJvcHMuY2hpbGRyZW59PC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgcHJvcFR5cGVzUGFuZWwgPSB7XHJcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZ1xyXG59O1xyXG5cclxuY29uc3QgZGVmYXVsdFByb3BzUGFuZWwgPSB7XHJcbiAgICBjbGFzc05hbWU6ICdwYW5lbC1kZWZhdWx0J1xyXG59O1xyXG5cclxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIFBhbmVsLiAqL1xyXG5jbGFzcyBQYW5lbCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xyXG4gICAgICAgIC8vIOy1nOy0iCDroIzrjZTrp4HsnbQg7J287Ja064KY6riwIOyngeyghCjtlZzrsogg7Zi47LacKVxyXG4gICAgICAgIGxldCBpZCA9IHRoaXMucHJvcHMuaWQ7XHJcbiAgICAgICAgaWYodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZCA9IFV0aWwuZ2V0VVVJRCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIHJlbmRlciBmdW5jdGlvblxyXG4gICAgICovXHJcbiAgICByZW5kZXJDaGlsZHJlbigpIHtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLmNoaWxkcmVuO1xyXG5cclxuICAgICAgICByZXR1cm4gUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgaWYoY2hpbGQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCB7fSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblx0XHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgLy8g7ZWE7IiYIO2VreuqqVxyXG4gICAgICAgIGNvbnN0IHtjbGFzc05hbWV9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ3BhbmVsJywgY2xhc3NOYW1lKX0+e3RoaXMucmVuZGVyQ2hpbGRyZW4oKX08L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5QYW5lbEhlYWRlci5wcm9wVHlwZXMgPSBwcm9wVHlwZXNQYW5lbEhlYWRlcjtcclxuUGFuZWxCb2R5LnByb3BUeXBlcyA9IHByb3BUeXBlc1BhbmVsQm9keTtcclxuUGFuZWxGb290ZXIucHJvcFR5cGVzID0gcHJvcFR5cGVzUGFuZWxGb290ZXI7XHJcblBhbmVsLnByb3BUeXBlcyA9IHByb3BUeXBlc1BhbmVsO1xyXG5QYW5lbC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHNQYW5lbDtcclxuXHJcbmV4cG9ydCB7IFBhbmVsLCBQYW5lbEhlYWRlciwgUGFuZWxCb2R5LCBQYW5lbEZvb3RlciB9OyIsIi8qKlxyXG4gKiBUZW1wIGNvbXBvbmVudFxyXG4gKlxyXG4gKiB2ZXJzaW9uIDx0dD4kIFZlcnNpb246IDEuMCAkPC90dD4gZGF0ZToyMDE2LzEwLzI5XHJcbiAqIGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmhyYWhuQG5raWEuY28ua3JcIj5BaG4gSHl1bmctUm88L2E+XHJcbiAqXHJcbiAqIGV4YW1wbGU6XHJcbiAqIDxQdWYuQnV0dG9uIG9wdGlvbnM9e29wdGlvbnN9IC8+XHJcbiAqXHJcbiAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQgVXRpbCBmcm9tICcuLi9zZXJ2aWNlcy9VdGlsJztcclxuXHJcbmNvbnN0IHByb3BUeXBlcyA9IHtcclxuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGljb25DbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICB0b29sdGlwOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgdG9vbHRpcFBvc2l0aW9uOiBQcm9wVHlwZXMub25lT2YoWydib3R0b20nLCAndG9wJywgJ2xlZnQnLCAncmlnaHQnLCAnY2VudGVyJ10pLFxyXG4gICAgc2l6ZTogUHJvcFR5cGVzLm9uZU9mKFsnc20nLCAnbWQnLCAnbGcnXSksXHJcbiAgICB0b2dnbGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGhpZGRlbjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICB2YWx1ZTogUHJvcFR5cGVzLm9iamVjdCxcclxuICAgIG9uQ2xpY2s6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XHJcbiAgICB0eXBlOiAnYnV0dG9uJyxcclxuICAgIGNsYXNzTmFtZTogJ2J0bi1kZWZhdWx0JyxcclxuICAgIHRvZ2dsZWQ6IGZhbHNlLFxyXG4gICAgdmFsdWU6IG51bGwsXHJcbiAgICB0b29sdGlwUG9zaXRpb246ICdib3R0b20nXHJcbn07XHJcblxyXG4vKiogQ2xhc3MgcmVwcmVzZW50aW5nIGEgVG9nZ2xlQnV0dG9uLiAqL1xyXG5jbGFzcyBUb2dnbGVCdXR0b24gZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcblxyXG4gICAgICAgIC8vIHRvZ2dsZWQg7ISk7KCV7J2AIGluaXQg7Iuc7JeQ66eMIOqwgOuKpVxyXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIHRvZ2dsZWQ6IHByb3BzLnRvZ2dsZWRcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyB0aGlzLnZhbHVlID0gcHJvcHMudmFsdWU7XHJcblxyXG4gICAgICAgIC8vIE1hbnVhbGx5IGJpbmQgdGhpcyBtZXRob2QgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZS4uLlxyXG4gICAgICAgIHRoaXMub25DbGljayA9IHRoaXMub25DbGljay5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcclxuICAgICAgICAvLyDstZzstIgg66CM642U66eB7J20IOydvOyWtOuCmOq4sCDsp4HsoIQo7ZWc67KIIO2YuOy2nClcclxuICAgICAgICBsZXQgaWQgPSB0aGlzLnByb3BzLmlkO1xyXG4gICAgICAgIGlmKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWQgPSBVdGlsLmdldFVVSUQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAvLyDstZzstIgg66CM642U66eB7J20IOydvOyWtOuCnCDri6TsnYwo7ZWc67KIIO2YuOy2nClcclxuICAgICAgICB0aGlzLiR0b2dnbGVCdXR0b24gPSAkKCcjJyArIHRoaXMuaWQpO1xyXG5cclxuICAgICAgICAvLyB0b29sdGlwXHJcbiAgICAgICAgLy8gaWYodHlwZW9mIHRoaXMucHJvcHMudG9vbHRpcCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHJcbiAgICAgICAgLy8gICAgIHRoaXMudG9vbHRpcCA9IHRoaXMuJHRvZ2dsZUJ1dHRvbi5rZW5kb1Rvb2x0aXAoe1xyXG4gICAgICAgIC8vICAgICAgICAgcG9zaXRpb246IHRoaXMucHJvcHMudG9vbHRpcFBvc2l0aW9uXHJcbiAgICAgICAgLy8gICAgIH0pLmRhdGEoJ2tlbmRvVG9vbHRpcCcpO1xyXG5cclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcclxuICAgICAgICAvLyDsu7Ttj6zrhIztirjqsIAg7IOI66Gc7Jq0IHByb3Bz66W8IOuwm+ydhCDrlYwg7Zi47LacKOy1nOy0iCDroIzrjZTrp4Eg7Iuc7JeQ64qUIO2YuOy2nOuQmOyngCDslYrsnYwpXHJcbiAgICAgICAgLy8gdG9nZ2xlZCDshKTsoJXsnYAgaW5pdCDsi5zsl5Drp4wg6rCA64qlXHJcbiAgICAgICAgLy90aGlzLnNldFN0YXRlKHsgdG9nZ2xlZDogbmV4dFByb3BzLnRvZ2dsZWQgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gZXZlbnRzXHJcbiAgICBvbkNsaWNrKGUpIHtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgdG9nZ2xlZCA9IHRoaXMudG9nZ2xlKCksXHJcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uQ2xpY2sgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DbGljayhlLCB0b2dnbGVkLCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIG1ldGhvZHNcclxuICAgIHRvZ2dsZShpc0Jvb2wpIHtcclxuICAgICAgICB2YXIgdG9nZ2xlZDtcclxuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgdG9nZ2xlZCA9ICF0aGlzLnN0YXRlLnRvZ2dsZWQ7XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICB0b2dnbGVkID0gaXNCb29sO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgdG9nZ2xlZDogdG9nZ2xlZCB9KTtcclxuICAgICAgICByZXR1cm4gdG9nZ2xlZDtcclxuICAgIH1cclxuXHJcbiAgICBpc1RvZ2dsZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUudG9nZ2xlZDtcclxuICAgIH1cclxuXHJcbiAgICBzZXRWYWx1ZSh2YWwpIHtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xyXG4gICAgfVxyXG5cclxuICAgIGdldFZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIHJlbmRlciBmdW5jdGlvblxyXG4gICAgICovXHJcbiAgICByZW5kZXJJY29uKCkge1xyXG4gICAgICAgIGNvbnN0IHsgaWNvbkNsYXNzTmFtZSB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICBpZihpY29uQ2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICA8aSBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ2ZhJywgaWNvbkNsYXNzTmFtZSl9PjwvaT5cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIC8vIO2VhOyImCDtla3rqqlcclxuICAgICAgICBjb25zdCB7IGNoaWxkcmVuLCBjbGFzc05hbWUsIHRvb2x0aXAsIHNpemUsIGRpc2FibGVkLCBoaWRkZW4sIHZhbHVlIH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIOuLpOyLnCDqt7jrprTrlYzripQg7IOd7ISx7J6Q6rCAIO2YuOy2nOydtCDslYjrkJjrr4DroZxcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblxyXG4gICAgICAgIHZhciBvcHRpb25hbCA9IHt9LFxyXG4gICAgICAgICAgICBzaXplQ2xhc3NOYW1lO1xyXG5cclxuICAgICAgICAvLyBzaXplIOyymOumrFxyXG4gICAgICAgIGlmKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBzaXplQ2xhc3NOYW1lID0gJ2J0bi0nICsgc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gZGlzYWJsZWQg7LKY66asXHJcbiAgICAgICAgaWYoZGlzYWJsZWQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgb3B0aW9uYWwuZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaGlkZGVuIOyymOumrFxyXG4gICAgICAgIGlmKGhpZGRlbiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBvcHRpb25hbC5zdHlsZSA9IHsgZGlzcGxheTogJ25vbmUnIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB7J1xcdTAwQTAnfVxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxidXR0b24gaWQ9e3RoaXMuaWR9IHR5cGU9XCJidXR0b25cIiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ2J0bicsIGNsYXNzTmFtZSwgeyB0b2dnbGU6IHRoaXMuc3RhdGUudG9nZ2xlZCB9LCBzaXplQ2xhc3NOYW1lKX0gb25DbGljaz17dGhpcy5vbkNsaWNrfSBcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZT17dG9vbHRpcH1cclxuICAgICAgICAgICAgICAgICAgICB7Li4ub3B0aW9uYWx9PlxyXG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVySWNvbigpfVxyXG4gICAgICAgICAgICAgICAge2NoaWxkcmVufVxyXG4gICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5Ub2dnbGVCdXR0b24ucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xyXG5Ub2dnbGVCdXR0b24uZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVG9nZ2xlQnV0dG9uO1xyXG4iLCIvKipcclxuICogUmFkaW8gY29tcG9uZW50XHJcbiAqXHJcbiAqIHZlcnNpb24gPHR0PiQgVmVyc2lvbjogMS4wICQ8L3R0PiBkYXRlOjIwMTYvMDMvMTdcclxuICogYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86aHJhaG5AbmtpYS5jby5rclwiPkFobiBIeXVuZy1SbzwvYT5cclxuICpcclxuICogZXhhbXBsZTpcclxuICogPFB1Zi5SYWRpbyBvcHRpb25zPVwie29wdGlvbnN9XCIgLz5cclxuICpcclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcbmltcG9ydCBVdGlsIGZyb20gJy4uLy4uL3NlcnZpY2VzL1V0aWwnO1xyXG5cclxuY29uc3QgcHJvcFR5cGVzID0ge1xyXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBuYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgc2VsZWN0ZWRWYWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLnN0cmluZyxcclxuICAgICAgICBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgICAgIFByb3BUeXBlcy5ib29sLFxyXG4gICAgXSksXHJcbiAgICBkaXJlY3Rpb246IFByb3BUeXBlcy5vbmVPZihbJ2gnLCd2J10pLFxyXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xyXG4gICAgICAgIFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICAgICAgUHJvcFR5cGVzLm51bWJlcixcclxuICAgICAgICBQcm9wVHlwZXMuYm9vbCxcclxuICAgIF0pXHJcbn07XHJcblxyXG4vKiogQ2xhc3MgcmVwcmVzZW50aW5nIGEgUmFkaW8uICovXHJcbmNsYXNzIFJhZGlvIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XHJcbiAgICAgICAgLy8g7LWc7LSIIOugjOuNlOungeydtCDsnbzslrTrgpjquLAg7KeB7KCEKO2VnOuyiCDtmLjstpwpXHJcbiAgICAgICAgbGV0IGlkID0gdGhpcy5wcm9wcy5pZDtcclxuICAgICAgICBpZih0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGlkID0gVXRpbC5nZXRVVUlEKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgLy8g7LWc7LSIIOugjOuNlOungeydtCDsnbzslrTrgpwg64uk7J2MKO2VnOuyiCDtmLjstpwpXHJcbiAgICAgICAgaWYodGhpcy5wcm9wcy5kaXJlY3Rpb24gPT09ICdoJykge1xyXG4gICAgICAgICAgICBsZXQgJGRpdiA9ICQoJyMnK3RoaXMuaWQpLFxyXG4gICAgICAgICAgICAgICAgJGxhYmVsID0gJGRpdi5jaGlsZHJlbigpO1xyXG4gICAgICAgICAgICAkbGFiZWwuYWRkQ2xhc3MoJ3JhZGlvLWlubGluZScpO1xyXG4gICAgICAgICAgICAkZGl2LnJlcGxhY2VXaXRoKCRsYWJlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICAvLyDtlYTsiJgg7ZWt66qpXHJcbiAgICAgICAgY29uc3Qge2NsYXNzTmFtZSwgbmFtZSwgc2VsZWN0ZWRWYWx1ZSwgb25DaGFuZ2UsIHZhbHVlLCBjaGlsZHJlbn0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbmFsID0ge307XHJcbiAgICAgICAgaWYoc2VsZWN0ZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbmFsLmNoZWNrZWQgPSAodGhpcy5wcm9wcy52YWx1ZSA9PT0gc2VsZWN0ZWRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgaWYodHlwZW9mIG9uQ2hhbmdlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbmFsLm9uQ2hhbmdlID0gb25DaGFuZ2UuYmluZChudWxsLCB0aGlzLnByb3BzLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgKi9cclxuICAgICAgICBvcHRpb25hbC5vbkNoYW5nZSA9IG9uQ2hhbmdlLmJpbmQobnVsbCwgdGhpcy5wcm9wcy52YWx1ZSk7XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmFkaW9cIiBpZD17dGhpcy5pZH0+XHJcbiAgICAgICAgICAgICAgICA8bGFiZWw+XHJcbiAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBuYW1lPXtuYW1lfSB2YWx1ZT17dmFsdWV9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHsuLi5vcHRpb25hbH0gLz5cclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJsYmxcIj57Y2hpbGRyZW59PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuUmFkaW8ucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xyXG4vLyBSYWRpby5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBSYWRpbzsiLCIvKipcclxuICogUmFkaW9EaXZpZGVyIGNvbXBvbmVudFxyXG4gKlxyXG4gKiB2ZXJzaW9uIDx0dD4kIFZlcnNpb246IDEuMCAkPC90dD4gZGF0ZToyMDE3LzAxLzA1XHJcbiAqIGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmhyYWhuQG5raWEuY28ua3JcIj5BaG4gSHl1bmctUm88L2E+XHJcbiAqXHJcbiAqIGV4YW1wbGU6XHJcbiAqIDxQdWYuUmFkaW9EaXZpZGVyIGNsYXNzTmFtZT1cInJhZGlvLWRpdmlkZXJcIiAvPlxyXG4gKlxyXG4gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuXHJcbi8vIO2DgOyeheyytO2BrCDtlZjripTsp4Ag7ZmV7J24IO2VhOyalFxyXG5jb25zdCBwcm9wVHlwZXMgPSB7XHJcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmdcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcclxuICAgIHR5cGU6ICdSYWRpb0RpdmlkZXInXHJcbn07XHJcblxyXG4vKiogQ2xhc3MgcmVwcmVzZW50aW5nIGEgUmFkaW9EaXZpZGVyLiAqL1xyXG5jb25zdCBSYWRpb0RpdmlkZXIgPSAoeyBjbGFzc05hbWUgfSkgPT4gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoJ3JhZGlvLWRpdmlkZXInLCBjbGFzc05hbWUpfT5cclxuICAgIDwvZGl2PlxyXG4pO1xyXG5cclxuUmFkaW9EaXZpZGVyLnByb3BUeXBlcyA9IHByb3BUeXBlcztcclxuUmFkaW9EaXZpZGVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJhZGlvRGl2aWRlcjsiLCIvKipcclxuICogUmFkaW9Hcm91cCBjb21wb25lbnRcclxuICpcclxuICogdmVyc2lvbiA8dHQ+JCBWZXJzaW9uOiAxLjAgJDwvdHQ+IGRhdGU6MjAxNi8wMy8xN1xyXG4gKiBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpocmFobkBua2lhLmNvLmtyXCI+QWhuIEh5dW5nLVJvPC9hPlxyXG4gKlxyXG4gKiBleGFtcGxlOlxyXG4gKiA8UHVmLlJhZGlvR3JvdXAgb3B0aW9ucz1cIntvcHRpb25zfVwiIC8+XHJcbiAqXHJcbiAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5cclxuY29uc3QgcHJvcFR5cGVzID0ge1xyXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIHNlbGVjdGVkVmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xyXG4gICAgICAgIFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICAgICAgUHJvcFR5cGVzLm51bWJlcixcclxuICAgICAgICBQcm9wVHlwZXMuYm9vbCxcclxuICAgIF0pLFxyXG4gICAgZGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2YoWydoJywndiddKSxcclxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xyXG4gICAgZGlyZWN0aW9uOiAndidcclxufTtcclxuXHJcbi8qKiBDbGFzcyByZXByZXNlbnRpbmcgYSBSYWRpb0dyb3VwLiAqL1xyXG5jbGFzcyBSYWRpb0dyb3VwIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG5cclxuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5zZXRTdGF0ZU9iamVjdChwcm9wcyk7XHJcblxyXG4gICAgICAgIC8vIE1hbnVhbGx5IGJpbmQgdGhpcyBtZXRob2QgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZS4uLlxyXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSB0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIC8vIOy1nOy0iCDroIzrjZTrp4HsnbQg7J287Ja064KcIOuLpOydjCjtlZzrsogg7Zi47LacKVxyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2NvbXBvbmVudERpZE1vdW50Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcclxuICAgICAgICAvLyDsu7Ttj6zrhIztirjqsIAg7IOI66Gc7Jq0IHByb3Bz66W8IOuwm+ydhCDrlYwg7Zi47LacKOy1nOy0iCDroIzrjZTrp4Eg7Iuc7JeQ64qUIO2YuOy2nOuQmOyngCDslYrsnYwpXHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLnNldFN0YXRlT2JqZWN0KG5leHRQcm9wcykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGV2ZW50c1xyXG4gICAgb25DaGFuZ2UodmFsdWUsIGV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7c2VsZWN0ZWRWYWx1ZTogdmFsdWV9KTtcclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkNoYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKGV2ZW50LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgc2V0U3RhdGVPYmplY3QocHJvcHMpIHtcclxuICAgICAgICBsZXQgc2VsZWN0ZWRWYWx1ZSA9IHByb3BzLnNlbGVjdGVkVmFsdWU7XHJcbiAgICAgICAgaWYodHlwZW9mIHNlbGVjdGVkVmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZTogc2VsZWN0ZWRWYWx1ZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIHJlbmRlciBmdW5jdGlvblxyXG4gICAgICovXHJcbiAgICByZW5kZXJDaGlsZHJlbigpIHtcclxuICAgICAgICBjb25zdCB7IGNsYXNzTmFtZSwgbmFtZSwgZGlyZWN0aW9uLCBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcyxcclxuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZSA9IHRoaXMuc3RhdGUuc2VsZWN0ZWRWYWx1ZSxcclxuICAgICAgICAgICAgb25DaGFuZ2UgPSB0aGlzLm9uQ2hhbmdlO1xyXG5cclxuICAgICAgICByZXR1cm4gUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCAocmFkaW8pID0+IHtcclxuICAgICAgICAgICAgaWYocmFkaW8gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBsZXQgX2NsYXNzTmFtZSA9ICcnLCAgICAgIFxyXG4gICAgICAgICAgICAgICAgcHJvcHMgPSB7fTtcclxuICAgICAgICAgICAgaWYocmFkaW8ucHJvcHMudHlwZSA9PT0gJ1JhZGlvRGl2aWRlcicpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgcmFkaW8ucHJvcHMuY2xhc3NOYW1lICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWUgPSByYWRpby5wcm9wcy5jbGFzc05hbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBfY2xhc3NOYW1lXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIHJhZGlvLnByb3BzLmNsYXNzTmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lID0gY2xhc3NOYW1lICsgJyAnICsgcmFkaW8ucHJvcHMuY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWUgPSBjbGFzc05hbWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcHJvcHMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBfY2xhc3NOYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2VcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChyYWRpbywgcHJvcHMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICAvLyDtlYTsiJgg7ZWt66qpXHJcbiAgICAgICAgY29uc3QgeyBjbGFzc05hbWUgfSA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtjbGFzc05hbWVzKCdyYWRpby1ncm91cCcsIGNsYXNzTmFtZSl9PlxyXG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVyQ2hpbGRyZW4oKX1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuUmFkaW9Hcm91cC5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XHJcblJhZGlvR3JvdXAuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUmFkaW9Hcm91cDsiLCIvKipcclxuICogQXV0b0NvbXBsZXRlIGNvbXBvbmVudFxyXG4gKlxyXG4gKiB2ZXJzaW9uIDx0dD4kIFZlcnNpb246IDEuMCAkPC90dD4gZGF0ZToyMDE2LzA5LzA5XHJcbiAqIGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmp5dEBua2lhLmNvLmtyXCI+SnVuZyBZb3VuZy1UYWk8L2E+XHJcbiAqXHJcbiAqIGV4YW1wbGU6XHJcbiAqIDxQdWYuQXV0b0NvbXBsZXRlIG9wdGlvbnM9e29wdGlvbnN9IC8+XHJcbiAqXHJcbiAqIEtlbmRvIEF1dG9Db21wbGV0ZSDrnbzsnbTruIzrn6zrpqzsl5Ag7KKF7IaN7KCB7J2064ukLlxyXG4gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IFV0aWwgZnJvbSAnLi4vc2VydmljZXMvVXRpbCc7XHJcblxyXG5jb25zdCBwcm9wVHlwZXMgPSB7XHJcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBob3N0OiBQcm9wVHlwZXMuc3RyaW5nLCAvLyDshJzrsoQg7KCV67O0KENyb3NzIEJyb3dzZXIgQWNjZXNzKVxyXG4gICAgdXJsOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgbWV0aG9kOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgZGF0YTogUHJvcFR5cGVzLm9iamVjdCxcclxuICAgIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgZGF0YVNvdXJjZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLmFycmF5LFxyXG4gICAgICAgIFByb3BUeXBlcy5vYmplY3RcclxuICAgIF0pLFxyXG4gICAgdGVtcGxhdGU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBmaWx0ZXI6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBzZXBhcmF0b3I6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBtaW5MZW5ndGg6IFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICBkYXRhVGV4dEZpZWxkOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgcGFyYW1ldGVyTWFwRmllbGQ6IFByb3BUeXBlcy5vYmplY3QgIC8vIFBhcmFtZXRlciBDb250cm9sIOqwneyytCjtlYTthLDsspjrpqwpXHJcbn1cclxuXHJcbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcclxuICAgIG1ldGhvZDogJ1BPU1QnLCBcclxuICAgIGxpc3RGaWVsZDogJ3Jlc3VsdFZhbHVlLmxpc3QnLCBcclxuICAgIHRvdGFsRmllbGQ6ICdyZXN1bHRWYWx1ZS50b3RhbENvdW50JywgXHJcbiAgICBwbGFjZWhvbGRlcjogJHBzX2xvY2FsZS5hdXRvQ29tcGxldGUsIFxyXG4gICAgZmlsdGVyOiBcInN0YXJ0c3dpdGhcIiwgXHJcbiAgICBzZXBhcmF0b3I6IFwiLCBcIiwgXHJcbiAgICB0ZW1wbGF0ZTogbnVsbCwgXHJcbiAgICBkYXRhVGV4dEZpZWxkOiBudWxsLFxyXG4gICAgbWluTGVuZ3RoOiAxXHJcbn07XHJcblxyXG4vKiogQ2xhc3MgcmVwcmVzZW50aW5nIGEgQXV0b0NvbXBsZXRlLiAqL1xyXG5jbGFzcyBBdXRvQ29tcGxldGUgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgLy8gT3BlcmF0aW9ucyB1c3VhbGx5IGNhcnJpZWQgb3V0IGluIGNvbXBvbmVudFdpbGxNb3VudCBnbyBoZXJlXHJcbiAgICAgICAgbGV0IGlkID0gcHJvcHMuaWQ7XHJcbiAgICAgICAgaWYodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZCA9IFV0aWwuZ2V0VVVJRCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIC8vIOy1nOy0iCDroIzrjZTrp4HsnbQg7J287Ja064KcIOuLpOydjCjtlZzrsogg7Zi47LacKVxyXG4gICAgICAgIHRoaXMuJGF1dG9Db21wbGV0ZSA9ICQoJyMnK3RoaXMuaWQpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5vcHRpb25zKHRoaXMucHJvcHMpKTtcclxuICAgICAgICB0aGlzLmF1dG9Db21wbGV0ZSA9IHRoaXMuJGF1dG9Db21wbGV0ZS5rZW5kb0F1dG9Db21wbGV0ZSh0aGlzLm9wdGlvbnModGhpcy5wcm9wcykpO1xyXG4gICAgfVxyXG5cdFxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBvcHRpb25zKHByb3BzKSB7XHJcbiAgICAgICAgY29uc3Qge3BsYWNlaG9sZGVyLCB0ZW1wbGF0ZSwgZGF0YVRleHRGaWVsZCwgbWluTGVuZ3RoLCBzZXBhcmF0b3J9ID0gcHJvcHM7XHJcbiAgICAgICAgdmFyIGRhdGFTb3VyY2UgPSB0aGlzLmdldERhdGFTb3VyY2UocHJvcHMpO1xyXG5cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLFxyXG4gICAgICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICAgICAgICAgIGRhdGFTb3VyY2U6IGRhdGFTb3VyY2UsXHJcbiAgICAgICAgICAgIGRhdGFUZXh0RmllbGQ6IGRhdGFUZXh0RmllbGQsXHJcbiAgICAgICAgICAgIG1pbkxlbmd0aDogbWluTGVuZ3RoLFxyXG4gICAgICAgICAgICBzZXBhcmF0b3I6IHNlcGFyYXRvclxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXREYXRhU291cmNlKHByb3BzKSB7XHJcbiAgICAgICAgY29uc3Qge2hvc3QsIHVybCwgbWV0aG9kLCBkYXRhLCBsaXN0RmllbGQsIHRvdGFsRmllbGQsIHBhcmFtZXRlck1hcEZpZWxkfSA9IHByb3BzO1xyXG5cclxuICAgICAgICBsZXQgZGF0YVNvdXJjZSA9IG5ldyBrZW5kby5kYXRhLkRhdGFTb3VyY2Uoe1xyXG4gICAgICAgICAgICB0cmFuc3BvcnQ6IHtcclxuICAgICAgICAgICAgICAgIHJlYWQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB1cmw6IChob3N0ICYmIGhvc3QgIT09IG51bGwgJiYgaG9zdC5sZW5ndGggPiAwKSA/IGhvc3QgKyB1cmwgOiB1cmwsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSwgICAgICAvLyBzZWFyY2ggKEBSZXF1ZXN0Qm9keSBHcmlkUGFyYW0gZ3JpZFBhcmFtIOuhnCDrsJvripTri6QuKVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOCdcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJNYXA6IGZ1bmN0aW9uKGRhdGEsIHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZih0eXBlID09IFwicmVhZFwiICYmIHBhcmFtZXRlck1hcEZpZWxkICE9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsdGVyIEFycmF5ID0+IEpzb24gT2JqZWN0IENvcHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocGFyYW1ldGVyTWFwRmllbGQuZmlsdGVyc1RvSnNvbiAmJiBkYXRhLmZpbHRlciAmJiBkYXRhLmZpbHRlci5maWx0ZXJzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJzID0gZGF0YS5maWx0ZXIuZmlsdGVycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcnMubWFwKChmaWx0ZXIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3BhcmFtZXRlck1hcEZpZWxkLnNlYXJjaEZpZWxkXSA9IGZpbHRlci52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2NoZW1hOiB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5lZCBpbiB0aGUgXCJsaXN0RmllbGRcIiBmaWVsZCBvZiB0aGUgcmVzcG9uc2VcclxuICAgICAgICAgICAgICAgIGRhdGE6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyciA9IFtdLCBncmlkTGlzdCA9IHJlc3BvbnNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihsaXN0RmllbGQgJiYgbGlzdEZpZWxkLmxlbmd0aCA+IDAgJiYgbGlzdEZpZWxkICE9ICdudWxsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIgPSBsaXN0RmllbGQuc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpIGluIGFycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGFycltpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFncmlkTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZExpc3QgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRMaXN0ID0gZ3JpZExpc3RbYXJyW2ldXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyaWRMaXN0O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybmVkIGluIHRoZSBcInRvdGFsRmllbGRcIiBmaWVsZCBvZiB0aGUgcmVzcG9uc2VcclxuICAgICAgICAgICAgICAgIHRvdGFsOiBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnIgPSBbXSwgdG90YWwgPSByZXNwb25zZTtcclxuICAgICAgICAgICAgICAgICAgICBpZih0b3RhbEZpZWxkICYmIHRvdGFsRmllbGQubGVuZ3RoID4gMCAmJiB0b3RhbEZpZWxkICE9ICdudWxsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIgPSB0b3RhbEZpZWxkLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSBpbiBhcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhhcnJbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighdG90YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsID0gdG90YWxbYXJyW2ldXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvdGFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXJ2ZXJGaWx0ZXJpbmc6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZGF0YVNvdXJjZTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIC8vIO2VhOyImCDtla3rqqlcclxuICAgICAgICB2YXIgaW5wdXRTdHlsZSA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IFwiMTAwJVwiXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB7IG5hbWUsIGNsYXNzTmFtZSB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8aW5wdXQgaWQ9e3RoaXMuaWR9IG5hbWU9e25hbWV9IGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhjbGFzc05hbWUpfSBzdHlsZT17aW5wdXRTdHlsZX0gLz5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5BdXRvQ29tcGxldGUucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xyXG5BdXRvQ29tcGxldGUuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQXV0b0NvbXBsZXRlO1xyXG4iLCIvKipcclxuICogRGF0ZVBpY2tlciBjb21wb25lbnRcclxuICpcclxuICogdmVyc2lvbiA8dHQ+JCBWZXJzaW9uOiAxLjAgJDwvdHQ+IGRhdGU6MjAxNi8wNi8wNVxyXG4gKiBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpocmFobkBua2lhLmNvLmtyXCI+QWhuIEh5dW5nLVJvPC9hPlxyXG4gKlxyXG4gKiBleGFtcGxlOlxyXG4gKiA8UHVmLkRhdGVQaWNrZXIgb3B0aW9ucz17b3B0aW9uc30gLz5cclxuICpcclxuICogS2VuZG8gRGF0ZVBpY2tlciDrnbzsnbTruIzrn6zrpqzsl5Ag7KKF7IaN7KCB7J2064ukLlxyXG4gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IFV0aWwgZnJvbSAnLi4vc2VydmljZXMvVXRpbCc7XHJcbmltcG9ydCBEYXRlVXRpbCBmcm9tICcuLi9zZXJ2aWNlcy9EYXRlVXRpbCc7XHJcblxyXG5jb25zdCBwcm9wVHlwZXMgPSB7XHJcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBkYXRlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMuc3RyaW5nLCAgICAgICAgICAgICAgIC8vIFlZWVktTU0tREQgSEg6bW06c3MgZm9ybWF07J2YIHN0cmluZ1xyXG4gICAgICAgIFByb3BUeXBlcy5vYmplY3QgICAgICAgICAgICAgICAgLy8gRGF0ZVxyXG4gICAgXSksXHJcbiAgICBtaW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xyXG4gICAgICAgIFByb3BUeXBlcy5zdHJpbmcsICAgICAgICAgICAgICAgLy8gWVlZWS1NTS1ERCBISDptbTpzcyBmb3JtYXTsnZggc3RyaW5nXHJcbiAgICAgICAgUHJvcFR5cGVzLm9iamVjdCAgICAgICAgICAgICAgICAvLyBEYXRlXHJcbiAgICBdKSxcclxuICAgIG1heDogUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLnN0cmluZywgICAgICAgICAgICAgICAvLyBZWVlZLU1NLUREIEhIOm1tOnNzIGZvcm1hdOydmCBzdHJpbmdcclxuICAgICAgICBQcm9wVHlwZXMub2JqZWN0ICAgICAgICAgICAgICAgIC8vIERhdGVcclxuICAgIF0pLFxyXG4gICAgdGltZVBpY2tlcjogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBpbnRlcnZhbDogUHJvcFR5cGVzLm51bWJlcixcclxuICAgIHdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgICAgIFByb3BUeXBlcy5udW1iZXJcclxuICAgIF0pLFxyXG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgcmVhZE9ubHk6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25DbG9zZTogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICBvbk9wZW46IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgaW5pdDogUHJvcFR5cGVzLmZ1bmNcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcclxuICAgIGRpc2FibGVkOiBmYWxzZVxyXG59O1xyXG5cclxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIERhdGVQaWNrZXIuICovXHJcbmNsYXNzIERhdGVQaWNrZXIgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgLy8gT3BlcmF0aW9ucyB1c3VhbGx5IGNhcnJpZWQgb3V0IGluIGNvbXBvbmVudFdpbGxNb3VudCBnbyBoZXJlXHJcbiAgICAgICAgbGV0IGlkID0gcHJvcHMuaWQ7XHJcbiAgICAgICAgaWYodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZCA9IFV0aWwuZ2V0VVVJRCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cclxuICAgICAgICAvLyBNYW51YWxseSBiaW5kIHRoaXMgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuLi5cclxuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gdGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25DbG9zZSA9IHRoaXMub25DbG9zZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25PcGVuID0gdGhpcy5vbk9wZW4uYmluZCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAvLyDstZzstIgg66CM642U66eB7J20IOydvOyWtOuCnCDri6TsnYwo7ZWc67KIIO2YuOy2nClcclxuICAgICAgICB0aGlzLiRkYXRlUGlja2VyID0gJCgnIycrdGhpcy5pZCk7XHJcblxyXG4gICAgICAgIGlmKHRoaXMucHJvcHMudGltZVBpY2tlciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVQaWNrZXIgPSB0aGlzLiRkYXRlUGlja2VyLmtlbmRvRGF0ZVRpbWVQaWNrZXIodGhpcy5vcHRpb25zKCkpLmRhdGEoJ2tlbmRvRGF0ZVRpbWVQaWNrZXInKTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZVBpY2tlciA9IHRoaXMuJGRhdGVQaWNrZXIua2VuZG9EYXRlUGlja2VyKHRoaXMub3B0aW9ucygpKS5kYXRhKCdrZW5kb0RhdGVQaWNrZXInKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERhdGVSYW5nZVBpY2tlciDsl5DshJwgZGF0YS5kYXRlUGlja2VyIOydhCDsgqzsmqntlahcclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0ge307XHJcbiAgICAgICAgICAgIGRhdGEuJGRhdGVQaWNrZXIgPSB0aGlzLiRkYXRlUGlja2VyO1xyXG4gICAgICAgICAgICBkYXRhLmRhdGVQaWNrZXIgPSB0aGlzLmRhdGVQaWNrZXI7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMuaW5pdChkYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRpc2FibGVkXHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlKCF0aGlzLnByb3BzLmRpc2FibGVkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlYWRPbmx5XHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMucmVhZE9ubHkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVhZE9ubHkodGhpcy5wcm9wcy5yZWFkT25seSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XHJcbiAgICAgICAgLy8g7Lu07Y+s64SM7Yq46rCAIOyDiOuhnOyatCBwcm9wc+ulvCDrsJvsnYQg65WMIO2YuOy2nCjstZzstIgg66CM642U66eBIOyLnOyXkOuKlCDtmLjstpzrkJjsp4Ag7JWK7J2MKVxyXG4gICAgICAgIC8vdGhpcy5zZXRTdGF0ZSh0aGlzLnNldFN0YXRlT2JqZWN0KG5leHRQcm9wcykpO1xyXG4gICAgICAgIHRoaXMuc2V0RGF0ZShuZXh0UHJvcHMuZGF0ZSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gZGlzYWJsZWRcclxuICAgICAgICBpZih0eXBlb2YgbmV4dFByb3BzLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLmVuYWJsZSghbmV4dFByb3BzLmRpc2FibGVkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlYWRPbmx5XHJcbiAgICAgICAgaWYodHlwZW9mIG5leHRQcm9wcy5yZWFkT25seSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWFkT25seShuZXh0UHJvcHMucmVhZE9ubHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIG9wdGlvbnMoKSB7XHJcbiAgICAgICAgY29uc3Qge2RhdGUsIHRpbWVQaWNrZXIsIG1pbiwgbWF4fSA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgIHZhciBkYXRlVmFsdWU7XHJcbiAgICAgICAgaWYodHlwZW9mIGRhdGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGRhdGVWYWx1ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgfWVsc2UgaWYodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkYXRlLmdldE1vbnRoID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGRhdGVWYWx1ZSA9IGRhdGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgZm9ybWF0ID0gJ3l5eXktTU0tZGQnLFxyXG4gICAgICAgICAgICB0aW1lT3B0aW9ucztcclxuICAgICAgICBpZih0aW1lUGlja2VyID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdCA9ICd5eXl5LU1NLWRkIEhIOm1tJztcclxuICAgICAgICAgICAgdGltZU9wdGlvbnMgPSB0aGlzLmdldFRpbWVPcHRpb25zKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgdmFsdWU6IGRhdGVWYWx1ZSxcclxuICAgICAgICAgICAgZm9ybWF0OiBmb3JtYXQsXHJcbiAgICAgICAgICAgIGN1bHR1cmU6ICdrby1LUicsICAgICAgIC8vIGh0dHA6Ly9kb2NzLnRlbGVyaWsuY29tL2tlbmRvLXVpL2ZyYW1ld29yay9nbG9iYWxpemF0aW9uL292ZXJ2aWV3XHJcbiAgICAgICAgICAgIGNoYW5nZTogdGhpcy5vbkNoYW5nZSxcclxuICAgICAgICAgICAgY2xvc2U6IHRoaXMub25DbG9zZSxcclxuICAgICAgICAgICAgb3BlbjogdGhpcy5vbk9wZW5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB0aW1lT3B0aW9ucyk7XHJcblxyXG4gICAgICAgIC8vIG1pblxyXG4gICAgICAgIGlmKHR5cGVvZiBtaW4gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKG9wdGlvbnMsIHttaW46IG1pbn0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbWF4XHJcbiAgICAgICAgaWYodHlwZW9mIG1heCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQob3B0aW9ucywge21heDogbWF4fSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRUaW1lT3B0aW9ucygpIHtcclxuICAgICAgICBjb25zdCB7aW50ZXJ2YWx9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICAgICAgdmFyIGludGVydmFsVmFsdWU7XHJcbiAgICAgICAgaWYodHlwZW9mIGludGVydmFsID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpbnRlcnZhbFZhbHVlID0gNTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIGludGVydmFsVmFsdWUgPSBpbnRlcnZhbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRpbWVGb3JtYXQ6ICdISDptbScsXHJcbiAgICAgICAgICAgIGludGVydmFsOiBpbnRlcnZhbFZhbHVlXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIG1ldGhvZHNcclxuICAgIG9wZW4oKSB7XHJcbiAgICAgICAgdGhpcy5kYXRlUGlja2VyLm9wZW4oKTtcclxuICAgIH1cclxuXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICB0aGlzLmRhdGVQaWNrZXIuY2xvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXREYXRlKCkge1xyXG4gICAgICAgIHZhciBkYXRlID0gdGhpcy5kYXRlUGlja2VyLnZhbHVlKCk7IC8vIERhdGUg6rCd7LK0IOumrO2EtO2VqFxyXG4gICAgICAgIC8vY29uc29sZS5sb2coZGF0ZSk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0eXBlb2YgZGF0ZSk7XHJcbiAgICAgICAgcmV0dXJuIERhdGVVdGlsLmdldERhdGVUb1N0cmluZyhkYXRlKTsgICAgLy8gWVlZWS1NTS1ERCBISDptbTpzcyBmb3JtYXTsnZggc3RyaW5nXHJcbiAgICB9XHJcblxyXG4gICAgc2V0RGF0ZShkYXRlKSB7XHJcbiAgICAgICAgLypcclxuICAgICAgICBpZih0eXBlb2YgZGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRlUGlja2VyLnZhbHVlKG5ldyBEYXRlKCkpO1xyXG4gICAgICAgIH1lbHNlIGlmKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGF0ZS5nZXRNb250aCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvLyBZWVlZLU1NLUREIEhIOm1tOnNzIGZvcm1hdOydmCBzdHJpbmdcclxuICAgICAgICAgICAgdGhpcy5kYXRlUGlja2VyLnZhbHVlKGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAqL1xyXG4gICAgICAgIC8vIFlZWVktTU0tREQgSEg6bW06c3MgZm9ybWF07J2YIHN0cmluZ1xyXG4gICAgICAgIGlmKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGF0ZS5nZXRNb250aCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVQaWNrZXIudmFsdWUoZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgICBlbmFibGUoaXNCb29sKSB7XHJcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZVBpY2tlci5lbmFibGUoKTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZVBpY2tlci5lbmFibGUoaXNCb29sKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVhZE9ubHkoaXNCb29sKSB7XHJcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZVBpY2tlci5yZWFkb25seSgpO1xyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRlUGlja2VyLnJlYWRvbmx5KGlzQm9vbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG1pbihkYXRlKSB7XHJcbiAgICAgICAgaWYodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkYXRlLmdldE1vbnRoID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZVBpY2tlci5taW4oZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG1heChkYXRlKSB7XHJcbiAgICAgICAgaWYodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkYXRlLmdldE1vbnRoID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZVBpY2tlci5tYXgoZGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGV2ZW50c1xyXG4gICAgb25DaGFuZ2UoZSkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ29uQ2hhbmdlJyk7XHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMub25DaGFuZ2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGUgPSB0aGlzLmdldERhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShkYXRlKTtcclxuXHJcbiAgICAgICAgICAgIC8vZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25DbG9zZShlKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnb25DbG9zZScpO1xyXG4gICAgICAgIC8vZS5wcmV2ZW50RGVmYXVsdCgpOyAvL3ByZXZlbnQgcG9wdXAgY2xvc2luZ1xyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uQ2xvc2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNsb3NlKGUpO1xyXG5cclxuICAgICAgICAgICAgLy9ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbk9wZW4oZSkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ29uT3BlbicpO1xyXG4gICAgICAgIC8vZS5wcmV2ZW50RGVmYXVsdCgpOyAvL3ByZXZlbnQgcG9wdXAgb3BlbmluZ1xyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uT3BlbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uT3BlbihlKTtcclxuXHJcbiAgICAgICAgICAgIC8vZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgLy8g7ZWE7IiYIO2VreuqqVxyXG4gICAgICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBuYW1lLCB3aWR0aCB9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGlucHV0IGlkPXt0aGlzLmlkfSBjbGFzc05hbWU9e2NsYXNzTmFtZXMoY2xhc3NOYW1lKX0gbmFtZT17bmFtZX0gc3R5bGU9e3sgd2lkdGg6IHdpZHRoIH19IC8+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuRGF0ZVBpY2tlci5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XHJcbkRhdGVQaWNrZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRGF0ZVBpY2tlcjsiLCIvKipcbiAqIERhdGVSYW5nZVBpY2tlciBjb21wb25lbnRcbiAqXG4gKiB2ZXJzaW9uIDx0dD4kIFZlcnNpb246IDEuMCAkPC90dD4gZGF0ZToyMDE2LzA2LzA1XG4gKiBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpocmFobkBua2lhLmNvLmtyXCI+QWhuIEh5dW5nLVJvPC9hPlxuICpcbiAqIGV4YW1wbGU6XG4gKiA8UHVmLkRhdGVSYW5nZVBpY2tlciBvcHRpb25zPXtvcHRpb25zfSAvPlxuICpcbiAqIEtlbmRvIERhdGVQaWNrZXIg65287J2067iM65+s66as7JeQIOyiheyGjeyggeydtOuLpC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcbmltcG9ydCBVdGlsIGZyb20gJy4uL3NlcnZpY2VzL1V0aWwnO1xuaW1wb3J0IERhdGVVdGlsIGZyb20gJy4uL3NlcnZpY2VzL0RhdGVVdGlsJztcblxuY29uc3QgcHJvcFR5cGVzID0ge1xuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBzdGFydE5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgZW5kTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBzdGFydERhdGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xuICAgICAgICBQcm9wVHlwZXMuc3RyaW5nLCAgICAgICAgICAgICAgIC8vIFlZWVktTU0tREQgSEg6bW06c3MgZm9ybWF07J2YIHN0cmluZ1xuICAgICAgICBQcm9wVHlwZXMub2JqZWN0ICAgICAgICAgICAgICAgIC8vIERhdGVcbiAgICBdKSxcbiAgICBlbmREYXRlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgICAgUHJvcFR5cGVzLnN0cmluZywgICAgICAgICAgICAgICAvLyBZWVlZLU1NLUREIEhIOm1tOnNzIGZvcm1hdOydmCBzdHJpbmdcbiAgICAgICAgUHJvcFR5cGVzLm9iamVjdCAgICAgICAgICAgICAgICAvLyBEYXRlXG4gICAgXSksXG4gICAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICAgIHJlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcbiAgICB0aW1lUGlja2VyOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG4gICAgaW5pdDogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgICBzdGFydE5hbWU6ICdzdGFydERhdGUnLCBcbiAgICBlbmROYW1lOiAnZW5kRGF0ZScsXG4gICAgc3RhcnREYXRlOiBEYXRlVXRpbC5nZXRMYXN0RGF0ZShuZXcgRGF0ZSgpLCAyNCksXG4gICAgZW5kRGF0ZTogbmV3IERhdGUoKVxufTtcblxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIERhdGVSYW5nZVBpY2tlci4gKi9cbmNsYXNzIERhdGVSYW5nZVBpY2tlciBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuXG4gICAgICAgIC8vIGdldEluaXRpYWxTdGF0ZSAoc3RhdGUg7LSI6riw7ZmUKVxuICAgICAgICAvLyB0aGlzLnN0YXRlID0gdGhpcy5zZXRTdGF0ZU9iamVjdCh0aGlzLnByb3BzKTtcblxuICAgICAgICAvLyBNYW51YWxseSBiaW5kIHRoaXMgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuLi5cbiAgICAgICAgdGhpcy5vblN0YXJ0SW5pdCA9IHRoaXMub25TdGFydEluaXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkVuZEluaXQgPSB0aGlzLm9uRW5kSW5pdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uU3RhcnRDaGFuZ2UgPSB0aGlzLm9uU3RhcnRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbkVuZENoYW5nZSA9IHRoaXMub25FbmRDaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgICAgIC8vIOy1nOy0iCDroIzrjZTrp4HsnbQg7J287Ja064KY6riwIOyngeyghCjtlZzrsogg7Zi47LacKVxuICAgICAgICBsZXQgaWQgPSB0aGlzLnByb3BzLmlkO1xuICAgICAgICBpZih0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBpZCA9IFV0aWwuZ2V0VVVJRCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgIH1cblxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICAvLyDstZzstIgg66CM642U66eB7J20IOydvOyWtOuCnCDri6TsnYwo7ZWc67KIIO2YuOy2nClcbiAgICAgICAgdGhpcy5zdGFydFBpY2tlci5tYXgodGhpcy5lbmRQaWNrZXIudmFsdWUoKSk7XG4gICAgICAgIHRoaXMuZW5kUGlja2VyLm1pbih0aGlzLnN0YXJ0UGlja2VyLnZhbHVlKCkpO1xuXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLmluaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgICAgICBkYXRhLnN0YXJ0UGlja2VyID0gdGhpcy5zdGFydFBpY2tlcjtcbiAgICAgICAgICAgIGRhdGEuZW5kUGlja2VyID0gdGhpcy5lbmRQaWNrZXI7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmluaXQoZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIC8vICAgICAvLyDsu7Ttj6zrhIztirjqsIAg7IOI66Gc7Jq0IHByb3Bz66W8IOuwm+ydhCDrlYwg7Zi47LacKOy1nOy0iCDroIzrjZTrp4Eg7Iuc7JeQ64qUIO2YuOy2nOuQmOyngCDslYrsnYwpXG4gICAgLy8gICAgIHRoaXMuc2V0U3RhdGUodGhpcy5zZXRTdGF0ZU9iamVjdChuZXh0UHJvcHMpKTtcbiAgICAvLyB9XG5cbiAgICAvLyBzZXRTdGF0ZU9iamVjdChwcm9wcykge1xuXG4gICAgLy8gICAgIC8vIGVuZERhdGUg7LKY66asXG4gICAgLy8gICAgIGxldCBlbmREYXRlID0gcHJvcHMuZW5kRGF0ZSA/IHByb3BzLmVuZERhdGUgOiBuZXcgRGF0ZSgpO1xuXG4gICAgLy8gICAgIC8vIHN0YXJ0RGF0ZSDsspjrpqxcbiAgICAvLyAgICAgbGV0IHN0YXJ0RGF0ZSA9IHByb3BzLnN0YXJ0RGF0ZSA/IHByb3BzLnN0YXJ0RGF0ZSA6IERhdGVVdGlsLmdldExhc3REYXRlKGVuZERhdGUsIDI0KTtcbiAgICAgICAgXG4gICAgLy8gICAgIC8vIGRpc2FibGVkIOyymOumrFxuICAgIC8vICAgICBsZXQgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZDtcbiAgICAvLyAgICAgaWYodHlwZW9mIGRpc2FibGVkID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vICAgICAgICAgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAvLyAgICAgfVxuXG4gICAgLy8gICAgIHJldHVybiB7XG4gICAgLy8gICAgICAgICBzdGFydERhdGU6IHN0YXJ0RGF0ZSxcbiAgICAvLyAgICAgICAgIGVuZERhdGU6IGVuZERhdGUsXG4gICAgLy8gICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWRcbiAgICAvLyAgICAgfTtcbiAgICAvLyB9XG4gICAgXG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gbWV0aG9kc1xuICAgIGdldFN0YXJ0RGF0ZShpc0RhdGUgPSBmYWxzZSkge1xuICAgICAgICB2YXIgZGF0ZSA9IHRoaXMuc3RhcnRQaWNrZXIudmFsdWUoKTsgICAgICAgICAgICAvLyBEYXRlIOqwneyytCDrpqzthLTtlahcbiAgICAgICAgLy9jb25zb2xlLmxvZyhkYXRlKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0eXBlb2YgZGF0ZSk7XG4gICAgICAgIGlmKGlzRGF0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlVXRpbC5nZXREYXRlVG9TdHJpbmcoZGF0ZSk7ICAgICAgLy8gWVlZWS1NTS1ERCBISDptbTpzcyBmb3JtYXTsnZggc3RyaW5nXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuXG4gICAgZ2V0RW5kRGF0ZShpc0RhdGUgPSBmYWxzZSkge1xuICAgICAgICB2YXIgZGF0ZSA9IHRoaXMuZW5kUGlja2VyLnZhbHVlKCk7ICAgICAgICAgICAgICAvLyBEYXRlIOqwneyytCDrpqzthLTtlahcblxuICAgICAgICBpZihpc0RhdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZVV0aWwuZ2V0RGF0ZVRvU3RyaW5nKGRhdGUpOyAgICAgIC8vIFlZWVktTU0tREQgSEg6bW06c3MgZm9ybWF07J2YIHN0cmluZ1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0U3RhcnREYXRlKGRhdGUpIHtcbiAgICAgICAgLy8gWVlZWS1NTS1ERCBISDptbTpzcyBmb3JtYXTsnZggc3RyaW5nXG4gICAgICAgIGlmKHR5cGVvZiBkYXRlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGF0ZS5nZXRNb250aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5zdGFydFBpY2tlci52YWx1ZShkYXRlKTtcbiAgICAgICAgICAgIHRoaXMub25TdGFydENoYW5nZShkYXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldEVuZERhdGUoZGF0ZSkge1xuICAgICAgICAvLyBZWVlZLU1NLUREIEhIOm1tOnNzIGZvcm1hdOydmCBzdHJpbmdcbiAgICAgICAgaWYodHlwZW9mIGRhdGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBkYXRlLmdldE1vbnRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmVuZFBpY2tlci52YWx1ZShkYXRlKTtcbiAgICAgICAgICAgIHRoaXMub25FbmRDaGFuZ2UoZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbmFibGUoaXNCb29sKSB7XG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFBpY2tlci5lbmFibGUoKTtcbiAgICAgICAgICAgIHRoaXMuZW5kUGlja2VyLmVuYWJsZSgpO1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UGlja2VyLmVuYWJsZShpc0Jvb2wpO1xuICAgICAgICAgICAgdGhpcy5lbmRQaWNrZXIuZW5hYmxlKGlzQm9vbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWFkT25seShpc0Jvb2wpIHtcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UGlja2VyLnJlYWRPbmx5KCk7XG4gICAgICAgICAgICB0aGlzLmVuZFBpY2tlci5yZWFkT25seSgpO1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UGlja2VyLnJlYWRPbmx5KGlzQm9vbCk7XG4gICAgICAgICAgICB0aGlzLmVuZFBpY2tlci5yZWFkT25seShpc0Jvb2wpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIGV2ZW50c1xuICAgIG9uU3RhcnRJbml0KGRhdGEpIHtcbiAgICAgICAgdGhpcy5zdGFydFBpY2tlciA9IGRhdGEuZGF0ZVBpY2tlcjtcbiAgICB9XG5cbiAgICBvbkVuZEluaXQoZGF0YSkge1xuICAgICAgICB0aGlzLmVuZFBpY2tlciA9IGRhdGEuZGF0ZVBpY2tlcjtcbiAgICB9XG5cbiAgICBvblN0YXJ0Q2hhbmdlKGRhdGUpIHtcbiAgICAgICAgdGhpcy5lbmRQaWNrZXIubWluKGRhdGUpO1xuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkNoYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSh0aGlzLmdldFN0YXJ0RGF0ZSgpLCB0aGlzLmdldEVuZERhdGUoKSk7XG4gICAgICAgICAgICAvL2V2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIC8vdmFyIHN0YXJ0RGF0ZSA9IHRoaXMuc3RhcnRQaWNrZXIudmFsdWUoKSxcbiAgICAgICAgLy8gICAgZW5kRGF0ZSA9IHRoaXMuZW5kUGlja2VyLnZhbHVlKCk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vaWYgKHN0YXJ0RGF0ZSkge1xuICAgICAgICAvLyAgICB0aGlzLmVuZFBpY2tlci5taW4oc3RhcnREYXRlKTtcbiAgICAgICAgLy99IGVsc2UgaWYgKGVuZERhdGUpIHtcbiAgICAgICAgLy8gICAgdGhpcy5zdGFydFBpY2tlci5tYXgoZW5kRGF0ZSk7XG4gICAgICAgIC8vfSBlbHNlIHtcbiAgICAgICAgLy8gICAgZW5kRGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIC8vICAgIHN0YXJ0Lm1heChlbmREYXRlKTtcbiAgICAgICAgLy8gICAgZW5kLm1pbihlbmREYXRlKTtcbiAgICAgICAgLy99XG4gICAgfVxuXG4gICAgb25FbmRDaGFuZ2UoZGF0ZSkge1xuICAgICAgICB0aGlzLnN0YXJ0UGlja2VyLm1heChkYXRlKTtcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMub25DaGFuZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UodGhpcy5nZXRTdGFydERhdGUoKSwgdGhpcy5nZXRFbmREYXRlKCkpO1xuICAgICAgICAgICAgLy9ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8vIO2VhOyImCDtla3rqqlcbiAgICAgICAgY29uc3QgeyBjbGFzc05hbWUsIHN0YXJ0TmFtZSwgZW5kTmFtZSwgdGltZVBpY2tlciwgc3RhcnREYXRlLCBlbmREYXRlLCBkaXNhYmxlZCwgcmVhZE9ubHkgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIC8vIGNvbnN0IHtzdGFydERhdGUsIGVuZERhdGUsIGRpc2FibGVkfSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGF0ZXBpY2tlci1ncm91cFwiPlxuICAgICAgICAgICAgICAgIDxQdWYuRGF0ZVBpY2tlciBjbGFzc05hbWU9e2NsYXNzTmFtZX0gbmFtZT17c3RhcnROYW1lfSBkYXRlPXtzdGFydERhdGV9IGluaXQ9e3RoaXMub25TdGFydEluaXR9IG9uQ2hhbmdlPXt0aGlzLm9uU3RhcnRDaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVQaWNrZXI9e3RpbWVQaWNrZXJ9IGRpc2FibGVkPXtkaXNhYmxlZH0gcmVhZE9ubHk9e3JlYWRPbmx5fSAvPnsnXFx1MDBBMCd9XG4gICAgICAgICAgICAgICAgPFB1Zi5EYXRlUGlja2VyIGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBuYW1lPXtlbmROYW1lfSBkYXRlPXtlbmREYXRlfSBpbml0PXt0aGlzLm9uRW5kSW5pdH0gb25DaGFuZ2U9e3RoaXMub25FbmRDaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVQaWNrZXI9e3RpbWVQaWNrZXJ9IGRpc2FibGVkPXtkaXNhYmxlZH0gcmVhZE9ubHk9e3JlYWRPbmx5fSAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICk7XG4gICAgfVxufVxuXG5EYXRlUmFuZ2VQaWNrZXIucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuRGF0ZVJhbmdlUGlja2VyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcblxuZXhwb3J0IGRlZmF1bHQgRGF0ZVJhbmdlUGlja2VyOyIsIi8qKlxyXG4gKiBEcm9wRG93bkxpc3QgY29tcG9uZW50XHJcbiAqXHJcbiAqIHZlcnNpb24gPHR0PiQgVmVyc2lvbjogMS4wICQ8L3R0PiBkYXRlOjIwMTYvMDUvMDNcclxuICogYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86aHJhaG5AbmtpYS5jby5rclwiPkFobiBIeXVuZy1SbzwvYT5cclxuICpcclxuICogZXhhbXBsZTpcclxuICogPFB1Zi5Ecm9wRG93bkxpc3Qgb3B0aW9ucz17b3B0aW9uc30gLz5cclxuICpcclxuICogS2VuZG8gRHJvcERvd25MaXN0IOudvOydtOu4jOufrOumrOyXkCDsooXsho3soIHsnbTri6QuXHJcbiAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQgVXRpbCBmcm9tICcuLi9zZXJ2aWNlcy9VdGlsJztcclxuXHJcbmNvbnN0IHByb3BUeXBlcyA9IHtcclxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIHVybDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIG1ldGhvZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIHdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgICAgIFByb3BUeXBlcy5udW1iZXJcclxuICAgIF0pLFxyXG4gICAgb3B0aW9uTGFiZWw6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBsaXN0RmllbGQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBkYXRhVGV4dEZpZWxkOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgZGF0YVZhbHVlRmllbGQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBzZWxlY3RlZEl0ZW06IFByb3BUeXBlcy5vYmplY3QsXHJcbiAgICBzZWxlY3RlZFZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgICAgIFByb3BUeXBlcy5udW1iZXJcclxuICAgIF0pLFxyXG4gICAgc2VsZWN0ZWRJbmRleDogUHJvcFR5cGVzLm51bWJlcixcclxuICAgIGl0ZW1zOiBQcm9wVHlwZXMuYXJyYXksXHJcbiAgICBoZWFkZXJUZW1wbGF0ZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIHZhbHVlVGVtcGxhdGU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICB0ZW1wbGF0ZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHJlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHNlcnZlckZpbHRlcmluZzogUHJvcFR5cGVzLmJvb2wsIFxyXG4gICAgb25TZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25DbG9zZTogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICBvbk9wZW46IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25GaWx0ZXJpbmc6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25EYXRhQm91bmQ6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25Mb2FkQ29tcGxldGU6IFByb3BUeXBlcy5mdW5jXHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XHJcbiAgICBtZXRob2Q6ICdQT1NUJywgXHJcbiAgICBpdGVtczogW10sIFxyXG4gICAgLy8gbGlzdEZpZWxkOiAncmVzdWx0VmFsdWUnLCBsaXN0RmllbGTsnZgg7LSI6riw6rCS7J2AIOyXhuuKlCDqsoPsnLzroZwg7ZWc64ukLlxyXG4gICAgd2lkdGg6ICcxMDAlJywgXHJcbiAgICBkYXRhVGV4dEZpZWxkOiAndGV4dCcsIFxyXG4gICAgZGF0YVZhbHVlRmllbGQ6ICd2YWx1ZScsIFxyXG4gICAgc2VsZWN0ZWRJbmRleDogMCwgXHJcbiAgICBkaXNhYmxlZDogZmFsc2UsXHJcbiAgICBzZXJ2ZXJGaWx0ZXJpbmc6IGZhbHNlXHJcbn07XHJcblxyXG4vKiogQ2xhc3MgcmVwcmVzZW50aW5nIGEgRHJvcERvd25MaXN0LiAqL1xyXG5jbGFzcyBEcm9wRG93bkxpc3QgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgLy8gT3BlcmF0aW9ucyB1c3VhbGx5IGNhcnJpZWQgb3V0IGluIGNvbXBvbmVudFdpbGxNb3VudCBnbyBoZXJlXHJcbiAgICAgICAgLy8gbGV0IGlkID0gcHJvcHMuaWQ7XHJcbiAgICAgICAgLy8gaWYodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vICAgICBpZCA9IFV0aWwuZ2V0VVVJRCgpO1xyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgLy8gdGhpcy5pZCA9IGlkO1xyXG5cclxuICAgICAgICAvLyBNYW51YWxseSBiaW5kIHRoaXMgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuLi5cclxuICAgICAgICB0aGlzLm9uU2VsZWN0ID0gdGhpcy5vblNlbGVjdC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSB0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbk9wZW4gPSB0aGlzLm9uT3Blbi5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25DbG9zZSA9IHRoaXMub25DbG9zZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25GaWx0ZXJpbmcgPSB0aGlzLm9uRmlsdGVyaW5nLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbkRhdGFCb3VuZCA9IHRoaXMub25EYXRhQm91bmQuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9uTG9hZENvbXBsZXRlID0gdGhpcy5vbkxvYWRDb21wbGV0ZS5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcclxuICAgICAgICAvLyDstZzstIgg66CM642U66eB7J20IOydvOyWtOuCmOq4sCDsp4HsoIQo7ZWc67KIIO2YuOy2nClcclxuICAgICAgICBsZXQgaWQgPSB0aGlzLnByb3BzLmlkO1xyXG4gICAgICAgIGlmKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWQgPSBVdGlsLmdldFVVSUQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAvLyDstZzstIgg66CM642U66eB7J20IOydvOyWtOuCnCDri6TsnYwo7ZWc67KIIO2YuOy2nClcclxuICAgIFx0dGhpcy4kZHJvcERvd25MaXN0ID0gJCgnIycrdGhpcy5pZCk7XHJcbiAgICAgICAgdGhpcy5kcm9wZG93bmxpc3QgPSB0aGlzLiRkcm9wRG93bkxpc3Qua2VuZG9Ecm9wRG93bkxpc3QodGhpcy5vcHRpb25zKCkpLmRhdGEoJ2tlbmRvRHJvcERvd25MaXN0Jyk7XHJcblxyXG4gICAgICAgIC8vIEV2ZW50c1xyXG4gICAgICAgIHRoaXMuZHJvcGRvd25saXN0LmJpbmQoJ3NlbGVjdCcsIHRoaXMub25TZWxlY3QpO1xyXG4gICAgICAgIHRoaXMuZHJvcGRvd25saXN0LmJpbmQoJ2NoYW5nZScsIHRoaXMub25DaGFuZ2UpO1xyXG4gICAgICAgIHRoaXMuZHJvcGRvd25saXN0LmJpbmQoJ29wZW4nLCB0aGlzLm9uT3Blbik7XHJcbiAgICAgICAgdGhpcy5kcm9wZG93bmxpc3QuYmluZCgnY2xvc2UnLCB0aGlzLm9uQ2xvc2UpO1xyXG4gICAgICAgIHRoaXMuZHJvcGRvd25saXN0LmJpbmQoJ2ZpbHRlcmluZycsIHRoaXMub25GaWx0ZXJpbmcpO1xyXG4gICAgICAgIHRoaXMuZHJvcGRvd25saXN0LmJpbmQoJ2RhdGFCb3VuZCcsIHRoaXMub25EYXRhQm91bmQpO1xyXG5cclxuICAgICAgICAvLyBwcmV2U2VsZWN0ZWRJdGVtIOyEpOyglShhamF4IOyalOyyreyLnCDsspjrpqzripQgb25Mb2FkQ29tcGxldGUpXHJcbiAgICAgICAgLy8gaW5pdCDsi5wgZGF0YUl0ZW0g6rCS7J2EIOydveyWtOyYpOuKlOyngCDtmZXsnbjtlYTsmpRcclxuICAgICAgICB0aGlzLnByZXZTZWxlY3RlZEl0ZW0gPSB0aGlzLmRyb3Bkb3dubGlzdC5kYXRhSXRlbSgpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIHJlYWRPbmx5XHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMucmVhZE9ubHkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVhZE9ubHkodGhpcy5wcm9wcy5yZWFkT25seSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XHJcbiAgICAgICAgLy8g7Lu07Y+s64SM7Yq46rCAIOyDiOuhnOyatCBwcm9wc+ulvCDrsJvsnYQg65WMIO2YuOy2nCjstZzstIgg66CM642U66eBIOyLnOyXkOuKlCDtmLjstpzrkJjsp4Ag7JWK7J2MKVxyXG4gICAgICAgIGlmKHR5cGVvZiBuZXh0UHJvcHMuc2VsZWN0ZWRWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZShuZXh0UHJvcHMuc2VsZWN0ZWRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0eXBlb2YgbmV4dFByb3BzLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLmVuYWJsZSghbmV4dFByb3BzLmRpc2FibGVkKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZiBuZXh0UHJvcHMucmVhZE9ubHkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVhZE9ubHkobmV4dFByb3BzLnJlYWRPbmx5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHNob3VsZENvbXBvbmVudFVwZGF0ZShuZXh0UHJvcHMsIG5leHRTdGF0ZSkge1xyXG4gICAgICAgIC8vIOyDiOuhnOyatCBwcm9wc+uCmCBzdGF0ZeulvCDrsJvslZjsnYQg65WMIOugjOuNlOungSDsoITsl5Ag7Zi47LacKOy1nOy0iCDroIzrjZTrp4Eg7Iuc7JeQ64qUIO2YuOy2nOuQmOyngCDslYrsnYwpXHJcbiAgICAgICAgLy8gZmFsc2Ug66m0IHJlbmRlciDtmLjstpztlZjsp4Ag7JWK7J2MKGNvbXBvbmVudFdpbGxVcGRhdGUg7JmAIGNvbXBvbmVudERpZFVwZGF0ZSDsl63si5wg7Zi47Lac65CY7KeAIOyViuydjClcclxuICAgICAgICByZXR1cm4gZmFsc2U7ICAgIC8vIGRlZmF1bHQgdHJ1ZVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgb3B0aW9ucygpIHtcclxuICAgICAgICBjb25zdCB7IHVybCwgbWV0aG9kLCBpdGVtcywgc2VsZWN0ZWRJbmRleCwgc2VsZWN0ZWRWYWx1ZSwgbGlzdEZpZWxkLCBkYXRhVGV4dEZpZWxkLCBkYXRhVmFsdWVGaWVsZCwgXHJcbiAgICAgICAgICAgICAgICBoZWFkZXJUZW1wbGF0ZSwgdmFsdWVUZW1wbGF0ZSwgdGVtcGxhdGUsIGRpc2FibGVkLCBzZXJ2ZXJGaWx0ZXJpbmcgfSA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBpbmRleDogc2VsZWN0ZWRJbmRleCxcclxuICAgICAgICAgICAgZGF0YVRleHRGaWVsZDogZGF0YVRleHRGaWVsZCxcclxuICAgICAgICAgICAgZGF0YVZhbHVlRmllbGQ6IGRhdGFWYWx1ZUZpZWxkLFxyXG4gICAgICAgICAgICBlbmFibGU6ICFkaXNhYmxlZFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIGRhdGFTb3VyY2VcclxuICAgICAgICAvLyB1cmxcclxuICAgICAgICBpZih0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7IGRhdGFTb3VyY2U6IHtcclxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG1ldGhvZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04J1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHtcclxuICAgICAgICAgICAgICAgICAgIC8vIHJldHVybmVkIGluIHRoZSBcImxpc3RGaWVsZFwiIGZpZWxkIG9mIHRoZSByZXNwb25zZVxyXG4gICAgICAgICAgICAgICAgICAgZGF0YTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdEZpZWxkcyA9IFtdLCBkYXRhTGlzdCA9IHJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgIGlmKGxpc3RGaWVsZCAmJiBsaXN0RmllbGQubGVuZ3RoID4gMCAmJiBsaXN0RmllbGQgIT0gJ251bGwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RGaWVsZHMgPSBsaXN0RmllbGQuc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdEZpZWxkcy5tYXAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmllbGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhTGlzdCA9IGRhdGFMaXN0W2ZpZWxkXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFMaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNlcnZlckZpbHRlcmluZzogc2VydmVyRmlsdGVyaW5nLFxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdEVuZDogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZS50eXBlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGUucmVzcG9uc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdyZWFkJyAmJiByZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTG9hZENvbXBsZXRlKGUsIHJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcylcclxuICAgICAgICAgICAgfSB9KTtcclxuXHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7IGRhdGFTb3VyY2U6IGl0ZW1zIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gLy8gc2VsZWN0ZWRJbmRleFxyXG4gICAgICAgIC8vIGlmKHR5cGVvZiBzZWxlY3RlZEluZGV4ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vICAgICAkLmV4dGVuZChvcHRpb25zLCB7IGluZGV4OiBzZWxlY3RlZEluZGV4IH0pO1xyXG4gICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgLy8gc2VsZWN0ZWRWYWx1ZVxyXG4gICAgICAgIGlmKHR5cGVvZiBzZWxlY3RlZFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7IHZhbHVlOiBzZWxlY3RlZFZhbHVlIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaGVhZGVyVGVtcGxhdGVcclxuICAgICAgICBpZih0eXBlb2YgaGVhZGVyVGVtcGxhdGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKG9wdGlvbnMsIHsgaGVhZGVyVGVtcGxhdGU6IGhlYWRlclRlbXBsYXRlIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdmFsdWVUZW1wbGF0ZVxyXG4gICAgICAgIGlmKHR5cGVvZiB2YWx1ZVRlbXBsYXRlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7IHZhbHVlVGVtcGxhdGU6IHZhbHVlVGVtcGxhdGUgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0ZW1wbGF0ZVxyXG4gICAgICAgIGlmKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQob3B0aW9ucywgeyB0ZW1wbGF0ZTogdGVtcGxhdGUgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBtZXRob2RzXHJcbiAgICBvcGVuKCkge1xyXG4gICAgICAgIHRoaXMuZHJvcGRvd25saXN0Lm9wZW4oKTtcclxuICAgIH1cclxuXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICB0aGlzLmRyb3Bkb3dubGlzdC5jbG9zZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGVjdChpbmRleCkge1xyXG4gICAgICAgIC8vIGluZGV4OiBsaSBqUXVlcnkgfCBOdW1iZXIgfCBGdW5jdGlvblxyXG4gICAgICAgIC8vIHJldHVybiBUaGUgaW5kZXggb2YgdGhlIHNlbGVjdGVkIGl0ZW1cclxuICAgICAgICByZXR1cm4gdGhpcy5kcm9wZG93bmxpc3Quc2VsZWN0KGluZGV4KTtcclxuICAgIH1cclxuXHJcbiAgICB2YWx1ZSh2KSB7XHJcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyb3Bkb3dubGlzdC52YWx1ZSgpO1xyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd25saXN0LnZhbHVlKHYpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBlbmFibGUoaXNCb29sKSB7XHJcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd25saXN0LmVuYWJsZSgpO1xyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kcm9wZG93bmxpc3QuZW5hYmxlKGlzQm9vbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlYWRPbmx5KGlzQm9vbCkge1xyXG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3dubGlzdC5yZWFkb25seSgpO1xyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kcm9wZG93bmxpc3QucmVhZG9ubHkoaXNCb29sKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGRhdGEgaXRlbXMgb2YgdGhlIGRyb3Bkb3dubGlzdCdzIGRhdGEgc291cmNlLlxyXG4gICAgICogQHBhcmFtIHsoQXJyYXl8a2VuZG8uZGF0YS5PYnNlcnZhYmxlQXJyYXkpfSBpdGVtcyAtIHRoZSBkYXRhIGl0ZW1zIG9mIHRoZSBkcm9wZG93bmxpc3QncyBkYXRhIHNvdXJjZS5cclxuICAgICAqIEByZXR1cm4ge2tlbmRvLmRhdGEuT2JzZXJ2YWJsZUFycmF5fSB0aGUgZGF0YSBpdGVtcyBvZiB0aGUgZHJvcGRvd25saXN0J3MgZGF0YSBzb3VyY2UuXHJcbiAgICAgKi9cclxuICAgIHNldEl0ZW1zKGl0ZW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd25saXN0LmRhdGFTb3VyY2UuZGF0YShpdGVtcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGRhdGEgaXRlbXMgb2YgdGhlIGRyb3Bkb3dubGlzdCdzIGRhdGEgc291cmNlLlxyXG4gICAgICogQHJldHVybiB7a2VuZG8uZGF0YS5PYnNlcnZhYmxlQXJyYXl9IHRoZSBkYXRhIGl0ZW1zIG9mIHRoZSBkcm9wZG93bmxpc3QncyBkYXRhIHNvdXJjZS5cclxuICAgICAqL1xyXG4gICAgZ2V0SXRlbXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJvcGRvd25saXN0LmRhdGFTb3VyY2UuZGF0YSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGV2ZW50c1xyXG4gICAgb25TZWxlY3QoZSkge1xyXG4gICAgXHQvLyBjb25zb2xlLmxvZygnb25TZWxlY3QnLCBlKTtcclxuICAgICAgICB2YXIgc2VsZWN0ZWRJdGVtID0gdGhpcy5kcm9wZG93bmxpc3QuZGF0YUl0ZW0oZS5pdGVtKTtcclxuICAgICAgICAgICAgLy8gc2VsZWN0ZWRWYWx1ZSA9IHNlbGVjdGVkSXRlbVt0aGlzLnByb3BzLmRhdGFWYWx1ZUZpZWxkXTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKGRhdGFJdGVtW3RoaXMucHJvcHMuZGF0YVZhbHVlRmllbGRdKTtcclxuICAgICAgICAvLyQoJ1tuYW1lPScgKyB0aGlzLnByb3BzLm5hbWUgKyAnXScpLnZhbChkYXRhSXRlbS52YWx1ZSk7XHJcbiAgICAgICAgLy8kKCdpbnB1dFtuYW1lPWRpc3BsYXlEYXRhXScpLnZhbChkYXRhSXRlbVt0aGlzLnByb3BzLmRhdGFWYWx1ZUZpZWxkXSk7XHJcbiAgICAgICAgLy90aGlzLiRkcm9wRG93bkxpc3QudmFsKGRhdGFJdGVtW3RoaXMucHJvcHMuZGF0YVZhbHVlRmllbGRdKTtcclxuXHJcbiAgICBcdGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uU2VsZWN0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25TZWxlY3QoZSwgc2VsZWN0ZWRJdGVtLCB0aGlzLnByZXZTZWxlY3RlZEl0ZW0pO1xyXG4gICAgICAgICAgICAvL2Uuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBvbkNoYW5nZSDsl5DshJzrp4wg7LKY66asXHJcbiAgICAgICAgLy8gdGhpcy5wcmV2U2VsZWN0ZWRJdGVtID0gc2VsZWN0ZWRJdGVtO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNoYW5nZSDrsJzsg53tlZjsp4Ag7JWK7J2MXHJcbiAgICBvbkNoYW5nZShlKSB7XHJcbiAgICBcdC8vIGNvbnNvbGUubG9nKCdvbkNoYW5nZScsIGUpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuZHJvcGRvd25saXN0LmRhdGFJdGVtKGUuc2VuZGVyLnNlbGVjdGVkSW5kZXgpKTtcclxuICAgICAgICB2YXIgc2VsZWN0ZWRJdGVtID0gdGhpcy5kcm9wZG93bmxpc3QuZGF0YUl0ZW0oZS5zZW5kZXIuc2VsZWN0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgIC8vIHNlbGVjdGVkVmFsdWUgPSBzZWxlY3RlZEl0ZW1bdGhpcy5wcm9wcy5kYXRhVmFsdWVGaWVsZF07XHJcblxyXG4gICAgXHRpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkNoYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKGUsIHNlbGVjdGVkSXRlbSwgdGhpcy5wcmV2U2VsZWN0ZWRJdGVtKTtcclxuICAgICAgICAgICAgLy9lLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5wcmV2U2VsZWN0ZWRJdGVtID0gc2VsZWN0ZWRJdGVtO1xyXG4gICAgfVxyXG5cclxuICAgIG9uT3BlbihlKSB7XHJcbiAgICBcdC8vY29uc29sZS5sb2coJ29uT3BlbicpO1xyXG4gICAgXHQvL2NvbnNvbGUubG9nKGV2ZW50KTtcclxuICAgIFx0XHJcbiAgICBcdGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uT3BlbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uT3BlbihlKTtcclxuXHJcbiAgICAgICAgICAgIC8vZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uQ2xvc2UoZSkge1xyXG4gICAgXHQvL2NvbnNvbGUubG9nKCdvbkNsb3NlJyk7XHJcbiAgICBcdC8vY29uc29sZS5sb2coZXZlbnQpO1xyXG4gICAgXHRcclxuICAgIFx0aWYodHlwZW9mIHRoaXMucHJvcHMub25DbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2xvc2UoZSk7XHJcblxyXG4gICAgICAgICAgICAvL2V2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgb25GaWx0ZXJpbmcoZSkge1xyXG5cclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkZpbHRlcmluZyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkZpbHRlcmluZyhlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIG9uRGF0YUJvdW5kKGV2ZW50KSB7XHJcbiAgICBcdC8vY29uc29sZS5sb2coJ29uRGF0YUJvdW5kJyk7XHJcbiAgICBcdC8vY29uc29sZS5sb2coZXZlbnQpO1xyXG4gICAgXHRcclxuICAgIFx0aWYodHlwZW9mIHRoaXMucHJvcHMub25EYXRhQm91bmQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkRhdGFCb3VuZChldmVudCk7XHJcblxyXG4gICAgICAgICAgICAvL2V2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkxvYWRDb21wbGV0ZShlLCByZXNwb25zZSkge1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdvbkxvYWRDb21wbGV0ZScsIGUsIHJlc3BvbnNlKTtcclxuICAgICAgICB0aGlzLnByZXZTZWxlY3RlZEl0ZW0gPSByZXNwb25zZVt0aGlzLnByb3BzLnNlbGVjdGVkSW5kZXhdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIGluaXQg7Iuc7JeQ64qUIOqwkuydhCDsnb3slrTsmKTsp4Ag66q77ZWc64ukLlxyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdvbkxvYWRDb21wbGV0ZScsIHRoaXMuZHJvcGRvd25saXN0LmRhdGFJdGVtKCkpO1xyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdvbkxvYWRDb21wbGV0ZScsIHRoaXMudmFsdWUoKSk7XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uTG9hZENvbXBsZXRlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uTG9hZENvbXBsZXRlKGUsIHJlc3BvbnNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICAvLyDtlYTsiJgg7ZWt66qpICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHtjbGFzc05hbWUsIG5hbWUsIHdpZHRofSA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgXHQ8aW5wdXQgaWQ9e3RoaXMuaWR9IG5hbWU9e25hbWV9IHN0eWxlPXt7d2lkdGg6IHdpZHRofX0gLz5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5Ecm9wRG93bkxpc3QucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xyXG5Ecm9wRG93bkxpc3QuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRHJvcERvd25MaXN0OyIsIi8qKlxyXG4gKiBHcmlkIGNvbXBvbmVudFxyXG4gKlxyXG4gKiB2ZXJzaW9uIDx0dD4kIFZlcnNpb246IDEuMCAkPC90dD4gZGF0ZToyMDE2LzA0LzE3XHJcbiAqIGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmhyYWhuQG5raWEuY28ua3JcIj5BaG4gSHl1bmctUm88L2E+XHJcbiAqXHJcbiAqIGV4YW1wbGU6XHJcbiAqIDxQdWYuR3JpZCBvcHRpb25zPXtvcHRpb25zfSAvPlxyXG4gKlxyXG4gKiBLZW5kbyBHcmlkIOudvOydtOu4jOufrOumrOyXkCDsooXsho3soIHsnbTri6QuXHJcbiAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQgVXRpbCBmcm9tICcuLi9zZXJ2aWNlcy9VdGlsJztcclxuXHJcbmNvbnN0IHByb3BUeXBlcyA9IHtcclxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgaG9zdDogUHJvcFR5cGVzLnN0cmluZywgICAgICAgICAgICAgLy8g7ISc67KEIOygleuztChDcm9zcyBCcm93c2VyIEFjY2VzcylcclxuICAgIHVybDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIG1ldGhvZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGRhdGFUeXBlOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgY2hlY2tib3hGaWVsZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGRhdGE6IFByb3BUeXBlcy5vYmplY3QsXHJcbiAgICBjb2x1bW5zOiBQcm9wVHlwZXMuYXJyYXksXHJcbiAgICBpdGVtczogUHJvcFR5cGVzLmFycmF5LFxyXG4gICAgc2VsZWN0ZWRJZHM6IFByb3BUeXBlcy5hcnJheSxcclxuICAgIGxpc3RGaWVsZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIHRvdGFsRmllbGQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBjaGVja0ZpZWxkOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgb25TZWxlY3RSb3c6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgZWRpdGFibGU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgcmVzaXphYmxlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIGZpbHRlcmFibGU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1xyXG4gICAgICAgIFByb3BUeXBlcy5ib29sLFxyXG4gICAgICAgIFByb3BUeXBlcy5vYmplY3RcclxuICAgIF0pLFxyXG4gICAgc29ydGFibGU6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgc29ydDogUHJvcFR5cGVzLm9iamVjdCwgICAgICAgICAgICAgLy8geyBmaWVsZDogJ25hbWUnLCBkaXI6ICdkZXNjJyB9IG9yIFt7IGZpZWxkOiAnbmFtZScsIGRpcjogJ2Rlc2MnIH0sIHsgZmllbGQ6ICduYW1lJywgZGlyOiAnZGVzYycgfV1cclxuICAgIHBhZ2VhYmxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMuYm9vbCxcclxuICAgICAgICBQcm9wVHlwZXMub2JqZWN0XHJcbiAgICBdKSxcclxuICAgIHBhZ2VTaXplOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgaGVpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgICAgIFByb3BUeXBlcy5udW1iZXJcclxuICAgIF0pLFxyXG5cclxuICAgIC8qXHJcbiAgICAgICAgR3JpZCBzZWxlY3RhYmxlIOyEpOygleqwklxyXG4gICAgICAgIFwicm93XCIgLSB0aGUgdXNlciBjYW4gc2VsZWN0IGEgc2luZ2xlIHJvdy5cclxuICAgICAgICBcImNlbGxcIiAtIHRoZSB1c2VyIGNhbiBzZWxlY3QgYSBzaW5nbGUgY2VsbC5cclxuICAgICAgICBcIm11bHRpcGxlLCByb3dcIiAtIHRoZSB1c2VyIGNhbiBzZWxlY3QgbXVsdGlwbGUgcm93cy5cclxuICAgICAgICBcIm11bHRpcGxlLCBjZWxsXCIgLSB0aGUgdXNlciBjYW4gc2VsZWN0IG11bHRpcGxlIGNlbGxzLlxyXG4gICAgKi9cclxuICAgIHNlbGVjdE1vZGU6IFByb3BUeXBlcy5vbmVPZihbJ3JvdycsJ2NlbGwnXSksIC8vIEdyaWQgU2VsZWN0IFJvdyDrmJDripQgQ2VsbCDshKDtg51cclxuICAgIG11bHRpcGxlOiBQcm9wVHlwZXMuYm9vbCwgICAvLyDshYDroIntirggbXVsdGlwbGUg7KeA7JuQXHJcbiAgICAvKlxyXG4gICAgICAgIEdyaWQgcGFyYW1ldGVyTWFwRmllbGQg7ISk7KCV6rCSXHJcbiAgICAgICAgc2tpcDogXCJzdGFydFwiLCAtIHBhZ2luZyBza2lwIOuzgOyImCDsnoXroKXrkJwg6rCSKGtleSnsnLzroZwg67O17KCcXHJcbiAgICAgICAgdGFrZTogXCJsaW1pdFwiLCAtIHBhZ2luZyBsaW1pdCDrs4DsiJgg7J6F66Cl65CcIOqwkihrZXkp7Jy866GcIOuzteygnFxyXG4gICAgICAgIGNvbnZlcnRTb3J0OiB0cnVlLCAtIHNvcnQgcGFyYW1ldGVyIOuzteygnCDsl6zrtoBcclxuICAgICAgICBmaWVsZDpcInByb3BlcnR5XCIsICAtIHNvcnQgZmllbGQg67OA7IiYIOyeheugpeuQnCDqsJIoa2V5KeycvOuhnCDrs7XsoJxcclxuICAgICAgICBkaXI6IFwiZGlyZWN0aW9uXCIsICAtIHNvcnQgZGlyIOuzgOyImCDsnoXroKXrkJwg6rCSKGtleSnsnLzroZwg67O17KCcXHJcbiAgICAgICAgZmlsdGVyc1RvSnNvbjogdHJ1ZSwgICAgICAtIGZpbHRlciDsoJXrs7TrpbwganNvbuycvOuhnCDrs4DtmZjtlbTshJwg7J2867CYIO2MjOudvOuvuO2EsCDsspjrn7wg7LKY66asXHJcbiAgICAgICAgZmlsdGVyUHJlZml4OiBcInNlYXJjaF9cIiwgIC0gZmlsdGVyIGpzb27snLzroZwg67OA7ZmY7IucIHByZWZpeOqwgCDtlYTsmpTtlZwg6rK97JqwIHByZWZpeOulvCDrtpnsl6zshJwg67CY7ZmYXHJcbiAgICAgICAgZmlsdGVyRmllbGRUb0xvd2VyQ2FzZTogdHJ1ZSAgLSBmaWx0ZXLsnZggZmllbGTrpbwgbG93ZXJDYXNlKOyGjOusuOyekCnroZwg67CY7ZmYXHJcbiAgICAqL1xyXG4gICAgcGFyYW1ldGVyTWFwRmllbGQ6IFByb3BUeXBlcy5vYmplY3QsICAvLyBQYXJhbWV0ZXIgQ29udHJvbCDqsJ3ssrQo642w7J207YSwIOuzteyCrCwg7ZWE7YSw7LKY66asLCBTb3J0aW5nIO2MjOumrOuvuO2EsCDsoJXsnZgg65OxKVxyXG4gICAgc2Nyb2xsYWJsZTogUHJvcFR5cGVzLmJvb2wsIC8vIOyijOyasCDsiqTtgazroaQg7IOd7ISxXHJcbiAgICAvLyBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICBvbkRhdGFCb3VuZDogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICBvbkRhdGFCaW5kaW5nOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xyXG4gICAgbWV0aG9kOiAnUE9TVCcsIFxyXG4gICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgIGl0ZW1zOiBbXSwgXHJcbiAgICBsaXN0RmllbGQ6ICdyZXN1bHRWYWx1ZS5saXN0JywgXHJcbiAgICB0b3RhbEZpZWxkOiAncmVzdWx0VmFsdWUudG90YWxDb3VudCcsXHJcbiAgICBlZGl0YWJsZTogZmFsc2UsXHJcbiAgICByZXNpemFibGU6IHRydWUsIFxyXG4gICAgZmlsdGVyYWJsZTogZmFsc2UsIFxyXG4gICAgc29ydGFibGU6IHRydWUsIFxyXG4gICAgcGFnZWFibGU6IHRydWUsXHJcbiAgICBwYWdlU2l6ZTogMjAsIFxyXG4gICAgc2VsZWN0TW9kZTogbnVsbCwgXHJcbiAgICBtdWx0aXBsZTogZmFsc2UsIFxyXG4gICAgcGFyYW1ldGVyTWFwRmllbGQ6IG51bGwsIFxyXG4gICAgc2Nyb2xsYWJsZTogdHJ1ZVxyXG59O1xyXG5cclxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIEdyaWQuICovXHJcbmNsYXNzIEdyaWQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgXHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgdGhpcy5jaGVja2VkSWRzID0ge307XHJcbiAgICAgICAgdGhpcy5jaGVja2VkSXRlbXMgPSB7fTtcclxuXHJcbiAgICAgICAgLy8gTWFudWFsbHkgYmluZCB0aGlzIG1ldGhvZCB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlLi4uXHJcbiAgICAgICAgdGhpcy5vbkRhdGFCb3VuZCA9IHRoaXMub25EYXRhQm91bmQuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9uRGF0YUJpbmRpbmcgPSB0aGlzLm9uRGF0YUJpbmRpbmcuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gdGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25TZWxlY3RSb3cgPSB0aGlzLm9uU2VsZWN0Um93LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbkNoZWNrYm94SGVhZGVyID0gdGhpcy5vbkNoZWNrYm94SGVhZGVyLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbkNoZWNrYm94Um93ID0gdGhpcy5vbkNoZWNrYm94Um93LmJpbmQodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50V2lsbE1vdW50KCkge1xyXG4gICAgICAgIC8vIOy1nOy0iCDroIzrjZTrp4HsnbQg7J287Ja064KY6riwIOyngeyghCjtlZzrsogg7Zi47LacKVxyXG4gICAgICAgIGxldCBpZCA9IHRoaXMucHJvcHMuaWQ7XHJcbiAgICAgICAgaWYodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZCA9IFV0aWwuZ2V0VVVJRCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIC8vIOy1nOy0iCDroIzrjZTrp4HsnbQg7J287Ja064KcIOuLpOydjCjtlZzrsogg7Zi47LacKVxyXG4gICAgICAgIHRoaXMuJGdyaWQgPSAkKCcjJyt0aGlzLmlkKTtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyh0aGlzLm9wdGlvbnModGhpcy5wcm9wcykpO1xyXG4gICAgICAgIHRoaXMuZ3JpZCA9IHRoaXMuJGdyaWQua2VuZG9HcmlkKHRoaXMub3B0aW9ucyh0aGlzLnByb3BzKSkuZGF0YSgna2VuZG9HcmlkJyk7XHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAkKHdpbmRvdykucmVzaXplKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgIC8vX3RoaXMuJGdyaWQuZGF0YShcImtlbmRvR3JpZFwiKS5yZXNpemUoKTtcclxuICAgICAgICAgICAgX3RoaXMuYXV0b1Jlc2l6ZUdyaWQoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAqL1xyXG4gICAgICAgIC8vIGJpbmQgY2xpY2sgZXZlbnQgdG8gdGhlIGNoZWNrYm94XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhncmlkKTtcclxuICAgICAgICAvLyBFdmVudHNcclxuICAgICAgICB0aGlzLmdyaWQuYmluZCgnY2hhbmdlJywgdGhpcy5vbkNoYW5nZSk7XHJcbiAgICAgICAgdGhpcy5ncmlkLmJpbmQoJ2RhdGFCb3VuZCcsIHRoaXMub25EYXRhQm91bmQpO1xyXG4gICAgICAgIHRoaXMuZ3JpZC5iaW5kKCdkYXRhQmluZGluZycsIHRoaXMub25EYXRhQmluZGluZyk7XHJcblxyXG4gICAgICAgIHRoaXMuZ3JpZC50YWJsZS5vbignY2xpY2snLCAnLmNoZWNrYm94JyAsIHRoaXMub25DaGVja2JveFJvdyk7ICAgICAgICAgLy8gY2hlY2tib3hcclxuICAgICAgICB0aGlzLmdyaWQudGhlYWQub24oJ2NsaWNrJywgJy5jaGVja2JveCcgLCB0aGlzLm9uQ2hlY2tib3hIZWFkZXIpOyAgICAgIC8vIGhlYWRlciBjaGVja2JveFxyXG5cclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xyXG4gICAgICAgIC8vIOy7tO2PrOuEjO2KuOqwgCDsg4jroZzsmrQgcHJvcHPrpbwg67Cb7J2EIOuVjCDtmLjstpwo7LWc7LSIIOugjOuNlOungSDsi5zsl5DripQg7Zi47Lac65CY7KeAIOyViuydjClcclxuICAgICAgICAvKiBkYXRhU291cmNlIOyXkCDqtIDroKjrkJwg6rCS7J20IOuwlOuAjOyWtOyVvCDri6Tsi5wg642w7J207YSwIOuhnOuUqe2VmOuKlCDrsKnsi53snYAg7J2864uoIOuztOulmFxyXG4gICAgICAgIO2ZlOuptOyXkOyEnCByZWZyZXNoIOqwgCDslYjrkKhcclxuICAgICAgICBjb25zdCB7dXJsLCBtZXRob2QsIGRhdGEsIGxpc3RGaWVsZH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICB2YXIgYiA9IGZhbHNlO1xyXG4gICAgICAgIGZvcih2YXIga2V5IGluIGRhdGEpIHtcclxuICAgICAgICAgICAgaWYobmV4dFByb3BzLmRhdGFba2V5XSAhPSBkYXRhW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIGIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKG5leHRQcm9wcy51cmwgIT0gdXJsIHx8IGIgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdzZXREYXRhU291cmNlJyk7XHJcbiAgICAgICAgICAgIHZhciBncmlkID0gJCgnIycrdGhpcy5pZCkuZGF0YShcImtlbmRvR3JpZFwiKTtcclxuICAgICAgICAgICAgZ3JpZC5zZXREYXRhU291cmNlKHRoaXMuY3JlYXRlRGF0YVNvdXJjZShuZXh0UHJvcHMpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgKi9cclxuICAgICAgICAvL3RoaXMuZ3JpZC5zZXREYXRhU291cmNlKHRoaXMuY3JlYXRlRGF0YVNvdXJjZShuZXh0UHJvcHMpKTtcclxuICAgICAgICB0aGlzLmNoZWNrZWRJZHMgPSB7fTtcclxuICAgICAgICB0aGlzLmdyaWQudGhlYWQuZmluZCgnLmNoZWNrYm94JykuYXR0cignY2hlY2tlZCcsIGZhbHNlKTtcclxuICAgICAgICAvLyBzZXREYXRhU291cmNlIOqwgCDsnbzslrTrgpjrqbQgaGVhZGVyIGNoZWNrYm94IGNsaWNrIOydtOuypO2KuCDrpqzsiqTrhIjqsIAg7IKs65287KC47IScIOuLpOyLnCDshKTsoJVcclxuICAgICAgICB0aGlzLmdyaWQudGhlYWQub24oJ2NsaWNrJywgJy5jaGVja2JveCcgLCB0aGlzLm9uQ2hlY2tib3hIZWFkZXIpOyAgICAgIC8vIGhlYWRlciBjaGVja2JveFxyXG5cclxuICAgICAgICAvLyBzZWxlY3RlZCBjaGVja1xyXG4gICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRJZHMobmV4dFByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIG9wdGlvbnMocHJvcHMpIHtcclxuICAgICAgICBjb25zdCB7IHVybCwgaXRlbXMsIGVkaXRhYmxlLCByZXNpemFibGUsIGZpbHRlcmFibGUsIHNvcnRhYmxlLCBwYWdlYWJsZSwgaGVpZ2h0LCBjaGVja2JveEZpZWxkLCBzZWxlY3RNb2RlLCBtdWx0aXBsZSwgc2Nyb2xsYWJsZSB9ID0gcHJvcHM7XHJcblxyXG4gICAgICAgIHZhciBkYXRhU291cmNlO1xyXG4gICAgICAgIGlmKHVybCAmJiB1cmwubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBkYXRhU291cmNlID0gdGhpcy5jcmVhdGVEYXRhU291cmNlKHByb3BzKTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGFTb3VyY2UgPSBpdGVtcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBjb2x1bW5zID0gcHJvcHMuY29sdW1ucztcclxuICAgICAgICBpZih0eXBlb2YgY2hlY2tib3hGaWVsZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdmFyIGIgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IodmFyIGkgaW4gY29sdW1ucykge1xyXG4gICAgICAgICAgICAgICAgaWYoY2hlY2tib3hGaWVsZCA9PSBjb2x1bW5zW2ldLmZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGIgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbHVtbnMudW5zaGlmdCh0aGlzLmdldENoZWNrYm94Q29sdW1uKGNoZWNrYm94RmllbGQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGZpbHRlcjtcclxuICAgICAgICBpZih0eXBlb2YgZmlsdGVyYWJsZSA9PT0gJ2Jvb2xlYW4nICYmIGZpbHRlcmFibGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgZmlsdGVyID0ge1xyXG4gICAgICAgICAgICAgICAgZXh0cmE6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgb3BlcmF0b3JzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zOiAnY29udGFpbnMnXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBudW1iZXI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXE6ICdlcScvKixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVxOiBcIkRpdmVyc28gZGFcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3RlOiBcIk1hZ2dpb3JlIG8gdWd1YWxlIGFcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3Q6IFwiTWFnZ2lvcmUgZGlcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbHRlOiBcIk1pbm9yZSBvIHVndWFsZSBhXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGx0OiBcIk1pbm9yZSBkaVwiKi9cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXE6ICdlcScvKixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmVxOiBcIkRpdmVyc28gZGFcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3RlOiBcIlN1Y2Nlc3NpdmEgbyB1Z3VhbGUgYWxcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3Q6IFwiU3VjY2Vzc2l2YSBhbFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsdGU6IFwiUHJlY2VkZW50ZSBvIHVndWFsZSBhbFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsdDogXCJQcmVjZWRlbnRlIGFsXCIqL1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZW51bXM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnM6ICdjb250YWlucydcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdWk6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgJHBhcmVudCA9IGVsZW1lbnQucGFyZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoJHBhcmVudC5jaGlsZHJlbigpLmxlbmd0aCA+IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJHBhcmVudC5jaGlsZHJlbigpWzBdKS5yZW1vdmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgJHBhcmVudC5wcmVwZW5kKCc8aW5wdXQgdHlwZT1cInRleHRcIiBkYXRhLWJpbmQ9XCJ2YWx1ZTpmaWx0ZXJzWzBdLnZhbHVlXCIgY2xhc3M9XCJrLXRleHRib3hcIj4nKTtcclxuICAgICAgICAgICAgICAgICAgICAkcGFyZW50LmZpbmQoJ2J1dHRvbjpzdWJtaXQuay1idXR0b24uay1wcmltYXJ5JykuaHRtbCgn7ZWE7YSwJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgJHBhcmVudC5maW5kKCdidXR0b246cmVzZXQuay1idXR0b24nKS5odG1sKCfstIjquLDtmZQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIGZpbHRlciA9IGZpbHRlcmFibGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgX3BhZ2VhYmxlO1xyXG4gICAgICAgIGlmKHR5cGVvZiBwYWdlYWJsZSA9PT0gJ2Jvb2xlYW4nICYmIHBhZ2VhYmxlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIF9wYWdlYWJsZSA9IHtcclxuICAgICAgICAgICAgICAgIGJ1dHRvbkNvdW50OiA1LFxyXG4gICAgICAgICAgICAgICAgcGFnZVNpemVzOiBbMTAsIDIwLCAzMCwgNTAsIDEwMF0sXHJcbiAgICAgICAgICAgICAgICBtZXNzYWdlczoge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICRwc19sb2NhbGUuZ3JpZC5yZWNvcmR0ZXh0LC8vJ3swfS17MX0vezJ9JyxcclxuICAgICAgICAgICAgICAgICAgICBlbXB0eTogJycsXHJcbiAgICAgICAgICAgICAgICAgICAgLy9vZjogJy97MH0nLFxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zUGVyUGFnZTogJHBzX2xvY2FsZS5ncmlkLnJvd3NQZXJQYWdlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICBfcGFnZWFibGUgPSBwYWdlYWJsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBkYXRhU291cmNlOiBkYXRhU291cmNlLFxyXG4gICAgICAgICAgICBjb2x1bW5zOiBjb2x1bW5zLFxyXG4gICAgICAgICAgICBub1JlY29yZHM6IHtcclxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiAkcHNfbG9jYWxlLmdyaWQuZW1wdHlyZWNvcmRzXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgICAvL2RhdGFCb3VuZDogdGhpcy5vbkRhdGFCb3VuZCxcclxuICAgICAgICAgICAgZWRpdGFibGU6IGVkaXRhYmxlLFxyXG4gICAgICAgICAgICByZXNpemFibGU6IHJlc2l6YWJsZSxcclxuICAgICAgICAgICAgZmlsdGVyYWJsZTogZmlsdGVyLFxyXG4gICAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGUsXHJcbiAgICAgICAgICAgIHNjcm9sbGFibGU6IHNjcm9sbGFibGUsXHJcbiAgICAgICAgICAgIHBhZ2VhYmxlOiBfcGFnZWFibGUsXHJcbiAgICAgICAgICAgIHNlbGVjdGFibGU6IChtdWx0aXBsZSkgPyBcIm11bHRpcGxlICxcIiArIHNlbGVjdE1vZGUgOiBzZWxlY3RNb2RlXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgaWYodHlwZW9mIGhlaWdodCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGhlaWdodCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQob3B0aW9ucywge2hlaWdodDogaGVpZ2h0fSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZURhdGFTb3VyY2UocHJvcHMpIHtcclxuICAgICAgICBjb25zdCB7aG9zdCwgdXJsLCBtZXRob2QsIGRhdGFUeXBlLCBkYXRhLCBsaXN0RmllbGQsIHRvdGFsRmllbGQsIHNvcnQsIHBhZ2VhYmxlLCBwYWdlU2l6ZSwgcGFyYW1ldGVyTWFwRmllbGR9ID0gcHJvcHM7XHJcblxyXG4gICAgICAgIC8vIHBhZ2VTaXplXHJcbiAgICAgICAgdmFyIF9wYWdlU2l6ZSA9IDAsIF9wYWdlYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmKHBhZ2VhYmxlKSB7XHJcbiAgICAgICAgICAgIF9wYWdlU2l6ZSA9IHBhZ2VTaXplO1xyXG4gICAgICAgICAgICBfcGFnZWFibGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaHR0cDovL2l0cS5ubC9rZW5kby11aS1ncmlkLXdpdGgtc2VydmVyLXBhZ2luZy1maWx0ZXJpbmctYW5kLXNvcnRpbmctd2l0aC1tdmMzL1xyXG4gICAgICAgIC8vIGh0dHBzOi8vYmxvZy5sb25nbGUubmV0LzIwMTIvMDQvMTMvdGVsZXJpa3MtaHRtbDUta2VuZG8tdWktZ3JpZC13aXRoLXNlcnZlci1zaWRlLXBhZ2luZy1zb3J0aW5nLWZpbHRlcmluZy13aXRoLW12YzMtZWY0LWR5bmFtaWMtbGlucS9cclxuICAgICAgICB2YXIgZGF0YVNvdXJjZSA9IG5ldyBrZW5kby5kYXRhLkRhdGFTb3VyY2Uoe1xyXG4gICAgICAgICAgICB0cmFuc3BvcnQ6IHtcclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICByZWFkOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJC5hamF4KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogbWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsIOydtOqygyDshKTsoJXtlZjrqbQgZGF0YSDsoITshqEg7JWI65CoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsLy9KU09OLnN0cmluZ2lmeSh7a2V5OiBcInZhbHVlXCJ9KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhkYXRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyID0gW10sIGdyaWRMaXN0ID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxpc3RGaWVsZCAmJiBsaXN0RmllbGQubGVuZ3RoID4gMCAmJiBsaXN0RmllbGQgIT0gJ251bGwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyID0gbGlzdEZpZWxkLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgaW4gYXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhhcnJbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRMaXN0ID0gZ3JpZExpc3RbYXJyW2ldXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3VjY2VzcyhncmlkTGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL29wdGlvbnMuc3VjY2VzcyhkYXRhLnJlc3VsdFZhbHVlLmxpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgcmVhZDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHVybDogKGhvc3QgJiYgaG9zdCAhPT0gbnVsbCAmJiBob3N0Lmxlbmd0aCA+IDApID8gaG9zdCArIHVybCA6IHVybCxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBtZXRob2QsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6IGRhdGFUeXBlLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsICAgICAgLy8gc2VhcmNoIChAUmVxdWVzdEJvZHkgR3JpZFBhcmFtIGdyaWRQYXJhbSDroZwg67Cb64qU64ukLilcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLTgnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyTWFwOiBmdW5jdGlvbihkYXRhLCB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZSA9PSBcInJlYWRcIiAmJiBwYXJhbWV0ZXJNYXBGaWVsZCAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgXHQvLyDrjbDsnbTthLAg7J297Ja07Jis65WMIO2VhOyalO2VnCDrjbDsnbTthLAoZXg67Y6Y7J207KeA6rSA66CoKeqwgCDsnojsnLzrqbQgZGF0YeulvCBjb3B57ZWc64ukLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGNvcHkgaW4gcGFyYW1ldGVyTWFwRmllbGQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIHBhcmFtZXRlck1hcEZpZWxkW2NvcHldID09PSBcInN0cmluZ1wiICYmICggY29weSBpbiBkYXRhICkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbcGFyYW1ldGVyTWFwRmllbGRbY29weV1dID0gZGF0YVtjb3B5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgQXJyYXkgPT4gSnNvbiBPYmplY3QgQ29weVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwYXJhbWV0ZXJNYXBGaWVsZC5maWx0ZXJzVG9Kc29uICYmIGRhdGEuZmlsdGVyICYmIGRhdGEuZmlsdGVyLmZpbHRlcnMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZpbHRlcnMgPSBkYXRhLmZpbHRlci5maWx0ZXJzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVycy5tYXAoKGZpbHRlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IChwYXJhbWV0ZXJNYXBGaWVsZC5maWx0ZXJQcmVmaXgpID8gcGFyYW1ldGVyTWFwRmllbGQuZmlsdGVyUHJlZml4ICsgZmlsdGVyLmZpZWxkIDogZmlsdGVyLmZpZWxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHBhcmFtZXRlck1hcEZpZWxkLmZpbHRlckZpZWxkVG9Mb3dlckNhc2Upe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2ZpZWxkLnRvTG93ZXJDYXNlKCldID0gZmlsdGVyLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2ZpZWxkXSA9IGZpbHRlci52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTb3J0IEFycmF5ID0+IEZpZWxkLCBEaXIgQ29udmVydFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwYXJhbWV0ZXJNYXBGaWVsZC5jb252ZXJ0U29ydCAmJiBkYXRhLnNvcnQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zb3J0Lm1hcCgoc29ydERhdGEpID0+e1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKFwiZmllbGRcIiBpbiBwYXJhbWV0ZXJNYXBGaWVsZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnREYXRhW3BhcmFtZXRlck1hcEZpZWxkLmZpZWxkXSA9IHNvcnREYXRhLmZpZWxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihcImRpclwiIGluIHBhcmFtZXRlck1hcEZpZWxkKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ydERhdGFbcGFyYW1ldGVyTWFwRmllbGQuZGlyXSA9IHNvcnREYXRhLmRpcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBwYWdpbmcg7LKY66as7IucIOyEnOuyhOuhnCDrs7TrgrTsp4DripQg6re466as65OcIOq0gOugqCDrjbDsnbTthLAge3Rha2U6IDIwLCBza2lwOiAwLCBwYWdlOiAxLCBwYWdlU2l6ZTogMjB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gcGFnaW5nIOyymOumrOyLnOyXkOuKlCB7fSDsnYQg7ISc67KE66GcIOuztOuCuOuLpC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBAUmVxdWVzdEJvZHkgR3JpZFBhcmFtIGdyaWRQYXJhbSDroZwg67Cb64qU64ukLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2NoZW1hOiB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXR1cm5lZCBpbiB0aGUgXCJsaXN0RmllbGRcIiBmaWVsZCBvZiB0aGUgcmVzcG9uc2VcclxuICAgICAgICAgICAgICAgIGRhdGE6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhyZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyciA9IFtdLCBncmlkTGlzdCA9IHJlc3BvbnNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihsaXN0RmllbGQgJiYgbGlzdEZpZWxkLmxlbmd0aCA+IDAgJiYgbGlzdEZpZWxkICE9ICdudWxsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIgPSBsaXN0RmllbGQuc3BsaXQoJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpIGluIGFycikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKGFycltpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFncmlkTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JpZExpc3QgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyaWRMaXN0ID0gZ3JpZExpc3RbYXJyW2ldXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdyaWRMaXN0O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8vIHJldHVybmVkIGluIHRoZSBcInRvdGFsRmllbGRcIiBmaWVsZCBvZiB0aGUgcmVzcG9uc2VcclxuICAgICAgICAgICAgICAgIHRvdGFsOiBmdW5jdGlvbihyZXNwb25zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnIgPSBbXSwgdG90YWwgPSByZXNwb25zZTtcclxuICAgICAgICAgICAgICAgICAgICBpZih0b3RhbEZpZWxkICYmIHRvdGFsRmllbGQubGVuZ3RoID4gMCAmJiB0b3RhbEZpZWxkICE9ICdudWxsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIgPSB0b3RhbEZpZWxkLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSBpbiBhcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhhcnJbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighdG90YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsID0gdG90YWxbYXJyW2ldXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvdGFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwYWdlU2l6ZTogX3BhZ2VTaXplLFxyXG4gICAgICAgICAgICBzZXJ2ZXJQYWdpbmc6IF9wYWdlYWJsZSxcclxuICAgICAgICAgICAgc2VydmVyRmlsdGVyaW5nOiBfcGFnZWFibGUsXHJcbiAgICAgICAgICAgIHNlcnZlclNvcnRpbmc6IF9wYWdlYWJsZSxcclxuICAgICAgICAgICAgc29ydDogc29ydFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gZGF0YVNvdXJjZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHNldFNlbGVjdGVkSWRzKHByb3BzKSB7XHJcbiAgICAgICAgY29uc3Qge2NoZWNrRmllbGQsIHNlbGVjdGVkSWRzfSA9IHByb3BzO1xyXG5cclxuICAgICAgICB2YXIgX3NlbGVjdGVkSWRzO1xyXG4gICAgICAgIGlmKHR5cGVvZiBzZWxlY3RlZElkcyAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZWN0ZWRJZHMgIT09IG51bGwgJiYgc2VsZWN0ZWRJZHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBfc2VsZWN0ZWRJZHMgPSBzZWxlY3RlZElkcztcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIF9zZWxlY3RlZElkcyA9IHRoaXMuc2VsZWN0ZWRJZHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0eXBlb2YgX3NlbGVjdGVkSWRzID09PSAndW5kZWZpbmVkJyB8fCBfc2VsZWN0ZWRJZHMgPT09IG51bGwpIHJldHVybjtcclxuXHJcbiAgICAgICAgdmFyIHJvd3MgPSB0aGlzLmdyaWQudGFibGUuZmluZCgndHInKS5maW5kKCd0ZDpmaXJzdCBpbnB1dCcpLmNsb3Nlc3QoJ3RyJyksXHJcbiAgICAgICAgICAgIF90aGlzID0gdGhpcztcclxuXHJcbiAgICAgICAgcm93cy5lYWNoKGZ1bmN0aW9uKGluZGV4LCByb3cpIHtcclxuICAgICAgICAgICAgdmFyICRjaGVja2JveCA9ICQocm93KS5maW5kKCdpbnB1dDpjaGVja2JveC5jaGVja2JveCcpLFxyXG4gICAgICAgICAgICAgICAgZGF0YUl0ZW0gPSBfdGhpcy5ncmlkLmRhdGFJdGVtKHJvdyksXHJcbiAgICAgICAgICAgICAgICBjaGVja2VkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxfc2VsZWN0ZWRJZHMubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihjaGVja0ZpZWxkICE9PSBudWxsICYmIHR5cGVvZiBjaGVja0ZpZWxkICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGRhdGFJdGVtW2NoZWNrRmllbGRdID09IF9zZWxlY3RlZElkc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZigkY2hlY2tib3gudmFsKCkgPT0gX3NlbGVjdGVkSWRzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICRjaGVja2JveC5hdHRyKCdjaGVja2VkJywgY2hlY2tlZCk7XHJcbiAgICAgICAgICAgIF90aGlzLnNlbGVjdENoZWNrYm94KCRjaGVja2JveCwgY2hlY2tlZCwgJChyb3cpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBzZWxlY3RDaGVja2JveCgkY2hlY2tib3gsIGNoZWNrZWQsICRyb3cpIHtcclxuXHJcbiAgICAgICAgdmFyIGRhdGFJdGVtID0gdGhpcy5ncmlkLmRhdGFJdGVtKCRyb3cpO1xyXG5cclxuICAgICAgICBpZih0aGlzLnByb3BzLmNoZWNrRmllbGQgIT09IG51bGwgJiYgdHlwZW9mIHRoaXMucHJvcHMuY2hlY2tGaWVsZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGVja2VkSWRzW2RhdGFJdGVtW3RoaXMucHJvcHMuY2hlY2tGaWVsZF1dID0gY2hlY2tlZDtcclxuICAgICAgICAgICAgdGhpcy5jaGVja2VkSXRlbXNbZGF0YUl0ZW1bdGhpcy5wcm9wcy5jaGVja0ZpZWxkXV0gPSBkYXRhSXRlbTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tlZElkc1skY2hlY2tib3gudmFsKCldID0gY2hlY2tlZDtcclxuICAgICAgICAgICAgdGhpcy5jaGVja2VkSXRlbXNbJGNoZWNrYm94LnZhbCgpXSA9IGRhdGFJdGVtO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoY2hlY2tlZCkge1xyXG4gICAgICAgICAgICAvLy1zZWxlY3QgdGhlIHJvd1xyXG4gICAgICAgICAgICAkcm93LmFkZENsYXNzKFwiay1zdGF0ZS1zZWxlY3RlZFwiKTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIC8vLXJlbW92ZSBzZWxlY3Rpb25cclxuICAgICAgICAgICAgJHJvdy5yZW1vdmVDbGFzcyhcImstc3RhdGUtc2VsZWN0ZWRcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZ2V0Q2hlY2tib3hDb2x1bW4oY2hlY2tib3hGaWVsZCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZpZWxkOiBjaGVja2JveEZpZWxkLFxyXG4gICAgICAgICAgICBoZWFkZXJUZW1wbGF0ZTogJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cImNoZWNrYm94XCIgLz4nLFxyXG4gICAgICAgICAgICAvL2hlYWRlclRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cImNoZWNrYm94XCI+PGxhYmVsPjxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiAvPjwvbGFiZWw+PC9kaXY+JyxcclxuICAgICAgICAgICAgLy9oZWFkZXJBdHRyaWJ1dGVzOiB7XHJcbiAgICAgICAgICAgIC8vICAgICdjbGFzcyc6ICd0YWJsZS1oZWFkZXItY2VsbCcsXHJcbiAgICAgICAgICAgIC8vICAgIHN0eWxlOiAndGV4dC1hbGlnbjogY2VudGVyJ1xyXG4gICAgICAgICAgICAvL30sXHJcbiAgICAgICAgICAgIHRlbXBsYXRlOiAnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwiY2hlY2tib3hcIiB2YWx1ZT1cIiM9JyArIGNoZWNrYm94RmllbGQgKyAnI1wiIC8+JyxcclxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xyXG4gICAgICAgICAgICAgICAgYWxpZ246ICdjZW50ZXInXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHdpZHRoOiA0MCxcclxuICAgICAgICAgICAgc29ydGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBmaWx0ZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgcmVzaXphYmxlOiBmYWxzZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gbWV0aG9kc1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZyZXNoXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZXJ2ZXI9dHJ1ZV0gLSBzZXJ2ZXIgcmVmcmVzaCBvciBub3QuXHJcbiAgICAgKi9cclxuICAgIHJlZnJlc2goc2VydmVyID0gdHJ1ZSkge1xyXG4gICAgICAgIC8vdGhpcy5ncmlkLnJlZnJlc2goKTtcclxuICAgICAgICBpZihzZXJ2ZXIgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy5ncmlkLnNldERhdGFTb3VyY2UodGhpcy5jcmVhdGVEYXRhU291cmNlKHRoaXMucHJvcHMpKTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBkYXRhU291cmNlLlxyXG4gICAgICogQHJldHVybiB7a2VuZG8uZGF0YS5EYXRhU291cmNlfSBHcmlkIGRhdGEgc291cmNlLlxyXG4gICAgICovXHJcbiAgICBnZXREYXRhU291cmNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZGF0YVNvdXJjZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBqUXVlcnkgb2JqZWN0IHdoaWNoIHJlcHJlc2VudHMgdGhlIGdyaWQgY29udGVudCBlbGVtZW50LCB3aGljaCBob2xkcyB0aGUgc2Nyb2xsYWJsZSBjb250ZW50LiBBdmFpbGFibGUgb25seSBpbiBhIGdyaWQgd2l0aCBsb2NrZWQgY29sdW1ucy5cclxuICAgICAqIEByZXR1cm4ge2pRdWVyeX0gR3JpZCBjb250ZW50LlxyXG4gICAgICovXHJcbiAgICBnZXRDb250ZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuY29udGVudDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBzZWxlY3RlZCBpZHMuXHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gR3JpZCBzZWxlY3RlZCBpZHMuXHJcbiAgICAgKi9cclxuICAgIGdldFNlbGVjdGVkSWRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkSWRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHNlbGVjdGVkIGl0ZW1zLlxyXG4gICAgICogQHJldHVybiB7QXJyYXl9IEdyaWQgc2VsZWN0ZWQgaXRlbXMuXHJcbiAgICAgKi9cclxuICAgIGdldFNlbGVjdGVkSXRlbXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRJdGVtcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBTZXQgR3JpZCBDb250ZW50IEhlaWdodFxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcil9IGhlaWdodCAtIEdyaWQgQ29udGVudCBIZWlnaHRcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gR3JpZCBDb250ZW50IEhlaWdodFxyXG4gICAgICovXHJcbiAgICBjb250ZW50SGVpZ2h0KGhlaWdodCkge1xyXG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kZ3JpZC5maW5kKCcuay1ncmlkLWNvbnRlbnQnKS5oZWlnaHQoKTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRncmlkLmZpbmQoJy5rLWdyaWQtY29udGVudCcpLmhlaWdodChoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3IgU2V0IEdyaWQgSGVhZGVyIEhlaWdodFxyXG4gICAgICogQHBhcmFtIHsoc3RyaW5nfG51bWJlcil9IGhlaWdodCAtIEdyaWQgSGVhZGVyIEhlaWdodFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBHcmlkIEhlYWRlciBIZWlnaHRcclxuICAgICAqL1xyXG4gICAgaGVhZGVySGVpZ2h0KGhlaWdodCkge1xyXG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kZ3JpZC5maW5kKCcuay1ncmlkLWhlYWRlcicpLmhlaWdodCgpO1xyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGdyaWQuZmluZCgnLmstZ3JpZC1oZWFkZXInKS5oZWlnaHQoaGVpZ2h0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyBhIGRhdGEgaXRlbSB0byB0aGUgZGF0YSBzb3VyY2UuXHJcbiAgICAgKiBAcGFyYW0geyhvYmplY3R8a2VuZG8uZGF0YS5Nb2RlbCl9IGRhdGFJdGVtIC0gdGhlIGRhdGEgaXRlbSB0byB3aGljaCB0aGUgc3BlY2lmaWVkIHRhYmxlIHJvdyBpcyBib3VuZC4gVGhlIGRhdGEgaXRlbSBpcyBhIEtlbmRvIFVJIE1vZGVsIGluc3RhbmNlLlxyXG4gICAgICogQHJldHVybiB7a2VuZG8uZGF0YS5Nb2RlbH0gdGhlIGRhdGEgaXRlbSB3aGljaCBpcyBpbnNlcnRlZC5cclxuICAgICAqL1xyXG4gICAgYWRkSXRlbShkYXRhSXRlbSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQuZGF0YVNvdXJjZS5hZGQoZGF0YUl0ZW0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGRhdGEgaXRlbSBmcm9tIHRoZSBkYXRhIHNvdXJjZS5cclxuICAgICAqIEBwYXJhbSB7KG9iamVjdHxrZW5kby5kYXRhLk1vZGVsKX0gZGF0YUl0ZW0gLSB0aGUgZGF0YSBpdGVtIHRvIHdoaWNoIHRoZSBzcGVjaWZpZWQgdGFibGUgcm93IGlzIGJvdW5kLiBUaGUgZGF0YSBpdGVtIGlzIGEgS2VuZG8gVUkgTW9kZWwgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUl0ZW0oZGF0YUl0ZW0pIHtcclxuICAgICAgICB0aGlzLmdyaWQuZGF0YVNvdXJjZS5yZW1vdmUoZGF0YUl0ZW0pO1xyXG5cclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5jaGVja0ZpZWxkID09PSAndW5kZWZpbmVkJyB8fCAhdGhpcy5wcm9wcy5jaGVja0ZpZWxkKSByZXR1cm47XHJcbiAgICAgICAgdGhpcy5jaGVja2VkSWRzW2RhdGFJdGVtW3RoaXMucHJvcHMuY2hlY2tGaWVsZF1dID0gZmFsc2U7XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnNlbGVjdGVkSWRzID09PSAndW5kZWZpbmVkJyB8fCAhdGhpcy5zZWxlY3RlZElkcykgcmV0dXJuO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuc2VsZWN0ZWRJZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYodGhpcy5zZWxlY3RlZElkc1tpXSA9PT0gZGF0YUl0ZW1bdGhpcy5wcm9wcy5jaGVja0ZpZWxkXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZElkcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbXMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgZGF0YSBpdGVtcyBvZiB0aGUgZ3JpZCdzIGRhdGEgc291cmNlLlxyXG4gICAgICogQHBhcmFtIHsoQXJyYXl8a2VuZG8uZGF0YS5PYnNlcnZhYmxlQXJyYXkpfSBpdGVtcyAtIHRoZSBkYXRhIGl0ZW1zIG9mIHRoZSBncmlkJ3MgZGF0YSBzb3VyY2UuXHJcbiAgICAgKiBAcmV0dXJuIHtrZW5kby5kYXRhLk9ic2VydmFibGVBcnJheX0gdGhlIGRhdGEgaXRlbXMgb2YgdGhlIGdyaWQncyBkYXRhIHNvdXJjZS5cclxuICAgICAqL1xyXG4gICAgc2V0SXRlbXMoaXRlbXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmRhdGFTb3VyY2UuZGF0YShpdGVtcyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGRhdGEgaXRlbXMgb2YgdGhlIGdyaWQncyBkYXRhIHNvdXJjZS5cclxuICAgICAqIEByZXR1cm4ge2tlbmRvLmRhdGEuT2JzZXJ2YWJsZUFycmF5fSB0aGUgZGF0YSBpdGVtcyBvZiB0aGUgZ3JpZCdzIGRhdGEgc291cmNlLlxyXG4gICAgICovXHJcbiAgICBnZXRJdGVtcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmRhdGFTb3VyY2UuZGF0YSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZHJhZ2dhYmxlXHJcbiAgICAgKi9cclxuICAgIGRyYWdnYWJsZSgpIHtcclxuICAgICAgICB0aGlzLmdyaWQuY29udGVudC5rZW5kb0RyYWdnYWJsZSh7XHJcbiAgICAgICAgICAgIGZpbHRlcjogJ3RyJyxcclxuICAgICAgICAgICAgaGludDogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuY2xvbmUoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGRyb3AgdGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0geyhrZW5kby51aS5XaWRnZXR8ZnVuY3Rpb24pfSB3aWRnZXQgLSBXaWRnZXQgb3IgZnVuY3Rpb25cclxuICAgICAqL1xyXG4gICAgZHJvcFRhcmdldCh3aWRnZXQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLCBkcm9wRnVuYztcclxuXHJcbiAgICAgICAgLy8gZS5kcmFnZ2FibGUvZS5kcm9wVGFyZ2V0IChqUXVlcnkpL2UudGFyZ2V0IEVsZW1lbnRcclxuICAgICAgICAvL19kcm9wRnVuYyhlKTtcclxuXHJcbiAgICAgICAgaWYodHlwZW9mIHdpZGdldCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBkcm9wRnVuYyA9IHdpZGdldDtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIGRyb3BGdW5jID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGFJdGVtID0gd2lkZ2V0LmRhdGFJdGVtKGUuZHJhZ2dhYmxlLmN1cnJlbnRUYXJnZXQpOy8vZHJhZ0RhdGFTb3VyY2UuZ2V0QnlVaWQoZS5kcmFnZ2FibGUuY3VycmVudFRhcmdldC5kYXRhKCd1aWQnKSk7XHJcbiAgICAgICAgICAgICAgICBpZih0eXBlb2Ygd2lkZ2V0LnJlbW92ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZGdldC5yZW1vdmUoZS5kcmFnZ2FibGUuY3VycmVudFRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5ncmlkLmRhdGFTb3VyY2UuYWRkKGRhdGFJdGVtKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2UuZHJhZ2dhYmxlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgIC8vZS5kcmFnZ2FibGUuZWxlbWVudC5jc3MoJ29wYWNpdHknLCAwLjMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmdyaWQuY29udGVudC5rZW5kb0Ryb3BUYXJnZXQoe1xyXG4gICAgICAgICAgICBkcmFnZW50ZXI6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGUuZHJhZ2dhYmxlLmhpbnQuY3NzKCdvcGFjaXR5JywgMC43KTsgICAgICAgICAgIC8vbW9kaWZ5IHRoZSBkcmFnZ2FibGUgaGludFxyXG4gICAgICAgICAgICAgICAgZS5kcm9wVGFyZ2V0LmFkZENsYXNzKCdkcm9wdGFyZ2V0LWFjdGl2ZScpOyAgICAgLy9tb2RpZnkgZHJvcFRhcmdldCBlbGVtZW50XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdsZWF2ZTogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgZS5kcmFnZ2FibGUuaGludC5jc3MoJ29wYWNpdHknLCAxKTsgICAgICAgICAgICAgLy9tb2RpZnkgdGhlIGRyYWdnYWJsZSBoaW50XHJcbiAgICAgICAgICAgICAgICBlLmRyb3BUYXJnZXQucmVtb3ZlQ2xhc3MoJ2Ryb3B0YXJnZXQtYWN0aXZlJyk7ICAvL21vZGlmeSBkcm9wVGFyZ2V0IGVsZW1lbnRcclxuXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyb3A6IGRyb3BGdW5jXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBkcmFnIHNvcnRhYmxlXHJcbiAgICAgKi9cclxuICAgIGRyYWdTb3J0YWJsZSgpIHtcclxuICAgICAgICB0aGlzLmdyaWQuY29udGVudC5jc3MoJ2N1cnNvcicsICdtb3ZlJyk7XHJcblxyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5ncmlkLnRhYmxlLmtlbmRvU29ydGFibGUoe1xyXG4gICAgICAgICAgICBmaWx0ZXI6ICc+dGJvZHkgPnRyJyxcclxuICAgICAgICAgICAgY3Vyc29yOiAnbW92ZScsXHJcbiAgICAgICAgICAgIGhpbnQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHsgLy9jdXN0b21pemUgdGhlIGhpbnRcclxuICAgICAgICAgICAgICAgIC8vdmFyIHRhYmxlID0gJCgnPHRhYmxlIHN0eWxlPVwid2lkdGg6IDYwMHB4O1wiIGNsYXNzPVwiay1ncmlkIGstd2lkZ2V0XCI+PC90YWJsZT4nKSxcclxuICAgICAgICAgICAgICAgIC8vICAgIGhpbnQ7XHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy90YWJsZS5hcHBlbmQoZWxlbWVudC5jbG9uZSgpKTsgLy9hcHBlbmQgdGhlIGRyYWdnZWQgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgLy90YWJsZS5jc3MoJ29wYWNpdHknLCAwLjcpO1xyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vcmV0dXJuIHRhYmxlOyAvL3JldHVybiB0aGUgaGludCBlbGVtZW50XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gX3RoaXMuZ3JpZC50YWJsZS5jbG9uZSgpLCAvLyBDbG9uZSBHcmlkJ3MgdGFibGVcclxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyV2lkdGggPSBfdGhpcy5ncmlkLndyYXBwZXIud2lkdGgoKSwgLy9nZXQgR3JpZCdzIHdpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgd3JhcHBlciA9ICQoJzxkaXYgY2xhc3M9XCJrLWdyaWQgay13aWRnZXRcIj48L2Rpdj4nKS53aWR0aCh3cmFwcGVyV2lkdGgpLFxyXG4gICAgICAgICAgICAgICAgICAgIGhpbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgdGFibGUuZmluZCgndGhlYWQnKS5yZW1vdmUoKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBHcmlkJ3MgaGVhZGVyIGZyb20gdGhlIGhpbnRcclxuICAgICAgICAgICAgICAgIHRhYmxlLmZpbmQoJ3Rib2R5JykuZW1wdHkoKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGV4aXN0aW5nIHJvd3MgZnJvbSB0aGUgaGludFxyXG4gICAgICAgICAgICAgICAgdGFibGUud3JhcCh3cmFwcGVyKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdyYXAgdGhlIHRhYmxlXHJcbiAgICAgICAgICAgICAgICB0YWJsZS5hcHBlbmQoZWxlbWVudC5jbG9uZSgpLnJlbW92ZUF0dHIoJ3VpZCcpKTsgICAgLy8gQXBwZW5kIHRoZSBkcmFnZ2VkIGVsZW1lbnRcclxuXHJcbiAgICAgICAgICAgICAgICBoaW50ID0gdGFibGUucGFyZW50KCk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB3cmFwcGVyXHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpbnQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgaGludCBlbGVtZW50XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5jbG9uZSgpLmFkZENsYXNzKCdrLXNvcnRhYmxlLXBsYWNlaG9sZGVyJyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbnRhaW5lcjogJyMnK3RoaXMuaWQrJyB0Ym9keScsXHJcbiAgICAgICAgICAgIGNoYW5nZTogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9sZEluZGV4ID0gZS5vbGRJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBuZXdJbmRleCA9IGUubmV3SW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IF90aGlzLmdyaWQuZGF0YVNvdXJjZS5kYXRhKCksXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YUl0ZW0gPSBfdGhpcy5ncmlkLmRhdGFTb3VyY2UuZ2V0QnlVaWQoZS5pdGVtLmRhdGEoJ3VpZCcpKTtcclxuXHJcbiAgICAgICAgICAgICAgICBfdGhpcy5ncmlkLmRhdGFTb3VyY2UucmVtb3ZlKGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmdyaWQuZGF0YVNvdXJjZS5pbnNlcnQobmV3SW5kZXgsIGRhdGFJdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGV2ZW50c1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSB3aWRnZXQgaXMgYm91bmQgdG8gZGF0YSBmcm9tIGl0cyBkYXRhIHNvdXJjZS5cclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGUgLSBldmVudCwgZXZlbnQgZGF0YSBlLnNlbmRlciBrZW5kby51aS5HcmlkXHJcbiAgICAgKiBAcGFyYW0ge2tlbmRvLmRhdGEuT2JzZXJ2YWJsZUFycmF5fSBkYXRhIC0gdGhlIGRhdGEgaXRlbXMgb2YgdGhlIGRhdGEgc291cmNlLlxyXG4gICAgICovXHJcbiAgICBvbkRhdGFCb3VuZChlKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnZGF0YUJvdW5kJywgZSk7XHJcblxyXG4gICAgICAgIC8vIHNlbGVjdGVkIGNoZWNrXHJcbiAgICAgICAgdGhpcy5zZXRTZWxlY3RlZElkcyh0aGlzLnByb3BzKTtcclxuXHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMub25EYXRhQm91bmQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdyaWQuZGF0YVNvdXJjZS5kYXRhKCk7Ly9lLnNlbmRlci5kYXRhU291cmNlLmRhdGEoKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkRhdGFCb3VuZChlLCBkYXRhKTtcclxuICAgICAgICAgICAgLy9ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCBiZWZvcmUgdGhlIHdpZGdldCBiaW5kcyB0byBpdHMgZGF0YSBzb3VyY2UuXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlIC0gZXZlbnQsIGV2ZW50IGRhdGEgZS5zZW5kZXIga2VuZG8udWkuR3JpZFxyXG4gICAgICogQHBhcmFtIHtrZW5kby5kYXRhLk9ic2VydmFibGVBcnJheX0gZGF0YSAtIHRoZSBkYXRhIGl0ZW1zIG9mIHRoZSBkYXRhIHNvdXJjZS5cclxuICAgICAqL1xyXG4gICAgb25EYXRhQmluZGluZyhlKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnb25EYXRhQmluZGluZycsIGUpO1xyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uRGF0YUJpbmRpbmcgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdyaWQuZGF0YVNvdXJjZS5kYXRhKCk7Ly9lLnNlbmRlci5kYXRhU291cmNlLmRhdGEoKTtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkRhdGFCaW5kaW5nKGUsIGRhdGEpO1xyXG4gICAgICAgICAgICAvL2V2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBrZW5kbyBhcGnripQg7J6I64qU642wIOyLpOygnCDtlbTrs7TrqbQg7JWI65CoXHJcbiAgICAvL3NvcnQ6IGZ1bmN0aW9uKGZpZWxkLCBkaXIpIHtcclxuICAgIC8vICAgIHZhciBvcHRpb25zID0gdGhpcy5ncmlkLm9wdGlvbnMoKSxcclxuICAgIC8vICAgICAgICBkYXRhU291cmNlID0gb3B0aW9ucy5kYXRhU291cmNlO1xyXG4gICAgLy8gICAgY29uc29sZS5sb2coZGF0YVNvdXJjZSk7XHJcbiAgICAvL1xyXG4gICAgLy8gICAgZGF0YVNvdXJjZS5zb3J0KHsgZmllbGQ6IGZpZWxkLCBkaXI6IGRpciB9KTsgLy8gZGlyOiBhc2MvZGVzY1xyXG4gICAgLy99LFxyXG4gICAgLypcclxuICAgICogR3JpZCBDaGFuZ2UgRXZlbnQoU2VsZWN0IEV2ZW50KSwgZGF0YVNldOycvOuhnCDsoJXsnZjtlZjsl6wg67Cb64qU64ukLlxyXG4gICAgKiByb3dJbmRleFxyXG4gICAgKiBjZWxsSW5kZXhcclxuICAgICogZGF0YVxyXG4gICAgKiByb3dzXHJcbiAgICAqL1xyXG4gICAgb25DaGFuZ2UoKSB7XHJcbiAgICAgICAgbGV0IGdyaWQgPSB0aGlzLmdyaWQ7XHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMub25DaGFuZ2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgLy92YXIgZGF0YSA9IGV2ZW50Lm5vZGU7XHJcbiAgICAgICAgICAgIGxldCBkYXRhU2V0ID0ge307XHJcbiAgICAgICAgICAgIGlmKHRoaXMucHJvcHMuc2VsZWN0TW9kZSA9PT0gXCJjZWxsXCIpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHJvdyA9ICQoZ3JpZC5zZWxlY3QoKSkuY2xvc2VzdChcInRyXCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNlbGwgPSBncmlkLnNlbGVjdCgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGNlbGxUZXh0ID0gJChjZWxsKS50ZXh0KCk7XHJcbiAgICAgICAgICAgICAgICBkYXRhU2V0LnJvd0luZGV4ID0gJChcInRyXCIsIGdyaWQudGJvZHkpLmluZGV4KHJvdyk7XHJcbiAgICAgICAgICAgICAgICBkYXRhU2V0LmNlbGxJbmRleCA9IGdyaWQuY2VsbEluZGV4KGNlbGwpO1xyXG4gICAgICAgICAgICAgICAgZGF0YVNldC5kYXRhID0gJChjZWxsKS50ZXh0KCk7XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgbGV0IHJvd3MgPSBncmlkLnNlbGVjdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKHJvd3MubGVuZ3RoID4gMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJvd3NEYXRhID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgcm93cy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93c0RhdGEucHVzaChncmlkLmRhdGFJdGVtKCQodGhpcykpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhU2V0LnJvd3MgPSByb3dzO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFTZXQuZGF0YSA9IHJvd3NEYXRhO1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVNldC5yb3dzID0gcm93cztcclxuICAgICAgICAgICAgICAgICAgICBkYXRhU2V0LmRhdGEgPSBncmlkLmRhdGFJdGVtKHJvd3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoZGF0YVNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uU2VsZWN0Um93KGV2ZW50KSB7XHJcblxyXG4gICAgICAgIHZhciBpZHMgPSBbXSwgaXRlbXMgPSBbXTtcclxuICAgICAgICBmb3IodmFyIGtleSBpbiB0aGlzLmNoZWNrZWRJZHMpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5jaGVja2VkSWRzW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIGlkcy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKHRoaXMuY2hlY2tlZEl0ZW1zW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGVkSWRzID0gaWRzO1xyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtcyA9IGl0ZW1zO1xyXG5cclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vblNlbGVjdFJvdyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uU2VsZWN0Um93KGV2ZW50LCBpZHMsIGl0ZW1zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBvbkNoZWNrYm94SGVhZGVyKGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIGNoZWNrZWQgPSAkKGV2ZW50LnRhcmdldCkuaXMoJzpjaGVja2VkJyk7XHJcblxyXG4gICAgICAgIHZhciByb3dzID0gdGhpcy5ncmlkLnRhYmxlLmZpbmQoXCJ0clwiKS5maW5kKFwidGQ6Zmlyc3QgaW5wdXRcIikuY2xvc2VzdChcInRyXCIpLFxyXG4gICAgICAgICAgICBfdGhpcyA9IHRoaXM7XHJcblxyXG4gICAgICAgIHJvd3MuZWFjaChmdW5jdGlvbihpbmRleCwgcm93KSB7XHJcbiAgICAgICAgICAgIHZhciAkY2hlY2tib3ggPSAkKHJvdykuZmluZCgnaW5wdXQ6Y2hlY2tib3guY2hlY2tib3gnKTtcclxuICAgICAgICAgICAgJGNoZWNrYm94LmF0dHIoJ2NoZWNrZWQnLCBjaGVja2VkKTtcclxuXHJcbiAgICAgICAgICAgIF90aGlzLnNlbGVjdENoZWNrYm94KCRjaGVja2JveCwgY2hlY2tlZCwgJChyb3cpKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5vblNlbGVjdFJvdyhldmVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBvbkNoZWNrYm94Um93KGV2ZW50KSB7XHJcbiAgICAgICAgdmFyIGNoZWNrZWQgPSBldmVudC50YXJnZXQuY2hlY2tlZCxcclxuICAgICAgICAgICAgJHJvdyA9ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KCd0cicpO1xyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdENoZWNrYm94KCQoZXZlbnQudGFyZ2V0KSwgY2hlY2tlZCwgJHJvdyk7XHJcbiAgICAgICAgdGhpcy5vblNlbGVjdFJvdyhldmVudCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vb25EYXRhQm91bmQ6IGZ1bmN0aW9uKGFyZykge1xyXG4gICAgLy8gICAgLy8gc2VsZWN0ZWQgY2hlY2tcclxuICAgIC8vICAgIHRoaXMuc2V0U2VsZWN0ZWRJZHModGhpcy5wcm9wcyk7XHJcbiAgICAvL30sXHJcbiAgICBcclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICAvLyDtlYTsiJgg7ZWt66qpXHJcbiAgICAgICAgY29uc3Qge2NsYXNzTmFtZX0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2IGlkPXt0aGlzLmlkfSBjbGFzc05hbWU9e2NsYXNzTmFtZXMoY2xhc3NOYW1lKX0+PC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuR3JpZC5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XHJcbkdyaWQuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgR3JpZDsiLCIvKipcclxuICogTXVsdGlTZWxlY3QgY29tcG9uZW50XHJcbiAqXHJcbiAqIHZlcnNpb24gPHR0PiQgVmVyc2lvbjogMS4wICQ8L3R0PiBkYXRlOjIwMTYvMDgvMjNcclxuICogYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86aHJhaG5AbmtpYS5jby5rclwiPkFobiBIeXVuZy1SbzwvYT5cclxuICpcclxuICogZXhhbXBsZTpcclxuICogPFB1Zi5NdWx0aVNlbGVjdCBvcHRpb25zPXtvcHRpb25zfSAvPlxyXG4gKlxyXG4gKiBLZW5kbyBNdWx0aVNlbGVjdCDrnbzsnbTruIzrn6zrpqzsl5Ag7KKF7IaN7KCB7J2064ukLlxyXG4gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IFV0aWwgZnJvbSAnLi4vc2VydmljZXMvVXRpbCc7XHJcblxyXG5jb25zdCBwcm9wVHlwZXMgPSB7XHJcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIG5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBob3N0OiBQcm9wVHlwZXMuc3RyaW5nLCAgICAgICAgICAgICAgICAgLy8g7ISc67KEIOygleuztChDcm9zcyBCcm93c2VyIEFjY2VzcylcclxuICAgIHVybDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIG1ldGhvZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGRhdGE6IFByb3BUeXBlcy5vYmplY3QsXHJcbiAgICBpdGVtczogUHJvcFR5cGVzLmFycmF5LFxyXG4gICAgc2VsZWN0ZWRWYWx1ZXM6IFByb3BUeXBlcy5hcnJheSxcclxuICAgIHBsYWNlaG9sZGVyOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgbGlzdEZpZWxkOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgZGF0YVRleHRGaWVsZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGRhdGFWYWx1ZUZpZWxkOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgbXVsdGlwbGU6IFByb3BUeXBlcy5ib29sLCAgICAgICAgICAgICAgIC8vIOuLpOykkeyEoO2DneydhCDsp4Dsm5DtlZjrqbAsIOuLq+2eiOyngCDslYrqs6Ag7Jes65+s6rCc66W8IOyEoO2Dne2VoCDsiJgg7J6I64ukLlxyXG4gICAgaGVhZGVyVGVtcGxhdGU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBpdGVtVGVtcGxhdGU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICB0YWdUZW1wbGF0ZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcclxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHJlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uU2VsZWN0OiBQcm9wVHlwZXMuZnVuYyxcclxuICAgIG9uRGVzZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25PcGVuOiBQcm9wVHlwZXMuZnVuYyxcclxuICAgIG9uQ2xvc2U6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25GaWx0ZXJpbmc6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25EYXRhQm91bmQ6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25Mb2FkQ29tcGxldGU6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgbWluTGVuZ3RoOiBQcm9wVHlwZXMubnVtYmVyLCAgICAgICAgICAgIC8vIOqygOyDieyLnCDtlYTsmpTtlZwg7LWc7IaMIOuLqOyWtCDquLjsnbRcclxuICAgIG1heFNlbGVjdGVkSXRlbXM6IFByb3BUeXBlcy5udW1iZXIsICAgICAvLyDstZzrjIAg7ISg7YOdIOyImFxyXG4gICAgcGFyYW1ldGVyTWFwRmllbGQ6IFByb3BUeXBlcy5vYmplY3QsICAgIC8vIFBhZ2luZywgRmlsdGVySnNvblxyXG4gICAgc2VydmVyRmlsdGVyaW5nOiBQcm9wVHlwZXMuYm9vbCwgICAgICAgIC8vIOyEnOuyhCBGaWx0ZXJpbmco6rKA7IOJ7KGw6rG07JeQIOuUsOuluCDrpqzsiqTtirjsl4UpXHJcbiAgICBmaWx0ZXJGaWVsZHM6IFByb3BUeXBlcy5hcnJheSAgICAgICAgICAgLy8g7ZWE7YSwIO2VhOuTnCDsoJXsnZgob3LroZwg64uk7KSRIOqygOyDieyLnCDsoJzqs7UpXHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XHJcbiAgICBtZXRob2Q6ICdQT1NUJywgXHJcbiAgICBpdGVtczogW10sIFxyXG4gICAgbGlzdEZpZWxkOiAncmVzdWx0VmFsdWUnLCBcclxuICAgIHBsYWNlaG9sZGVyOiAkcHNfbG9jYWxlLnNlbGVjdCwgXHJcbiAgICBkYXRhVGV4dEZpZWxkOiAndGV4dCcsIFxyXG4gICAgZGF0YVZhbHVlRmllbGQ6ICd2YWx1ZScsIFxyXG4gICAgbXVsdGlwbGU6IGZhbHNlLCBcclxuICAgIG1pbkxlbmd0aDogMCwgXHJcbiAgICBtYXhTZWxlY3RlZEl0ZW1zOiBudWxsLCBcclxuICAgIHNlcnZlckZpbHRlcmluZzogZmFsc2UsIFxyXG4gICAgZmlsdGVyRmllbGRzOiBudWxsLFxyXG4gICAgZGlzYWJsZWQ6IGZhbHNlXHJcbn07XHJcblxyXG4vKiogQ2xhc3MgcmVwcmVzZW50aW5nIGEgTXVsdGlTZWxlY3QuICovXHJcbmNsYXNzIE11bHRpU2VsZWN0IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG5cclxuICAgICAgICAvLyBNYW51YWxseSBiaW5kIHRoaXMgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuLi5cclxuICAgICAgICB0aGlzLm9uU2VsZWN0ID0gdGhpcy5vblNlbGVjdC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25EZXNlbGVjdCA9IHRoaXMub25EZXNlbGVjdC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSB0aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbk9wZW4gPSB0aGlzLm9uT3Blbi5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25DbG9zZSA9IHRoaXMub25DbG9zZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25GaWx0ZXJpbmcgPSB0aGlzLm9uRmlsdGVyaW5nLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbkRhdGFCb3VuZCA9IHRoaXMub25EYXRhQm91bmQuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9uTG9hZENvbXBsZXRlID0gdGhpcy5vbkxvYWRDb21wbGV0ZS5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcclxuICAgICAgICAvLyDstZzstIgg66CM642U66eB7J20IOydvOyWtOuCmOq4sCDsp4HsoIQo7ZWc67KIIO2YuOy2nClcclxuICAgICAgICBsZXQgaWQgPSB0aGlzLnByb3BzLmlkO1xyXG4gICAgICAgIGlmKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWQgPSBVdGlsLmdldFVVSUQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAvLyDstZzstIgg66CM642U66eB7J20IOydvOyWtOuCnCDri6TsnYwo7ZWc67KIIO2YuOy2nClcclxuICAgICAgICB0aGlzLiRtdWx0aVNlbGVjdCA9ICQoJyMnK3RoaXMuaWQpO1xyXG4gICAgICAgIHRoaXMubXVsdGlTZWxlY3QgPSB0aGlzLiRtdWx0aVNlbGVjdC5rZW5kb011bHRpU2VsZWN0KHRoaXMub3B0aW9ucygpKS5kYXRhKCdrZW5kb011bHRpU2VsZWN0Jyk7XHJcblxyXG4gICAgICAgIC8vIEV2ZW50c1xyXG4gICAgICAgIHRoaXMubXVsdGlTZWxlY3QuYmluZCgnc2VsZWN0JywgdGhpcy5vblNlbGVjdCk7XHJcbiAgICAgICAgdGhpcy5tdWx0aVNlbGVjdC5iaW5kKCdkZXNlbGVjdCcsIHRoaXMub25EZXNlbGVjdCk7XHJcbiAgICAgICAgdGhpcy5tdWx0aVNlbGVjdC5iaW5kKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlKTtcclxuICAgICAgICB0aGlzLm11bHRpU2VsZWN0LmJpbmQoJ29wZW4nLCB0aGlzLm9uT3Blbik7XHJcbiAgICAgICAgdGhpcy5tdWx0aVNlbGVjdC5iaW5kKCdjbG9zZScsIHRoaXMub25DbG9zZSk7XHJcbiAgICAgICAgdGhpcy5tdWx0aVNlbGVjdC5iaW5kKCdmaWx0ZXJpbmcnLCB0aGlzLm9uRmlsdGVyaW5nKTtcclxuICAgICAgICB0aGlzLm11bHRpU2VsZWN0LmJpbmQoJ2RhdGFCb3VuZCcsIHRoaXMub25EYXRhQm91bmQpO1xyXG5cclxuICAgICAgICAgLy8gcmVhZE9ubHlcclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5yZWFkT25seSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWFkT25seSh0aGlzLnByb3BzLnJlYWRPbmx5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcclxuICAgICAgICAvLyDsu7Ttj6zrhIztirjqsIAg7IOI66Gc7Jq0IHByb3Bz66W8IOuwm+ydhCDrlYwg7Zi47LacKOy1nOy0iCDroIzrjZTrp4Eg7Iuc7JeQ64qUIO2YuOy2nOuQmOyngCDslYrsnYwpXHJcbiAgICAgICAgaWYodHlwZW9mIG5leHRQcm9wcy5zZWxlY3RlZFZhbHVlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5tdWx0aVNlbGVjdC52YWx1ZShuZXh0UHJvcHMuc2VsZWN0ZWRWYWx1ZXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodHlwZW9mIG5leHRQcm9wcy5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmFibGUoIW5leHRQcm9wcy5kaXNhYmxlZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0eXBlb2YgbmV4dFByb3BzLnJlYWRPbmx5ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWRPbmx5KG5leHRQcm9wcy5yZWFkT25seSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgb3B0aW9ucygpIHtcclxuICAgICAgICBjb25zdCB7IGhvc3QsIHVybCwgZGF0YSwgbWV0aG9kLCBpdGVtcywgc2VsZWN0ZWRWYWx1ZXMsIHBsYWNlaG9sZGVyLFxyXG4gICAgICAgICAgICAgICAgbGlzdEZpZWxkLCBkYXRhVGV4dEZpZWxkLCBkYXRhVmFsdWVGaWVsZCxcclxuICAgICAgICAgICAgICAgIGhlYWRlclRlbXBsYXRlLCBpdGVtVGVtcGxhdGUsIHRhZ1RlbXBsYXRlLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0LCBkaXNhYmxlZCwgbXVsdGlwbGUsIG1pbkxlbmd0aCwgbWF4U2VsZWN0ZWRJdGVtcyxcclxuICAgICAgICAgICAgICAgIHBhcmFtZXRlck1hcEZpZWxkLCBzZXJ2ZXJGaWx0ZXJpbmcsIGZpbHRlckZpZWxkcyB9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlcixcclxuICAgICAgICAgICAgZGF0YVRleHRGaWVsZDogZGF0YVRleHRGaWVsZCxcclxuICAgICAgICAgICAgZGF0YVZhbHVlRmllbGQ6IGRhdGFWYWx1ZUZpZWxkLFxyXG4gICAgICAgICAgICBlbmFibGU6ICFkaXNhYmxlZFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIGRhdGFTb3VyY2VcclxuICAgICAgICAvLyB1cmxcclxuICAgICAgICBpZih0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7IGRhdGFTb3VyY2U6IHtcclxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAoaG9zdCAmJiBob3N0ICE9PSBudWxsICYmIGhvc3QubGVuZ3RoID4gMCkgPyBob3N0ICsgdXJsIDogdXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBtZXRob2QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsICAgICAgLy8gc2VhcmNoIChAUmVxdWVzdEJvZHkgR3JpZFBhcmFtIGdyaWRQYXJhbSDroZwg67Cb64qU64ukLilcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04J1xyXG4gICAgICAgICAgICAgICAgICAgIH0vKixcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJNYXA6IGZ1bmN0aW9uKGRhdGEsIHR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZSA9PSBcInJlYWRcIiAmJiBwYXJhbWV0ZXJNYXBGaWVsZCAhPT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDrjbDsnbTthLAg7J297Ja07Jis65WMIO2VhOyalO2VnCDrjbDsnbTthLAoZXg67Y6Y7J207KeA6rSA66CoKeqwgCDsnojsnLzrqbQgZGF0YeulvCBjb3B57ZWc64ukLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBjb3B5IGluIHBhcmFtZXRlck1hcEZpZWxkKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgcGFyYW1ldGVyTWFwRmllbGRbY29weV0gPT09IFwic3RyaW5nXCIgJiYgKCBjb3B5IGluIGRhdGEgKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbcGFyYW1ldGVyTWFwRmllbGRbY29weV1dID0gZGF0YVtjb3B5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYocGFyYW1ldGVyTWFwRmllbGQuZmlsdGVyc1RvSnNvbiAmJiBkYXRhLmZpbHRlciAmJiBkYXRhLmZpbHRlci5maWx0ZXJzKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgQXJyYXkgPT4gSnNvbiBPYmplY3QgQ29weVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWx0ZXJzID0gZGF0YS5maWx0ZXIuZmlsdGVycztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJzLm1hcCgoZmlsdGVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaWVsZCA9IChwYXJhbWV0ZXJNYXBGaWVsZC5maWx0ZXJQcmVmaXgpID8gcGFyYW1ldGVyTWFwRmllbGQuZmlsdGVyUHJlZml4ICsgZmlsdGVyLmZpZWxkIDogZmlsdGVyLmZpZWxkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwYXJhbWV0ZXJNYXBGaWVsZC5maWx0ZXJGaWVsZFRvTG93ZXJDYXNlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbZmllbGQudG9Mb3dlckNhc2UoKV0gPSBmaWx0ZXIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtmaWVsZF0gPSBmaWx0ZXIudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2NoZW1hOiB7XHJcbiAgICAgICAgICAgICAgICAgICAvLyByZXR1cm5lZCBpbiB0aGUgXCJsaXN0RmllbGRcIiBmaWVsZCBvZiB0aGUgcmVzcG9uc2VcclxuICAgICAgICAgICAgICAgICAgIGRhdGE6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RGaWVsZHMgPSBbXSwgZGF0YUxpc3QgPSByZXNwb25zZTtcclxuICAgICAgICAgICAgICAgICAgICAgICBpZihsaXN0RmllbGQgJiYgbGlzdEZpZWxkLmxlbmd0aCA+IDAgJiYgbGlzdEZpZWxkICE9ICdudWxsJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0RmllbGRzID0gbGlzdEZpZWxkLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RGaWVsZHMubWFwKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZpZWxkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUxpc3QgPSBkYXRhTGlzdFtmaWVsZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhTGlzdDtcclxuICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzZXJ2ZXJGaWx0ZXJpbmc6IHNlcnZlckZpbHRlcmluZyxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RFbmQ6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGUudHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBlLnJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAncmVhZCcgJiYgcmVzcG9uc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkxvYWRDb21wbGV0ZShlLCByZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICAgICAgICAgIH0gfSk7XHJcblxyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgJC5leHRlbmQob3B0aW9ucywgeyBkYXRhU291cmNlOiBpdGVtcyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNlbGVjdGVkVmFsdWVzXHJcbiAgICAgICAgaWYodHlwZW9mIHNlbGVjdGVkVmFsdWVzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7IHZhbHVlOiBzZWxlY3RlZFZhbHVlcyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGhlYWRlclRlbXBsYXRlXHJcbiAgICAgICAgaWYodHlwZW9mIGhlYWRlclRlbXBsYXRlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7IGhlYWRlclRlbXBsYXRlOiBoZWFkZXJUZW1wbGF0ZSB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGl0ZW1UZW1wbGF0ZVxyXG4gICAgICAgIGlmKHR5cGVvZiBpdGVtVGVtcGxhdGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKG9wdGlvbnMsIHsgaXRlbVRlbXBsYXRlOiBpdGVtVGVtcGxhdGUgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0YWdUZW1wbGF0ZVxyXG4gICAgICAgIGlmKHR5cGVvZiB0YWdUZW1wbGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQob3B0aW9ucywgeyB0YWdUZW1wbGF0ZTogdGFnVGVtcGxhdGUgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBoZWlnaHRcclxuICAgICAgICBpZih0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7IGhlaWdodDogaGVpZ2h0IH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYXV0b0Nsb3NlXHJcbiAgICAgICAgaWYobXVsdGlwbGUpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQob3B0aW9ucywgeyBhdXRvQ2xvc2U6IGZhbHNlIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbWluTGVuZ3RoXHJcbiAgICAgICAgaWYobWluTGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7IG1pbkxlbmd0aDogbWluTGVuZ3RoIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbWF4U2VsZWN0ZWRJdGVtc1xyXG4gICAgICAgIGlmKG1heFNlbGVjdGVkSXRlbXMgIT09IG51bGwpe1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7IG1heFNlbGVjdGVkSXRlbXM6IG1heFNlbGVjdGVkSXRlbXMgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBmaWx0ZXJcclxuICAgICAgICBpZihmaWx0ZXJGaWVsZHMgIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheShmaWx0ZXJGaWVsZHMpKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKG9wdGlvbnMsIHsgZmlsdGVyaW5nOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpZWxkcyA9IGZpbHRlckZpZWxkcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBlLmZpbHRlci52YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0ZpZWxkcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkcy5tYXAoZmllbGQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdGaWVsZHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcjogXCJjb250YWluc1wiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RmlsdGVyID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJzOiBuZXdGaWVsZHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2ljOiBcIm9yXCJcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGUuc2VuZGVyLmRhdGFTb3VyY2UuZmlsdGVyKG5ld0ZpbHRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9IH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gbWV0aG9kc1xyXG4gICAgdmFsdWUodikge1xyXG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aVNlbGVjdC52YWx1ZSgpO1xyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlTZWxlY3QudmFsdWUodik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGVuYWJsZShpc0Jvb2wpIHtcclxuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5tdWx0aVNlbGVjdC5lbmFibGUoKTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubXVsdGlTZWxlY3QuZW5hYmxlKGlzQm9vbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlYWRPbmx5KGlzQm9vbCkge1xyXG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm11bHRpU2VsZWN0LnJlYWRvbmx5KCk7XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm11bHRpU2VsZWN0LnJlYWRvbmx5KGlzQm9vbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGV2ZW50c1xyXG4gICAgb25TZWxlY3QoZSkge1xyXG4gICAgICAgIHZhciBkYXRhSXRlbSA9IHRoaXMubXVsdGlTZWxlY3QuZGF0YVNvdXJjZS52aWV3KClbZS5pdGVtLmluZGV4KCldO1xyXG5cclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vblNlbGVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblNlbGVjdChlLCBkYXRhSXRlbSwgdGhpcy52YWx1ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25EZXNlbGVjdChlKSB7XHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ211bHRpc2VsZWN0IGRlc2VsZWN0OiAnLCBlKTtcclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkRlc2VsZWN0ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uRGVzZWxlY3QoZSwgZS5kYXRhSXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uQ2hhbmdlKGUpIHtcclxuICAgICAgICAvL3ZhciBkYXRhSXRlbSA9IHRoaXMubXVsdGlTZWxlY3QuZGF0YVNvdXJjZS52aWV3KClbZS5pdGVtLmluZGV4KCldO1xyXG5cclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkNoYW5nZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShlLCB0aGlzLnZhbHVlKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbk9wZW4oZSkge1xyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uT3BlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbk9wZW4oZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uQ2xvc2UoZSkge1xyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uQ2xvc2UgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25DbG9zZShlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25GaWx0ZXJpbmcoZSkge1xyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uRmlsdGVyaW5nICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uRmlsdGVyaW5nKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkRhdGFCb3VuZChlKSB7XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uRGF0YUJvdW5kICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uRGF0YUJvdW5kKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkxvYWRDb21wbGV0ZShlLCByZXNwb25zZSkge1xyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uTG9hZENvbXBsZXRlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uTG9hZENvbXBsZXRlKGUsIHJlc3BvbnNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICAvLyDtlYTsiJgg7ZWt66qpXHJcbiAgICAgICAgY29uc3QgeyBjbGFzc05hbWUsIG5hbWUsIG11bHRpcGxlIH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8c2VsZWN0IGlkPXt0aGlzLmlkfSBuYW1lPXtuYW1lfSBtdWx0aXBsZT17bXVsdGlwbGV9IGNsYXNzTmFtZT17Y2xhc3NOYW1lcyhjbGFzc05hbWUpfT48L3NlbGVjdD5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5NdWx0aVNlbGVjdC5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XHJcbk11bHRpU2VsZWN0LmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE11bHRpU2VsZWN0OyIsIi8qKlxyXG4gKiBOdW1lcmljVGV4dEJveCBjb21wb25lbnRcclxuICpcclxuICogdmVyc2lvbiA8dHQ+JCBWZXJzaW9uOiAxLjAgJDwvdHQ+IGRhdGU6MjAxNi8wOC8zMVxyXG4gKiBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpocmFobkBua2lhLmNvLmtyXCI+QWhuIEh5dW5nLVJvPC9hPlxyXG4gKlxyXG4gKiBleGFtcGxlOlxyXG4gKiA8UHVmLk51bWVyaWNUZXh0Qm94IG9wdGlvbnM9e29wdGlvbnN9IC8+XHJcbiAqXHJcbiAqIEtlbmRvIE51bWVyaWNUZXh0Qm94IOudvOydtOu4jOufrOumrOyXkCDsooXsho3soIHsnbTri6QuXHJcbiAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQgVXRpbCBmcm9tICcuLi9zZXJ2aWNlcy9VdGlsJztcclxuXHJcbmNvbnN0IHByb3BUeXBlcyA9IHtcclxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIHdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgICAgIFByb3BUeXBlcy5udW1iZXJcclxuICAgIF0pLFxyXG4gICAgZm9ybWF0OiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgdmFsdWU6IFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICBzdGVwOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgbWluOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgbWF4OiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgZGVjaW1hbHM6IFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGRvd25BcnJvd1RleHQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICB1cEFycm93VGV4dDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHJlYWRPbmx5OiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xyXG4gICAgZm9ybWF0OiAnbjAnLCBcclxuICAgIHZhbHVlOiAxLCBcclxuICAgIGRvd25BcnJvd1RleHQ6ICcnLCBcclxuICAgIHVwQXJyb3dUZXh0OiAnJyxcclxuICAgIGRpc2FibGVkOiBmYWxzZVxyXG59O1xyXG5cclxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIE51bWVyaWNUZXh0Qm94LiAqL1xyXG5jbGFzcyBOdW1lcmljVGV4dEJveCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgLy8gTWFudWFsbHkgYmluZCB0aGlzIG1ldGhvZCB0byB0aGUgY29tcG9uZW50IGluc3RhbmNlLi4uXHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnRXaWxsTW91bnQoKSB7XHJcbiAgICAgICAgLy8g7LWc7LSIIOugjOuNlOungeydtCDsnbzslrTrgpjquLAg7KeB7KCEKO2VnOuyiCDtmLjstpwpXHJcbiAgICAgICAgbGV0IGlkID0gdGhpcy5wcm9wcy5pZDtcclxuICAgICAgICBpZih0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGlkID0gVXRpbC5nZXRVVUlEKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XHJcbiAgICAgICAgLy8g7LWc7LSIIOugjOuNlOungeydtCDsnbzslrTrgpwg64uk7J2MKO2VnOuyiCDtmLjstpwpXHJcbiAgICAgICAgdGhpcy4kbnVtZXJpY1RleHRCb3ggPSAkKCcjJyt0aGlzLmlkKTtcclxuICAgICAgICB0aGlzLm51bWVyaWNUZXh0Qm94ID0gdGhpcy4kbnVtZXJpY1RleHRCb3gua2VuZG9OdW1lcmljVGV4dEJveCh0aGlzLm9wdGlvbnMoKSkuZGF0YSgna2VuZG9OdW1lcmljVGV4dEJveCcpO1xyXG5cclxuICAgICAgICAvLyBFdmVudHNcclxuICAgICAgICB0aGlzLm51bWVyaWNUZXh0Qm94LmJpbmQoJ2NoYW5nZScsIHRoaXMub25DaGFuZ2UpO1xyXG5cclxuICAgICAgICAvLyBkaXNhYmxlZFxyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLmVuYWJsZSghdGhpcy5wcm9wcy5kaXNhYmxlZCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyByZWFkT25seVxyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLnJlYWRPbmx5ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWRPbmx5KHRoaXMucHJvcHMucmVhZE9ubHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xyXG4gICAgICAgIC8vIOy7tO2PrOuEjO2KuOqwgCDsg4jroZzsmrQgcHJvcHPrpbwg67Cb7J2EIOuVjCDtmLjstpwo7LWc7LSIIOugjOuNlOungSDsi5zsl5DripQg7Zi47Lac65CY7KeAIOyViuydjClcclxuICAgICAgICBpZih0eXBlb2YgbmV4dFByb3BzLnZhbHVlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLm51bWVyaWNUZXh0Qm94LnZhbHVlKG5leHRQcm9wcy52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBkaXNhYmxlZFxyXG4gICAgICAgIGlmKHR5cGVvZiBuZXh0UHJvcHMuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlKCFuZXh0UHJvcHMuZGlzYWJsZWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVhZE9ubHlcclxuICAgICAgICBpZih0eXBlb2YgbmV4dFByb3BzLnJlYWRPbmx5ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnJlYWRPbmx5KG5leHRQcm9wcy5yZWFkT25seSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgb3B0aW9ucygpIHtcclxuICAgICAgICBjb25zdCB7IGZvcm1hdCwgdmFsdWUsIHN0ZXAsIG1pbiwgbWF4LCBkZWNpbWFscywgcGxhY2Vob2xkZXIsIGRvd25BcnJvd1RleHQsIHVwQXJyb3dUZXh0IH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgZm9ybWF0OiBmb3JtYXQsXHJcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICAgICAgZG93bkFycm93VGV4dDogZG93bkFycm93VGV4dCxcclxuICAgICAgICAgICAgdXBBcnJvd1RleHQ6IHVwQXJyb3dUZXh0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gc3RlcFxyXG4gICAgICAgIGlmKHR5cGVvZiBzdGVwICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7IHN0ZXA6IHN0ZXAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBtaW5cclxuICAgICAgICBpZih0eXBlb2YgbWluICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7IG1pbjogbWluIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbWF4XHJcbiAgICAgICAgaWYodHlwZW9mIG1heCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQob3B0aW9ucywgeyBtYXg6IG1heCB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGRlY2ltYWxzXHJcbiAgICAgICAgaWYodHlwZW9mIGRlY2ltYWxzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7IGRlY2ltYWxzOiBkZWNpbWFscyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHBsYWNlaG9sZGVyXHJcbiAgICAgICAgaWYodHlwZW9mIHBsYWNlaG9sZGVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7IHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIG1ldGhvZHNcclxuICAgIHZhbHVlKHYpIHtcclxuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVtZXJpY1RleHRCb3gudmFsdWUoKTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm51bWVyaWNUZXh0Qm94LnZhbHVlKHYpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBlbmFibGUoaXNCb29sKSB7XHJcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubnVtZXJpY1RleHRCb3guZW5hYmxlKCk7XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm51bWVyaWNUZXh0Qm94LmVuYWJsZShpc0Jvb2wpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZWFkT25seShpc0Jvb2wpIHtcclxuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5udW1lcmljVGV4dEJveC5yZWFkb25seSgpO1xyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5udW1lcmljVGV4dEJveC5yZWFkb25seShpc0Jvb2wpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBldmVudHNcclxuICAgIG9uQ2hhbmdlKGUpIHtcclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkNoYW5nZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShlLCB0aGlzLnZhbHVlKCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIC8vIO2VhOyImCDtla3rqqlcclxuICAgICAgICBjb25zdCB7IGNsYXNzTmFtZSwgbmFtZSwgd2lkdGggfSA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxpbnB1dCBpZD17dGhpcy5pZH0gbmFtZT17bmFtZX0gc3R5bGU9e3t3aWR0aDogd2lkdGh9fSAvPlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbk51bWVyaWNUZXh0Qm94LnByb3BUeXBlcyA9IHByb3BUeXBlcztcclxuTnVtZXJpY1RleHRCb3guZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTnVtZXJpY1RleHRCb3g7IiwiLyoqXHJcbiAqIFBhbmVsQmFyIGNvbXBvbmVudFxyXG4gKlxyXG4gKiB2ZXJzaW9uIDx0dD4kIFZlcnNpb246IDEuMCAkPC90dD4gZGF0ZToyMDE2LzA4LzE4XHJcbiAqIGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmhyYWhuQG5raWEuY28ua3JcIj5BaG4gSHl1bmctUm88L2E+XHJcbiAqXHJcbiAqIGV4YW1wbGU6XHJcbiAqIDxQdWYuUGFuZWxCYXIgb3B0aW9ucz17b3B0aW9uc30gLz5cclxuICpcclxuICogS2VuZG8gUGFuZWxCYXIg65287J2067iM65+s66as7JeQIOyiheyGjeyggeydtOuLpC5cclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcbmltcG9ydCBVdGlsIGZyb20gJy4uL3NlcnZpY2VzL1V0aWwnO1xyXG5cclxuY29uc3QgcHJvcFR5cGVzID0ge1xyXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBjb250ZW50VXJsczogUHJvcFR5cGVzLmFycmF5XHJcbn07XHJcblxyXG5jb25zdCBkZWZhdWx0UHJvcHMgPSB7XHJcblxyXG59O1xyXG5cclxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIFBhbmVsQmFyLiAqL1xyXG5jbGFzcyBQYW5lbEJhciBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgLy8gT3BlcmF0aW9ucyB1c3VhbGx5IGNhcnJpZWQgb3V0IGluIGNvbXBvbmVudFdpbGxNb3VudCBnbyBoZXJlXHJcbiAgICAgICAgbGV0IGlkID0gcHJvcHMuaWQ7XHJcbiAgICAgICAgaWYodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZCA9IFV0aWwuZ2V0VVVJRCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cclxuICAgICAgICAvLyBNYW51YWxseSBiaW5kIHRoaXMgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuLi5cclxuICAgICAgICB0aGlzLm9uU2VsZWN0ID0gdGhpcy5vblNlbGVjdC5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIC8vIOy1nOy0iCDroIzrjZTrp4HsnbQg7J287Ja064KcIOuLpOydjCjtlZzrsogg7Zi47LacKVxyXG4gICAgICAgIHRoaXMuJHBhbmVsQmFyID0gJCgnIycrdGhpcy5pZCk7XHJcbiAgICAgICAgdGhpcy5wYW5lbEJhciA9IHRoaXMuJHBhbmVsQmFyLmtlbmRvUGFuZWxCYXIodGhpcy5vcHRpb25zKCkpLmRhdGEoJ2tlbmRvUGFuZWxCYXInKTtcclxuXHJcbiAgICAgICAgLy8gRXZlbnRzXHJcbiAgICAgICAgdGhpcy5wYW5lbEJhci5iaW5kKCdzZWxlY3QnLCB0aGlzLm9uU2VsZWN0KTtcclxuXHJcbiAgICAgICAgLy8gUGFuZWxCYXJQYW5lIOydmCBwcm9wcyBpZOulvCDshKTsoJXtlbTslbwgSWNvbiDshKTsoJXsnYQg7ZWgIOyImCDsnojri6QuXHJcbiAgICAgICAgdmFyIHBhbmVsQmFyUGFuZXMgPSBbXTtcclxuICAgICAgICBpZigkLmlzQXJyYXkodGhpcy5wcm9wcy5jaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgcGFuZWxCYXJQYW5lcyA9IHRoaXMucHJvcHMuY2hpbGRyZW47XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICBwYW5lbEJhclBhbmVzID0gW3RoaXMucHJvcHMuY2hpbGRyZW5dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBwYW5lbEJhclBhbmVzLm1hcCgocGFuZWxCYXJQYW5lKSA9PiB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZih0eXBlb2YgcGFuZWxCYXJQYW5lLnByb3BzLmlkICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGljb247XHJcbiAgICAgICAgICAgICAgICBpZihwYW5lbEJhclBhbmUucHJvcHMuaWNvbkNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGljb24gPSAnPGkgY2xhc3M9XCInK3BhbmVsQmFyUGFuZS5wcm9wcy5pY29uQ2xhc3NOYW1lKydcIj48L2k+JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHBhbmVsQmFyUGFuZS5wcm9wcy5pY29uVXJsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWNvbiA9ICc8aW1nIGNsYXNzPVwiay1pbWFnZVwiIGFsdD1cIlwiIHNyYz1cIicrcGFuZWxCYXJQYW5lLnByb3BzLmljb25VcmwrJ1wiPic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICQoJyMnICsgcGFuZWxCYXJQYW5lLnByb3BzLmlkICsgJyA+IHNwYW4uay1saW5rLmstaGVhZGVyJykucHJlcGVuZChpY29uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgb3B0aW9ucygpIHtcclxuICAgICAgICByZXR1cm4ge31cclxuICAgIH1cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBtZXRob2RzXHJcbiAgICBleHBhbmQoJGl0ZW0pIHtcclxuICAgICAgICB0aGlzLnBhbmVsQmFyLmV4cGFuZCgkaXRlbSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gZXZlbnRzXHJcbiAgICBvblNlbGVjdChlKSB7XHJcblxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgLy8g7ZWE7IiYIO2VreuqqVxyXG4gICAgICAgIGNvbnN0IHsgY2xhc3NOYW1lLCBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPHVsIGlkPXt0aGlzLmlkfSBjbGFzc05hbWU9e2NsYXNzTmFtZXMoY2xhc3NOYW1lKX0+e2NoaWxkcmVufTwvdWw+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgcHJvcFR5cGVzUGFuZWxCYXJQYW5lID0ge1xyXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICB0aXRsZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGljb25Vcmw6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBpY29uQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgaXRlbXM6IFByb3BUeXBlcy5hcnJheVxyXG59O1xyXG5cclxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIFBhbmVsQmFyUGFuZS4gKi9cclxuY2xhc3MgUGFuZWxCYXJQYW5lIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHJlbmRlclBhbmVDb250ZW50KCkge1xyXG4gICAgICAgIGNvbnN0IHsgaXRlbXMsIGNoaWxkcmVuLCBjb250ZW50VXJscyB9ID0gdGhpcy5wcm9wcztcclxuICAgICAgICB2YXIgY29udGVudDtcclxuXHJcbiAgICAgICAgaWYoaXRlbXMpIHtcclxuICAgICAgICAgICAgdmFyIF9pdGVtcyA9IGl0ZW1zLm1hcChmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaWNvbiwgdGV4dDtcclxuICAgICAgICAgICAgICAgICAgICBpZihpdGVtLmhhc093blByb3BlcnR5KCdzcHJpdGVDc3NDbGFzcycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGljb24gPSA8c3BhbiBjbGFzc05hbWU9e2NsYXNzTmFtZXMoaXRlbS5zcHJpdGVDc3NDbGFzcyl9Pjwvc3Bhbj47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0uaGFzT3duUHJvcGVydHkoJ2ltYWdlVXJsJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWNvbiA9IDxpbWcgc3JjPXtpdGVtLmltYWdlVXJsfSAvPjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGl0ZW0uaGFzT3duUHJvcGVydHkoJ3RleHQnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gaXRlbS50ZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5oYXNPd25Qcm9wZXJ0eSgnZGF0YScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB7IGRhdGE6IEpTT04uc3RyaW5naWZ5KGl0ZW0uZGF0YSkgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gKDxsaSBrZXk9e1V0aWwudW5pcXVlSUQoKX0+e2ljb259IHt0ZXh0fTwvbGk+KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDxsaSB7Li4uZGF0YX0+e2ljb259IHt0ZXh0fTwvbGk+KTtcclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiA8UGFuZWxCYXJQYW5lSXRlbSBkYXRhPXtkYXRhfT57aWNvbn0ge3RleHR9PC9QYW5lbEJhclBhbmVJdGVtPjtcclxuICAgICAgICAgICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiAoPGxpIGtleT17VXRpbC51bmlxdWVJRCgpfT57aXRlbX08L2xpPik7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICg8bGk+e2l0ZW19PC9saT4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29udGVudCA9IDx1bD57X2l0ZW1zfTwvdWw+O1xyXG5cclxuICAgICAgICB9ZWxzZSBpZihjaGlsZHJlbikge1xyXG4gICAgICAgICAgICBjb250ZW50ID0gY2hpbGRyZW47XHJcblxyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgLy8gY29udGVudFVybHMg7J2065286rOgIO2MkOuLqFxyXG4gICAgICAgICAgICBjb250ZW50ID0gPGRpdj48L2Rpdj47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY29udGVudDtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgLy8g7ZWE7IiYIO2VreuqqVxyXG4gICAgICAgIGNvbnN0IHsgaWQsIHRpdGxlIH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICB2YXIgX2lkO1xyXG4gICAgICAgIGlmKGlkKSB7XHJcbiAgICAgICAgICAgIF9pZCA9IHtpZDogaWR9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGxpIHsuLi5faWR9PlxyXG4gICAgICAgICAgICAgICAge3RpdGxlfVxyXG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVyUGFuZUNvbnRlbnQoKX1cclxuICAgICAgICAgICAgPC9saT5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKiogQ2xhc3MgcmVwcmVzZW50aW5nIGEgUGFuZWxCYXJQYW5lSXRlbS4gKi9cclxuY2xhc3MgUGFuZWxCYXJQYW5lSXRlbSBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHJldHVybiAoPGxpIHsuLi5kYXRhfT57dGhpcy5wcm9wcy5jaGlsZHJlbn08L2xpPik7XHJcbiAgICB9XHJcbn1cclxuXHJcblBhbmVsQmFyLnByb3BUeXBlcyA9IHByb3BUeXBlcztcclxuUGFuZWxCYXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xyXG5QYW5lbEJhclBhbmUucHJvcFR5cGVzID0gcHJvcFR5cGVzUGFuZWxCYXJQYW5lO1xyXG5cclxuZXhwb3J0IHsgUGFuZWxCYXIsIFBhbmVsQmFyUGFuZSB9OyIsIi8qKlxyXG4gKiBQcm9ncmVzc0JhciBjb21wb25lbnRcclxuICpcclxuICogdmVyc2lvbiA8dHQ+JCBWZXJzaW9uOiAxLjAgJDwvdHQ+IGRhdGU6MjAxNi8wOS8wNlxyXG4gKiBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpocmFobkBua2lhLmNvLmtyXCI+QWhuIEh5dW5nLVJvPC9hPlxyXG4gKlxyXG4gKiBleGFtcGxlOlxyXG4gKiA8UHVmLlByb2dyZXNzQmFyIG9wdGlvbnM9e29wdGlvbnN9IC8+XHJcbiAqXHJcbiAqIEtlbmRvIFByb2dyZXNzQmFyIOudvOydtOu4jOufrOumrOyXkCDsooXsho3soIHsnbTri6QuXHJcbiAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50LCBQcm9wVHlwZXMgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnO1xyXG5pbXBvcnQgVXRpbCBmcm9tICcuLi9zZXJ2aWNlcy9VdGlsJztcclxuXHJcbmNvbnN0IHByb3BUeXBlcyA9IHtcclxuICAgIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgdHlwZTogUHJvcFR5cGVzLm9uZU9mKFsndmFsdWUnLCAncGVyY2VudCcsICdjaHVuayddKSxcclxuICAgIHZhbHVlOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgYW5pbWF0aW9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgICAgIFByb3BUeXBlcy5ib29sLFxyXG4gICAgICAgIFByb3BUeXBlcy5vYmplY3RcclxuICAgIF0pLFxyXG4gICAgbWluOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgbWF4OiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgZW5hYmxlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIG9yaWVudGF0aW9uOiBQcm9wVHlwZXMub25lT2YoWydob3Jpem9udGFsJywgJ3ZlcnRpY2FsJ10pLFxyXG4gICAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25Db21wbGV0ZTogUHJvcFR5cGVzLmZ1bmNcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcclxuICAgIHR5cGU6ICd2YWx1ZScsIFxyXG4gICAgdmFsdWU6IDAsIFxyXG4gICAgYW5pbWF0aW9uOiB7IGR1cmF0aW9uOiA2MDAgfSwgXHJcbiAgICBlbmFibGU6IHRydWUsIFxyXG4gICAgb3JpZW50YXRpb246ICdob3Jpem9udGFsJ1xyXG59O1xyXG5cclxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIFByb2dyZXNzQmFyLiAqL1xyXG5jbGFzcyBQcm9ncmVzc0JhciBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgLy8gT3BlcmF0aW9ucyB1c3VhbGx5IGNhcnJpZWQgb3V0IGluIGNvbXBvbmVudFdpbGxNb3VudCBnbyBoZXJlXHJcbiAgICAgICAgbGV0IGlkID0gcHJvcHMuaWQ7XHJcbiAgICAgICAgaWYodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZCA9IFV0aWwuZ2V0VVVJRCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cclxuICAgICAgICAvLyBNYW51YWxseSBiaW5kIHRoaXMgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuLi5cclxuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gdGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25Db21wbGV0ZSA9IHRoaXMub25Db21wbGV0ZS5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIC8vIOy1nOy0iCDroIzrjZTrp4HsnbQg7J287Ja064KcIOuLpOydjCjtlZzrsogg7Zi47LacKVxyXG4gICAgICAgIHRoaXMuJHByb2dyZXNzQmFyID0gJCgnIycrdGhpcy5pZCk7XHJcbiAgICAgICAgdGhpcy5wcm9ncmVzc0JhciA9IHRoaXMuJHByb2dyZXNzQmFyLmtlbmRvUHJvZ3Jlc3NCYXIodGhpcy5vcHRpb25zKCkpLmRhdGEoJ2tlbmRvUHJvZ3Jlc3NCYXInKTtcclxuXHJcbiAgICAgICAgLy8gRXZlbnRzXHJcbiAgICAgICAgdGhpcy5wcm9ncmVzc0Jhci5iaW5kKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlKTtcclxuICAgICAgICB0aGlzLnByb2dyZXNzQmFyLmJpbmQoJ2NvbXBsZXRlJywgdGhpcy5vbkNvbXBsZXRlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIG9wdGlvbnMoKSB7XHJcbiAgICAgICAgY29uc3QgeyB0eXBlLCB2YWx1ZSwgYW5pbWF0aW9uLCBlbmFibGUsIG9yaWVudGF0aW9uIH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICAvLyBhbmltYXRpb25cclxuICAgICAgICB2YXIgX2FuaW1hdGlvbjtcclxuICAgICAgICBpZih0eXBlb2YgYW5pbWF0aW9uID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBfYW5pbWF0aW9uID0geyBkdXJhdGlvbjogYW5pbWF0aW9uIH07XHJcbiAgICAgICAgfWVsc2UgaWYoYW5pbWF0aW9uID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIF9hbmltYXRpb24gPSB7IGR1cmF0aW9uOiA2MDAgfTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIF9hbmltYXRpb24gPSBhbmltYXRpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICBhbmltYXRpb246IF9hbmltYXRpb24sXHJcbiAgICAgICAgICAgIGVuYWJsZTogZW5hYmxlLFxyXG4gICAgICAgICAgICBvcmllbnRhdGlvbjogb3JpZW50YXRpb25cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBtaW5cclxuICAgICAgICBpZih0eXBlb2YgbWluICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7IG1pbjogbWluIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gbWF4XHJcbiAgICAgICAgaWYodHlwZW9mIG1heCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQob3B0aW9ucywgeyBtYXg6IG1heCB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIG1ldGhvZHNcclxuICAgIHZhbHVlKHYpIHtcclxuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvZ3Jlc3NCYXIudmFsdWUoKTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2dyZXNzQmFyLnZhbHVlKHYpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBlbmFibGUoYikge1xyXG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb2dyZXNzQmFyLmVuYWJsZSgpO1xyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9ncmVzc0Jhci5lbmFibGUoYik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGV2ZW50XHJcbiAgICBvbkNoYW5nZShlKSB7XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uQ2hhbmdlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKGUudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkNvbXBsZXRlKGUpIHtcclxuXHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMub25Db21wbGV0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNvbXBsZXRlKGUudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIC8vIO2VhOyImCDtla3rqqlcclxuICAgICAgICBjb25zdCB7IGNsYXNzTmFtZSB9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgPGRpdiBpZD17dGhpcy5pZH0gY2xhc3NOYW1lPXtjbGFzc05hbWVzKGNsYXNzTmFtZSl9PjwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcblByb2dyZXNzQmFyLnByb3BUeXBlcyA9IHByb3BUeXBlcztcclxuUHJvZ3Jlc3NCYXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUHJvZ3Jlc3NCYXI7IiwiLyoqXHJcbiAqIFNsaWRlciBjb21wb25lbnRcclxuICpcclxuICogdmVyc2lvbiA8dHQ+JCBWZXJzaW9uOiAxLjAgJDwvdHQ+IGRhdGU6MjAxNi8xMS8yNFxyXG4gKiBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpocmFobkBua2lhLmNvLmtyXCI+QWhuIEh5dW5nLVJvPC9hPlxyXG4gKlxyXG4gKiBleGFtcGxlOlxyXG4gKiA8UHVmLlNsaWRlciBvcHRpb25zPXtvcHRpb25zfSAvPlxyXG4gKlxyXG4gKiBLZW5kbyBTbGlkZXIg65287J2067iM65+s66as7JeQIOyiheyGjeyggeydtOuLpC5cclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQsIFByb3BUeXBlcyB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XHJcbmltcG9ydCBVdGlsIGZyb20gJy4uL3NlcnZpY2VzL1V0aWwnO1xyXG5cclxuY29uc3QgcHJvcFR5cGVzID0ge1xyXG4gICAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICB3aWR0aDogUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLnN0cmluZyxcclxuICAgICAgICBQcm9wVHlwZXMubnVtYmVyXHJcbiAgICBdKSxcclxuICAgIHZhbHVlOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgbWluOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgbWF4OiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgb3JpZW50YXRpb246IFByb3BUeXBlcy5vbmVPZihbJ2hvcml6b250YWwnLCd2ZXJ0aWNhbCddKS5pc1JlcXVpcmVkLFxyXG4gICAgZHJhZ0hhbmRsZVRpdGxlOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgc2hvd0J1dHRvbnM6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgbGFyZ2VTdGVwOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgc21hbGxTdGVwOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgdGlja1BsYWNlbWVudDogUHJvcFR5cGVzLm9uZU9mKFsndG9wTGVmdCcsJ2JvdHRvbVJpZ2h0JywnYm90aCcsJ25vbmUnXSkuaXNSZXF1aXJlZCxcclxuICAgIHRvb2x0aXBFbmFibGVkOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHRvb2x0aXBGb3JtYXQ6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICB0b29sdGlwVGVtcGxhdGU6IFByb3BUeXBlcy5zdHJpbmdcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcclxuICAgIHZhbHVlOiAwLFxyXG4gICAgbWluOiAwLFxyXG4gICAgbWF4OiAxMCxcclxuICAgIG9yaWVudGF0aW9uOiAnaG9yaXpvbnRhbCcsXHJcbiAgICBkcmFnSGFuZGxlVGl0bGU6ICdkcmFnJyxcclxuICAgIHNob3dCdXR0b25zOiB0cnVlLFxyXG4gICAgbGFyZ2VTdGVwOiA1LFxyXG4gICAgc21hbGxTdGVwOiAxLFxyXG4gICAgdGlja1BsYWNlbWVudDogJ2JvdGgnXHJcbn07XHJcblxyXG5jbGFzcyBTbGlkZXIgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICAgICAgLy8gdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAvLyAgICAgZGF0YTogW10sXHJcbiAgICAgICAgLy8gICAgIGNvdW50OiBwcm9wcy5pbml0aWFsQ291bnRcclxuICAgICAgICAvLyB9O1xyXG5cclxuICAgICAgICAvLyBNYW51YWxseSBiaW5kIHRoaXMgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuLi5cclxuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gdGhpcy5vbkNoYW5nZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25TbGlkZSA9IHRoaXMub25TbGlkZS5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcclxuICAgICAgICAvLyDstZzstIgg66CM642U66eB7J20IOydvOyWtOuCmOq4sCDsp4HsoIQo7ZWc67KIIO2YuOy2nClcclxuICAgICAgICBsZXQgaWQgPSB0aGlzLnByb3BzLmlkO1xyXG4gICAgICAgIGlmKHR5cGVvZiBpZCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgaWQgPSBVdGlsLmdldFVVSUQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaWQgPSBpZDtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAvLyDstZzstIgg66CM642U66eB7J20IOydvOyWtOuCnCDri6TsnYwo7ZWc67KIIO2YuOy2nClcclxuICAgICAgICB0aGlzLiRzbGlkZXIgPSAkKCcjJyt0aGlzLmlkKTtcclxuICAgICAgICB0aGlzLnNsaWRlciA9IHRoaXMuJHNsaWRlci5rZW5kb1NsaWRlcih0aGlzLm9wdGlvbnModGhpcy5wcm9wcykpLmRhdGEoJ2tlbmRvU2xpZGVyJyk7XHJcblxyXG4gICAgICAgIC8vIEV2ZW50c1xyXG4gICAgICAgIHRoaXMuc2xpZGVyLmJpbmQoJ2NoYW5nZScsIHRoaXMub25DaGFuZ2UpO1xyXG4gICAgICAgIHRoaXMuc2xpZGVyLmJpbmQoJ3NsaWRlJywgdGhpcy5vblNsaWRlKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xyXG4gICAgICAgIC8vIOy7tO2PrOuEjO2KuOqwgCDsg4jroZzsmrQgcHJvcHPrpbwg67Cb7J2EIOuVjCDtmLjstpwo7LWc7LSIIOugjOuNlOungSDsi5zsl5DripQg7Zi47Lac65CY7KeAIOyViuydjClcclxuICAgICAgICAvLyBpZih0aGlzLnByb3BzLm1pbiAhPSBuZXh0UHJvcHMubWluIHx8IHRoaXMucHJvcHMubWF4ICE9IG5leHRQcm9wcy5tYXgpIHtcclxuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coJ1NsaWRlciBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJywgbmV4dFByb3BzLm1heCk7XHJcbiAgICAgICAgLy8gICAgIHRoaXMuc2xpZGVyLmRlc3Ryb3koKTtcclxuICAgICAgICAvLyAgICAgdGhpcy5zbGlkZXIgPSB0aGlzLiRzbGlkZXIua2VuZG9TbGlkZXIodGhpcy5vcHRpb25zKG5leHRQcm9wcykpLmRhdGEoJ2tlbmRvU2xpZGVyJyk7XHJcblxyXG4gICAgICAgIC8vICAgICAvLyBFdmVudHNcclxuICAgICAgICAvLyAgICAgdGhpcy5zbGlkZXIuYmluZCgnY2hhbmdlJywgdGhpcy5vbkNoYW5nZSk7XHJcbiAgICAgICAgLy8gICAgIHRoaXMuc2xpZGVyLmJpbmQoJ3NsaWRlJywgdGhpcy5vblNsaWRlKTtcclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gZXZlbnRzXHJcbiAgICBvbkNoYW5nZShlKSB7XHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMub25DaGFuZ2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShlLCBlLnZhbHVlKTtcclxuICAgICAgICAgICAgLy9lLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvblNsaWRlKGUpIHtcclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vblNsaWRlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25TbGlkZShlLCBlLnZhbHVlKTtcclxuICAgICAgICAgICAgLy9lLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBtZXRob2RzXHJcbiAgICB2YWx1ZSh2YWwpIHtcclxuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2xpZGVyLnZhbHVlKCk7XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zbGlkZXIudmFsdWUodmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZW5hYmxlKGlzQm9vbCkge1xyXG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zbGlkZXIuZW5hYmxlKCk7XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zbGlkZXIuZW5hYmxlKGlzQm9vbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldFdpZHRoKHZhbCkge1xyXG4gICAgICAgIHZhciB3ID0gMDtcclxuICAgICAgICBpZih0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB3ID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNsaWRlci53cmFwcGVyLmNzcygnd2lkdGgnLCB3ICsgJ3B4Jyk7XHJcbiAgICAgICAgdGhpcy5zbGlkZXIucmVzaXplKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB2YXIgd3JhcHBlciA9IHRoaXMuc2xpZGVyLndyYXBwZXIsXHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLnNsaWRlci5lbGVtZW50O1xyXG5cclxuICAgICAgICB0aGlzLnNsaWRlci5kZXN0cm95KCk7XHJcbiAgICAgICAgd3JhcHBlci5iZWZvcmUoZWxlbWVudC5zaG93KCkpO1xyXG4gICAgICAgIHdyYXBwZXIucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgIC8vIHRoaXMuc2xpZGVyLmRlc3Ryb3koKTtcclxuICAgICAgICAvLyB0aGlzLiRzbGlkZXIuY2xvc2VzdCgnLmstc2xpZGVyJykucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRlKF9vcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnModGhpcy5wcm9wcyk7XHJcbiAgICAgICAgJC5leHRlbmQodHJ1ZSwgb3B0aW9ucywgX29wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuc2xpZGVyID0gdGhpcy4kc2xpZGVyLmtlbmRvU2xpZGVyKG9wdGlvbnMpLmRhdGEoJ2tlbmRvU2xpZGVyJyk7XHJcblxyXG4gICAgICAgIC8vIEV2ZW50c1xyXG4gICAgICAgIHRoaXMuc2xpZGVyLmJpbmQoJ2NoYW5nZScsIHRoaXMub25DaGFuZ2UpO1xyXG4gICAgICAgIHRoaXMuc2xpZGVyLmJpbmQoJ3NsaWRlJywgdGhpcy5vblNsaWRlKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRNYXgodmFsKSB7XHJcbiAgICAgICAgdGhpcy4kc2xpZGVyLnByZXYoKS5maW5kKCdhJykuYXR0cignYXJpYS12YWx1ZW1heCcsIHZhbCk7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0TWluKHZhbCkge1xyXG4gICAgICAgIHRoaXMuJHNsaWRlci5wcmV2KCkuZmluZCgnYScpLmF0dHIoJ2FyaWEtdmFsdWVtaW4nLCB2YWwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgb3B0aW9ucyhwcm9wcykge1xyXG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIG1pbiwgbWF4LCBvcmllbnRhdGlvbiwgZHJhZ0hhbmRsZVRpdGxlLCBzaG93QnV0dG9ucywgbGFyZ2VTdGVwLCBzbWFsbFN0ZXAsIHRpY2tQbGFjZW1lbnQsIHRvb2x0aXBFbmFibGVkLCB0b29sdGlwRm9ybWF0LCB0b29sdGlwVGVtcGxhdGUgfSA9IHByb3BzO1xyXG5cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICBtaW46IG1pbixcclxuICAgICAgICAgICAgbWF4OiBtYXgsXHJcbiAgICAgICAgICAgIG9yaWVudGF0aW9uOiBvcmllbnRhdGlvbixcclxuICAgICAgICAgICAgZHJhZ0hhbmRsZVRpdGxlOiBkcmFnSGFuZGxlVGl0bGUsXHJcbiAgICAgICAgICAgIHNob3dCdXR0b25zOiBzaG93QnV0dG9ucyxcclxuICAgICAgICAgICAgbGFyZ2VTdGVwOiBsYXJnZVN0ZXAsXHJcbiAgICAgICAgICAgIHNtYWxsU3RlcDogc21hbGxTdGVwLFxyXG4gICAgICAgICAgICB0aWNrUGxhY2VtZW50OiB0aWNrUGxhY2VtZW50XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gdG9vbHRpcCBlbmFibGVkXHJcbiAgICAgICAgaWYodHlwZW9mIHRvb2x0aXBFbmFibGVkID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQob3B0aW9ucywgeyB0b29sdGlwOiB7IGVuYWJsZWQ6IHRvb2x0aXBFbmFibGVkIH0gfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0b29sdGlwIGZvcm1hdFxyXG4gICAgICAgIGlmKHR5cGVvZiB0b29sdGlwRm9ybWF0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCBvcHRpb25zLCB7IHRvb2x0aXA6IHsgZm9ybWF0OiB0b29sdGlwRm9ybWF0IH0gfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0b29sdGlwIHRlbXBsYXRlXHJcbiAgICAgICAgaWYodHlwZW9mIHRvb2x0aXBUZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgb3B0aW9ucywgeyB0b29sdGlwOiB7IHRlbXBsYXRlOiB0b29sdGlwVGVtcGxhdGUgfSB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICAvLyDtlYTsiJgg7ZWt66qpXHJcbiAgICAgICAgY29uc3QgeyBjbGFzc05hbWUsIHdpZHRoIH0gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxpbnB1dCBpZD17dGhpcy5pZH0gY2xhc3NOYW1lPXtjbGFzc05hbWVzKGNsYXNzTmFtZSl9IHN0eWxlPXt7d2lkdGg6IHdpZHRofX0gLz5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5TbGlkZXIucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xyXG5TbGlkZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2xpZGVyO1xyXG4iLCIvKipcclxuICogVHJlZVZpZXcgY29tcG9uZW50XHJcbiAqXHJcbiAqIHZlcnNpb24gPHR0PiQgVmVyc2lvbjogMS4wICQ8L3R0PiBkYXRlOjIwMTYvMDQvMTVcclxuICogYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86aHJhaG5AbmtpYS5jby5rclwiPkFobiBIeXVuZy1SbzwvYT5cclxuICpcclxuICogZXhhbXBsZTpcclxuICogPFB1Zi5UcmVlVmlldyBvcHRpb25zPXtvcHRpb25zfSAvPlxyXG4gKlxyXG4gKiBLZW5kbyBUcmVlVmlldyDrnbzsnbTruIzrn6zrpqzsl5Ag7KKF7IaN7KCB7J2064ukLlxyXG4gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IFV0aWwgZnJvbSAnLi4vc2VydmljZXMvVXRpbCc7XHJcblxyXG5jb25zdCBwcm9wVHlwZXMgPSB7XHJcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIG9wdGlvbnM6IFByb3BUeXBlcy5vYmplY3QsXHJcbiAgICBob3N0OiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgdXJsOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgbWV0aG9kOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgaXRlbXM6IFByb3BUeXBlcy5hcnJheSxcclxuICAgIGRhdGE6IFByb3BUeXBlcy5vYmplY3QsXHJcbiAgICBvbkRlbWFuZDogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBkYXRhVGV4dEZpZWxkOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgICAgIFByb3BUeXBlcy5hcnJheVxyXG4gICAgXSksXHJcbiAgICBoYXNDaGlsZHJlbkZpZWxkOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgY2hpbGRyZW5GaWVsZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGNoZWNrYm94ZXM6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgZHJhZ0FuZERyb3A6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgdGVtcGxhdGU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBvblNlbGVjdDogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICBvbkNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcclxuICAgIG9uRGJsY2xpY2s6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25Db2xsYXBzZTogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICBvbkV4cGFuZDogUHJvcFR5cGVzLmZ1bmNcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcclxuICAgIG9uRGVtYW5kOiBmYWxzZSwgXHJcbiAgICBtZXRob2Q6ICdQT1NUJywgXHJcbiAgICBpdGVtczogW10sXHJcbiAgICBkYXRhVGV4dEZpZWxkOiAndGV4dCcsIFxyXG4gICAgaGFzQ2hpbGRyZW5GaWVsZDogJ2hhc0NoaWxkcmVuJywgXHJcbiAgICBjaGlsZHJlbkZpZWxkOiAnaXRlbXMnLCBcclxuICAgIGRyYWdBbmREcm9wOiBmYWxzZVxyXG59O1xyXG5cclxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIFRyZWVWaWV3LiAqL1xyXG5jbGFzcyBUcmVlVmlldyBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICAvLyBzdGF0aWMgZGlzcGxheU5hbWUgPSAnVHJlZVZpZXcnO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG5cclxuICAgICAgICAvLyBPcGVyYXRpb25zIHVzdWFsbHkgY2FycmllZCBvdXQgaW4gY29tcG9uZW50V2lsbE1vdW50IGdvIGhlcmVcclxuICAgICAgICBsZXQgaWQgPSBwcm9wcy5pZDtcclxuICAgICAgICBpZih0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGlkID0gVXRpbC5nZXRVVUlEKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblxyXG4gICAgICAgIC8vIE1hbnVhbGx5IGJpbmQgdGhpcyBtZXRob2QgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZS4uLlxyXG4gICAgICAgIHRoaXMub25TZWxlY3QgPSB0aGlzLm9uU2VsZWN0LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbkNoZWNrID0gdGhpcy5vbkNoZWNrLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9uQ29sbGFwc2UgPSB0aGlzLm9uQ29sbGFwc2UuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9uRXhwYW5kID0gdGhpcy5vbkV4cGFuZC5iaW5kKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLm9uRHJhZ1N0YXJ0ID0gdGhpcy5vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25EcmFnID0gdGhpcy5vbkRyYWcuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9uRHJvcCA9IHRoaXMub25Ecm9wLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbkRyYWdFbmQgPSB0aGlzLm9uRHJhZ0VuZC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25OYXZpZ2F0ZSA9IHRoaXMub25OYXZpZ2F0ZS5iaW5kKHRoaXMpO1xyXG5cclxuICAgICAgICB0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9uRGJsY2xpY2sgPSB0aGlzLm9uRGJsY2xpY2suYmluZCh0aGlzKTtcclxuXHJcbiAgICAgICAgLy8gdGhpcy5fYmluZCgnX2hhbmRsZUNsaWNrJywgJ19oYW5kbGVGb28nKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICAvLyDstZzstIgg66CM642U66eB7J20IOydvOyWtOuCnCDri6TsnYwo7ZWc67KIIO2YuOy2nClcclxuICAgICAgICB0aGlzLiR0cmVlVmlldyA9ICQoJyMnK3RoaXMuaWQpO1xyXG4gICAgICAgIHRoaXMudHJlZVZpZXcgPSB0aGlzLiR0cmVlVmlldy5rZW5kb1RyZWVWaWV3KHRoaXMub3B0aW9ucygpKS5kYXRhKCdrZW5kb1RyZWVWaWV3Jyk7XHJcblxyXG4gICAgICAgIC8vIEV2ZW50c1xyXG4gICAgICAgIHRoaXMudHJlZVZpZXcuYmluZCgnc2VsZWN0JywgdGhpcy5vblNlbGVjdCk7XHJcbiAgICAgICAgdGhpcy50cmVlVmlldy5iaW5kKCdjaGVjaycsIHRoaXMub25DaGVjayk7XHJcbiAgICAgICAgdGhpcy50cmVlVmlldy5iaW5kKCdjaGFuZ2UnLCB0aGlzLm9uQ2hhbmdlKTtcclxuICAgICAgICB0aGlzLnRyZWVWaWV3LmJpbmQoJ2NvbGxhcHNlJywgdGhpcy5vbkNvbGxhcHNlKTtcclxuICAgICAgICB0aGlzLnRyZWVWaWV3LmJpbmQoJ2V4cGFuZCcsIHRoaXMub25FeHBhbmQpO1xyXG5cclxuICAgICAgICAvKiBkcmFnICYgZHJvcCBldmVudHMgKi9cclxuICAgICAgICB0aGlzLnRyZWVWaWV3LmJpbmQoJ2RyYWdzdGFydCcsIHRoaXMub25EcmFnU3RhcnQpO1xyXG4gICAgICAgIHRoaXMudHJlZVZpZXcuYmluZCgnZHJhZycsIHRoaXMub25EcmFnKTtcclxuICAgICAgICB0aGlzLnRyZWVWaWV3LmJpbmQoJ2Ryb3AnLCB0aGlzLm9uRHJvcCk7XHJcbiAgICAgICAgdGhpcy50cmVlVmlldy5iaW5kKCdkcmFnZW5kJywgdGhpcy5vbkRyYWdFbmQpO1xyXG4gICAgICAgIHRoaXMudHJlZVZpZXcuYmluZCgnbmF2aWdhdGUnLCB0aGlzLm9uTmF2aWdhdGUpO1xyXG5cclxuICAgICAgICAvL3RoaXMuJHRyZWVWaWV3LmZpbmQoJy5rLWluJykub24oJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTsgICAgICAgLy8gY2xpY2vsnbQgc2VsZWN0IOuztOuLpCDrqLzsoIAg67Cc7IOdXHJcbiAgICAgICAgdGhpcy4kdHJlZVZpZXcub24oJ2NsaWNrJywgJy5rLWluJywgdGhpcy5vbkNsaWNrKTsgICAgICAgICAgICAgIC8vIGNsaWNr7J20IHNlbGVjdCDrs7Tri6Qg64KY7KSR7JeQIOuwnOyDnVxyXG4gICAgICAgIHRoaXMuJHRyZWVWaWV3LmZpbmQoJy5rLWluJykub24oJ2RibGNsaWNrJywgdGhpcy5vbkRibGNsaWNrKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gcHJpdmF0ZVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBvcHRpb25zKCkge1xyXG4gICAgICAgIGNvbnN0IHsgaG9zdCwgdXJsLCBtZXRob2QsIGRhdGEsIGl0ZW1zLCBvbkRlbWFuZCwgZGF0YVRleHRGaWVsZCwgaGFzQ2hpbGRyZW5GaWVsZCwgY2hpbGRyZW5GaWVsZCwgY2hlY2tib3hlcywgZHJhZ0FuZERyb3AsIHRlbXBsYXRlIH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgY2hlY2tib3hlczogY2hlY2tib3hlcywgICAgICAgICAvLyB0cnVlIG9yIGZhbHNlXHJcbiAgICAgICAgICAgIGRhdGFUZXh0RmllbGQ6IGRhdGFUZXh0RmllbGQsXHJcbiAgICAgICAgICAgIGxvYWRPbkRlbWFuZDogb25EZW1hbmQsXHJcbiAgICAgICAgICAgIGRyYWdBbmREcm9wOiBkcmFnQW5kRHJvcCAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhLnRyZWVWTykuc3BsaXQoJ1wiY2hpbGRyZW5cIjonKS5qb2luKCdcIml0ZW1zXCI6JykpLml0ZW1zXHJcblxyXG4gICAgICAgIHZhciBtb2RlbDtcclxuICAgICAgICAvLyBkYXRhU291cmNlXHJcbiAgICAgICAgLy8gdXJsXHJcbiAgICAgICAgaWYodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2hpbGRyZW5GaWVsZCAhPSBcImNoaWxkcmVuXCIpIHtcclxuICAgICAgICAgICAgaWYob25EZW1hbmQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIG1vZGVsID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlkOiAnaWQnLFxyXG4gICAgICAgICAgICAgICAgICAgIGhhc0NoaWxkcmVuOiBoYXNDaGlsZHJlbkZpZWxkLFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbkZpZWxkXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtb2RlbCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5GaWVsZFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgJC5leHRlbmQob3B0aW9ucywgeyBkYXRhU291cmNlOiBuZXcga2VuZG8uZGF0YS5IaWVyYXJjaGljYWxEYXRhU291cmNlKHtcclxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiAoaG9zdCAmJiBob3N0ICE9PSBudWxsICYmIGhvc3QubGVuZ3RoID4gMCkgPyBob3N0ICsgdXJsIDogdXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBtZXRob2QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOCdcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlck1hcDogZnVuY3Rpb24oZGF0YSwgdHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhkYXRhLCB0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHtcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbDogbW9kZWxcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkgfSk7XHJcblxyXG4gICAgICAgIH1lbHNlIGlmKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnICYmIGNoaWxkcmVuRmllbGQgPT0gJ2NoaWxkcmVuJykge1xyXG4gICAgICAgICAgICBpZihvbkRlbWFuZCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgbW9kZWwgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzQ2hpbGRyZW46IGhhc0NoaWxkcmVuRmllbGQsXHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46ICdpdGVtcydcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgICAgIG1vZGVsID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAnaXRlbXMnXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7IGRhdGFTb3VyY2U6IG5ldyBrZW5kby5kYXRhLkhpZXJhcmNoaWNhbERhdGFTb3VyY2Uoe1xyXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IChob3N0ICYmIGhvc3QgIT09IG51bGwgJiYgaG9zdC5sZW5ndGggPiAwKSA/IGhvc3QgKyB1cmwgOiB1cmwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IG1ldGhvZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04J1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyTWFwOiBmdW5jdGlvbihkYXRhLCB0eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgc2NoZW1hOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IG1vZGVsLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnRyZWVWTyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UudHJlZVZPKS5zcGxpdCgnXCJjaGlsZHJlblwiOicpLmpvaW4oJ1wiaXRlbXNcIjonKSkuaXRlbXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50cmVlVk87XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KSB9KTtcclxuXHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7IGRhdGFTb3VyY2U6IG5ldyBrZW5kby5kYXRhLkhpZXJhcmNoaWNhbERhdGFTb3VyY2Uoe1xyXG4gICAgICAgICAgICAgICAgZGF0YTogaXRlbXMsXHJcbiAgICAgICAgICAgICAgICBzY2hlbWE6IHtcclxuICAgICAgICAgICAgICAgICAgICBtb2RlbDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5GaWVsZFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB0ZW1wbGF0ZVxyXG4gICAgICAgIGlmKHR5cGVvZiB0ZW1wbGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQob3B0aW9ucywgeyB0ZW1wbGF0ZTogdGVtcGxhdGUgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBtZXRob2RzXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRhdGEgaXRlbSB0byB3aGljaCB0aGUgc3BlY2lmaWVkIG5vZGUgaXMgYm91bmQuXHJcbiAgICAgKiBAcGFyYW0geyhqUXVlcnl8RWxlbWVudHxTdHJpbmcpfSBub2RlIC0gQSBzdHJpbmcsIERPTSBlbGVtZW50IG9yIGpRdWVyeSBvYmplY3Qgd2hpY2ggcmVwcmVzZW50cyB0aGUgbm9kZS4gQSBzdHJpbmcgaXMgdHJlYXRlZCBhcyBhIGpRdWVyeSBzZWxlY3Rvci5cclxuICAgICAqIEByZXR1cm4gIHtrZW5kby5kYXRhLk5vZGV9IFRoZSBtb2RlbCBvZiB0aGUgaXRlbSB0aGF0IHdhcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXHJcbiAgICAgKi9cclxuICAgIGRhdGFJdGVtKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlVmlldy5kYXRhSXRlbShub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBwYXJlbnQobm9kZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyZWVWaWV3LnBhcmVudChub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxlY3Qobm9kZSkge1xyXG4gICAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZVZpZXcuc2VsZWN0KCk7XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlVmlldy5zZWxlY3Qobm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFwcGVuZChub2RlRGF0YSwgcGFyZW50Tm9kZSwgc3VjY2Vzcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyZWVWaWV3LmFwcGVuZChub2RlRGF0YSwgcGFyZW50Tm9kZSwgc3VjY2Vzcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVtb3ZlKG5vZGUpIHtcclxuICAgICAgICB0aGlzLnRyZWVWaWV3LnJlbW92ZShub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBleHBhbmQobm9kZSkge1xyXG4gICAgICAgIHRoaXMudHJlZVZpZXcuZXhwYW5kKG5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGV4cGFuZEFsbCgpIHtcclxuICAgICAgICB0aGlzLnRyZWVWaWV3LmV4cGFuZCgnLmstaXRlbScpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbGxhcHNlKG5vZGUpIHtcclxuICAgICAgICB0aGlzLnRyZWVWaWV3LmNvbGxhcHNlKG5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbGxhcHNlQWxsKCkge1xyXG4gICAgICAgIHRoaXMudHJlZVZpZXcuY29sbGFwc2UoJy5rLWl0ZW0nKTtcclxuICAgIH1cclxuXHJcbiAgICBlbmFibGUobm9kZSkge1xyXG4gICAgICAgIHRoaXMudHJlZVZpZXcuZW5hYmxlKG5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc2FibGUobm9kZSkge1xyXG4gICAgICAgIHRoaXMudHJlZVZpZXcuZW5hYmxlKG5vZGUsIGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICBlbmFibGVBbGwoKSB7XHJcbiAgICAgICAgdGhpcy50cmVlVmlldy5lbmFibGUoJy5rLWl0ZW0nKTtcclxuICAgIH1cclxuXHJcbiAgICBkaXNhYmxlQWxsKCkge1xyXG4gICAgICAgIHRoaXMudHJlZVZpZXcuZW5hYmxlKCcuay1pdGVtJywgZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbHRlcih2YWx1ZSkge1xyXG4gICAgICAgIGlmKHZhbHVlICE9PSBcIlwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJlZVZpZXcuZGF0YVNvdXJjZS5maWx0ZXIoe1xyXG4gICAgICAgICAgICAgICAgZmllbGQ6IHRoaXMucHJvcHMuZGF0YVRleHRGaWVsZCxcclxuICAgICAgICAgICAgICAgIG9wZXJhdG9yOiAnY29udGFpbnMnLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50cmVlVmlldy5kYXRhU291cmNlLmZpbHRlcih7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNvcnQoZGlyKSB7XHJcbiAgICAgICAgLy8gZGly7J2AICdhc2MnIG9yICdkZXNjJ1xyXG4gICAgICAgIHRoaXMudHJlZVZpZXcuZGF0YVNvdXJjZS5zb3J0KHtcclxuICAgICAgICAgICAgZmllbGQ6IHRoaXMucHJvcHMuZGF0YVRleHRGaWVsZCxcclxuICAgICAgICAgICAgZGlyOiBkaXJcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldCBkYXRhU291cmNlLlxyXG4gICAgICogQHJldHVybiB7a2VuZG8uZGF0YS5EYXRhU291cmNlfSBUcmVlVmlldyBkYXRhIHNvdXJjZS5cclxuICAgICAqL1xyXG4gICAgZ2V0RGF0YVNvdXJjZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlVmlldy5kYXRhU291cmNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogZHJhZ2dhYmxlXHJcbiAgICAgKi9cclxuICAgIGRyYWdnYWJsZSgpIHtcclxuICAgICAgICB0aGlzLiR0cmVlVmlldy5rZW5kb0RyYWdnYWJsZSh7XHJcbiAgICAgICAgICAgIGhpbnQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmNsb25lKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gZXZlbnRzXHJcbiAgICBvblNlbGVjdChldmVudCkge1xyXG4gICAgICAgIC8vIOqwmeydgCDrhbjrk5zrpbwgc2VsZWN0IO2VoCDqsr3smrAg7J2067Kk7Yq4IOuwnOyDne2VmOuPhOuhnSDtlZjquLAg7JyE7ZW0XHJcbiAgICAgICAgLy8gY2xpY2sg7J2067Kk7Yq47IucIGstc3RhdGUtc2VsZWN0ZWQg7KCc6rGw7ZWY6rOgXHJcbiAgICAgICAgLy8gc2VsZWN0IOydtOuypO2KuOyLnCDstpTqsIDtlZzri6QuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygndHJlZXZpZXcgc2VsZWN0Jyk7XHJcblxyXG5cclxuICAgICAgICAvLyQoZXZlbnQubm9kZSkuZmluZCgnc3Bhbi5rLWluJykuYWRkQ2xhc3MoJ2stc3RhdGUtc2VsZWN0ZWQnKTtcclxuICAgICAgICB2YXIgbm9kZSwgc2VsZWN0ZWRJdGVtO1xyXG5cclxuICAgICAgICBpZih0eXBlb2YgZXZlbnQubm9kZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZGlzcGF0Y2ggY2xpY2snKTtcclxuICAgICAgICAgICAgbm9kZSA9IGV2ZW50O1xyXG4gICAgICAgICAgICAvLyQobm9kZSkuZmluZCgnc3Bhbi5rLWluJykuYWRkQ2xhc3MoJ2stc3RhdGUtc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgJChub2RlKS5jaGlsZHJlbignOmZpcnN0JykuZmluZCgnc3Bhbi5rLWluJykuYWRkQ2xhc3MoJ2stc3RhdGUtc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgdGhpcy5vblNlbGVjdENhbGwgPSBmYWxzZTtcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2NsaWNrJyk7XHJcbiAgICAgICAgICAgIG5vZGUgPSBldmVudC5ub2RlO1xyXG4gICAgICAgICAgICB0aGlzLm9uU2VsZWN0Q2FsbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbGVjdGVkSXRlbSA9IHRoaXMudHJlZVZpZXcuZGF0YUl0ZW0obm9kZSk7XHJcbiAgICAgICAgLy92YXIgc2VsZWN0ZWRJdGVtID0gdGhpcy50cmVlVmlldy5kYXRhSXRlbShldmVudC5ub2RlKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKHNlbGVjdGVkSXRlbSk7XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uU2VsZWN0ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25TZWxlY3QoZXZlbnQsIHNlbGVjdGVkSXRlbSk7XHJcblxyXG4gICAgICAgICAgICAvL2V2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkNoZWNrKGV2ZW50KSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNoZWNrYm94IGNoYW5nZWQ6IFwiKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKGV2ZW50Lm5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIG9uQ2hhbmdlKGV2ZW50KSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNlbGVjdGlvbiBjaGFuZ2VkXCIpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coZXZlbnQpO1xyXG5cclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkNoYW5nZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAvL3ZhciBkYXRhID0gZXZlbnQubm9kZTtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZShldmVudCk7XHJcbiAgICAgICAgICAgIC8vZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uQ29sbGFwc2UoZSkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJDb2xsYXBzaW5nIFwiKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKGV2ZW50Lm5vZGUpO1xyXG4gICAgICAgIHZhciBzZWxlY3RlZEl0ZW0gPSB0aGlzLnRyZWVWaWV3LmRhdGFJdGVtKGUubm9kZSk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhzZWxlY3RlZEl0ZW0pO1xyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uQ29sbGFwc2UgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNvbGxhcHNlKGUsIHNlbGVjdGVkSXRlbSk7XHJcblxyXG4gICAgICAgICAgICAvL2Uuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uRXhwYW5kKGUpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiRXhwYW5kaW5nIFwiKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKGV2ZW50Lm5vZGUpO1xyXG4gICAgICAgIC8vIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBjb25zdCB7IHVybCwgbWV0aG9kLCBkYXRhLCBvbkRlbWFuZCwgaGFzQ2hpbGRyZW5GaWVsZCwgY2hpbGRyZW5GaWVsZCB9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICAgICAgdmFyIG5vZGUgPSBlLm5vZGUsXHJcbiAgICAgICAgICAgIHNlbGVjdGVkSXRlbSA9IHRoaXMudHJlZVZpZXcuZGF0YUl0ZW0obm9kZSksXHJcbiAgICAgICAgICAgIGhhc0NoaWxkcmVuID0gc2VsZWN0ZWRJdGVtW2hhc0NoaWxkcmVuRmllbGRdLFxyXG4gICAgICAgICAgICBhcHBlbmRlZCA9IHNlbGVjdGVkSXRlbVsnYXBwZW5kZWQnXTtcclxuICAgICAgICBcclxuICAgICAgICBpZihvbkRlbWFuZCA9PT0gdHJ1ZSAmJiBcclxuICAgICAgICAgICAgKCAoaGFzQ2hpbGRyZW4gPT09IHRydWUgfHwgaGFzQ2hpbGRyZW4gPT09ICd0cnVlJykgJiYgIWFwcGVuZGVkICkpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ29uRGVtYW5kJyk7XHJcbiAgICAgICAgICAgICQuYWpheCh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBtZXRob2QsXHJcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShzZWxlY3RlZEl0ZW0pLFxyXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04JyxcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVWaWV3LmFwcGVuZChkYXRhLCAkKG5vZGUpKTtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEl0ZW1bJ2FwcGVuZGVkJ10gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMub25FeHBhbmQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkV4cGFuZChlLCBzZWxlY3RlZEl0ZW0pO1xyXG5cclxuICAgICAgICAgICAgLy9lLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkRyYWdTdGFydChlKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN0YXJ0ZWQgZHJhZ2dpbmcgXCIpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coZXZlbnQuc291cmNlTm9kZSk7XHJcbiAgICAgICAgdmFyIHNlbGVjdGVkSXRlbSA9IHRoaXMudHJlZVZpZXcuZGF0YUl0ZW0oZS5zb3VyY2VOb2RlKTtcclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkRyYWdTdGFydCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB2YXIgaXRlbSA9IHNlbGVjdGVkSXRlbTtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkRyYWdTdGFydChlLCBpdGVtKTtcclxuXHJcbiAgICAgICAgICAgIC8vZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25EcmFnKGUpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiRHJhZ2dpbmcgXCIpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coZXZlbnQuc291cmNlTm9kZSk7XHJcbiAgICAgICAgdmFyIHNlbGVjdGVkSXRlbSA9IHRoaXMudHJlZVZpZXcuZGF0YUl0ZW0oZS5zb3VyY2VOb2RlKSxcclxuICAgICAgICAgICAgcGFyZW50Tm9kZSwgcGFyZW50SXRlbTtcclxuXHJcbiAgICAgICAgLy8gdHJlZXZpZXcgb3V0c2lkZSDroZwgZHJhZ+2VmOuptCBjbGFzc05hbWUgb2YgbnVsbCDsl5Drn6wg7LKY66asXHJcbiAgICAgICAgLy8gdHJlZXZpZXcg7JWI7JeQ7IScIGRyYWcg7ZWg65WM66eMIOu2gOuqqCDssL7ripTri6QuXHJcbiAgICAgICAgaWYodGhpcy4kdHJlZVZpZXcuZmluZChlLmRyb3BUYXJnZXQpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHRoaXMudHJlZVZpZXcucGFyZW50KGUuZHJvcFRhcmdldCk7XHJcbiAgICAgICAgICAgIHBhcmVudEl0ZW0gPSB0aGlzLnRyZWVWaWV3LmRhdGFJdGVtKHBhcmVudE5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhwYXJlbnRJdGVtKTtcclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkRyYWcgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkRyYWcoZSwgc2VsZWN0ZWRJdGVtLCBwYXJlbnRJdGVtKTtcclxuXHJcbiAgICAgICAgICAgIC8vZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25Ecm9wKGUpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdUcmVlVmlldyBEcm9wcGVkJyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhlLnZhbGlkKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKGUuc291cmNlTm9kZSk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhlLmRlc3RpbmF0aW9uTm9kZSk7XHJcbiAgICAgICAgdmFyIHNlbGVjdGVkSXRlbSA9IHRoaXMudHJlZVZpZXcuZGF0YUl0ZW0oZS5zb3VyY2VOb2RlKSxcclxuICAgICAgICAgICAgcGFyZW50Tm9kZSwgcGFyZW50SXRlbTtcclxuXHJcbiAgICAgICAgLy8gdHJlZXZpZXcgb3V0c2lkZSDroZwgZHJhZ+2VmOuptCBlLmRlc3RpbmF0aW9uTm9kZSDqsJLsnbQgdW5kZWZpbmVk6rCAIOuQnOuLpC5cclxuICAgICAgICBpZih0eXBlb2YgZS5kZXN0aW5hdGlvbk5vZGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSB0aGlzLnRyZWVWaWV3LnBhcmVudChlLmRlc3RpbmF0aW9uTm9kZSk7XHJcbiAgICAgICAgICAgIHBhcmVudEl0ZW0gPSB0aGlzLnRyZWVWaWV3LmRhdGFJdGVtKHBhcmVudE5vZGUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhwYXJlbnRJdGVtKTtcclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkRyb3AgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkRyb3AoZSwgc2VsZWN0ZWRJdGVtLCBwYXJlbnRJdGVtKTtcclxuXHJcbiAgICAgICAgICAgIC8vZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25EcmFnRW5kKGUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnVHJlZVZpZXcgRmluaXNoZWQgZHJhZ2dpbmcnKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKGV2ZW50LnNvdXJjZU5vZGUpO1xyXG4gICAgICAgIHZhciBzZWxlY3RlZEl0ZW0gPSB0aGlzLnRyZWVWaWV3LmRhdGFJdGVtKGUuc291cmNlTm9kZSksXHJcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSB0aGlzLnRyZWVWaWV3LnBhcmVudChlLmRlc3RpbmF0aW9uTm9kZSksXHJcbiAgICAgICAgICAgIHBhcmVudEl0ZW0gPSB0aGlzLnRyZWVWaWV3LmRhdGFJdGVtKHBhcmVudE5vZGUpO1xyXG5cclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkRyYWdFbmQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkRyYWdFbmQoZSwgc2VsZWN0ZWRJdGVtLCBwYXJlbnRJdGVtKTtcclxuXHJcbiAgICAgICAgICAgIC8vZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uTmF2aWdhdGUoZSkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJOYXZpZ2F0ZSBcIik7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhldmVudC5ub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBvbkRhdGFCb3VuZChlKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ29uRGF0YUJvdW5kJyk7XHJcbiAgICB9XHJcblxyXG4gICAgb25DbGljayhlKSB7XHJcbiAgICAgICAgLypcclxuICAgICAgICB2YXIgbm9kZSA9ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFwiLmstaXRlbVwiKSxcclxuICAgICAgICAgICAgc2VsZWN0ZWRJdGVtID0gdGhpcy50cmVlVmlldy5kYXRhSXRlbShub2RlKTtcclxuICAgICAgICBjb25zb2xlLmxvZygndHJlZXZpZXcgY2xpY2snKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKHNlbGVjdGVkSXRlbSk7XHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQsIHNlbGVjdGVkSXRlbSk7XHJcblxyXG4gICAgICAgICAgICAvL2V2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAqL1xyXG4gICAgICAgIC8vIOqwmeydgCDrhbjrk5zrpbwgc2VsZWN0IO2VoCDqsr3smrAg7J2067Kk7Yq4IOuwnOyDne2VmOuPhOuhnSDtlZjquLAg7JyE7ZW0XHJcbiAgICAgICAgLy8gY2xpY2sg7J2067Kk7Yq47IucIGstc3RhdGUtc2VsZWN0ZWQg7KCc6rGw7ZWY6rOgXHJcbiAgICAgICAgLy8gc2VsZWN0IOydtOuypO2KuOyLnCDstpTqsIDtlZzri6QuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygkKGV2ZW50LnRhcmdldCkuaGFzQ2xhc3MoJ2stc3RhdGUtc2VsZWN0ZWQnKSk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygndHJlZXZpZXcgb25jbGljaycpO1xyXG4gICAgICAgIGlmKHRoaXMub25TZWxlY3RDYWxsID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoXCIuay1pdGVtXCIpO1xyXG4gICAgICAgICAgICAkKGUudGFyZ2V0KS5yZW1vdmVDbGFzcygnay1zdGF0ZS1zZWxlY3RlZCcpO1xyXG4gICAgICAgICAgICB0aGlzLnRyZWVWaWV3LnRyaWdnZXIoJ3NlbGVjdCcsIG5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9uU2VsZWN0Q2FsbCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIG9uRGJsY2xpY2soZXZlbnQpIHtcclxuICAgICAgICB2YXIgbm9kZSA9ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFwiLmstaXRlbVwiKSxcclxuICAgICAgICAgICAgc2VsZWN0ZWRJdGVtID0gdGhpcy50cmVlVmlldy5kYXRhSXRlbShub2RlKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdvbkRibGNsaWNrJyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhzZWxlY3RlZEl0ZW0pO1xyXG5cclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkRibGNsaWNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25EYmxjbGljayhldmVudCwgc2VsZWN0ZWRJdGVtKTtcclxuXHJcbiAgICAgICAgICAgIC8vZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIFxyXG5cclxuICAgIHJlbmRlcigpIHtcclxuICAgICAgICAvLyDtlYTsiJgg7ZWt66qpXHJcbiAgICAgICAgY29uc3Qge2NsYXNzTmFtZX0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2IGlkPXt0aGlzLmlkfSBjbGFzc05hbWU9e2NsYXNzTmFtZXMoY2xhc3NOYW1lKX0+PC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuVHJlZVZpZXcucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xyXG5UcmVlVmlldy5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUcmVlVmlldzsiLCIvKipcclxuICogV2luZG93IGNvbXBvbmVudFxyXG4gKlxyXG4gKiB2ZXJzaW9uIDx0dD4kIFZlcnNpb246IDEuMCAkPC90dD4gZGF0ZToyMDE2LzA5LzA2XHJcbiAqIGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmhyYWhuQG5raWEuY28ua3JcIj5BaG4gSHl1bmctUm88L2E+XHJcbiAqXHJcbiAqIGV4YW1wbGU6XHJcbiAqIDxQdWYuV2luZG93IG9wdGlvbnM9e29wdGlvbnN9IC8+XHJcbiAqXHJcbiAqIEtlbmRvIFdpbmRvdyDrnbzsnbTruIzrn6zrpqzsl5Ag7KKF7IaN7KCB7J2064ukLlxyXG4gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IFV0aWwgZnJvbSAnLi4vc2VydmljZXMvVXRpbCc7XHJcblxyXG5jb25zdCBwcm9wVHlwZXMgPSB7XHJcbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcclxuICAgIHRpdGxlOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgdGl0bGVJY29uQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgdmlzaWJsZTogUHJvcFR5cGVzLmJvb2wsXHJcbiAgICBhY3Rpb25zOiBQcm9wVHlwZXMuYXJyYXksICAgICAgIC8vIFsnUGluJywgJ1JlZnJlc2gnLCAnTWluaW1pemUnLCAnTWF4aW1pemUnLCAnQ2xvc2UnXVxyXG4gICAgbW9kYWw6IFByb3BUeXBlcy5ib29sLFxyXG4gICAgcmVzaXphYmxlOiBQcm9wVHlwZXMuYm9vbCxcclxuICAgIHdpZHRoOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgICAgIFByb3BUeXBlcy5udW1iZXJcclxuICAgIF0pLFxyXG4gICAgaGVpZ2h0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcclxuICAgICAgICBQcm9wVHlwZXMuc3RyaW5nLFxyXG4gICAgICAgIFByb3BUeXBlcy5udW1iZXJcclxuICAgIF0pLFxyXG4gICAgbWluV2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICBtaW5IZWlnaHQ6IFByb3BUeXBlcy5udW1iZXIsXHJcbiAgICBvbk9wZW46IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25DbG9zZTogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICBvblJlc2l6ZTogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICBvbkRyYWdTdGFydDogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICBvbkRyYWdFbmQ6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25SZWZyZXNoOiBQcm9wVHlwZXMuZnVuYyxcclxuICAgIG9uQWN0aXZhdGU6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25EZWFjdGl2YXRlOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xyXG4gICAgdGl0bGU6ICdUaXRsZScsXHJcbiAgICB0aXRsZUljb25DbGFzc05hbWU6ICd3aW5kb3ctdGl0bGUtaWNvbicsXHJcbiAgICB2aXNpYmxlOiB0cnVlLCBcclxuICAgIGFjdGlvbnM6IFsnTWluaW1pemUnLCAnTWF4aW1pemUnLCAnQ2xvc2UnXSwgLy8gUGluXHJcbiAgICBtb2RhbDogZmFsc2UsIFxyXG4gICAgcmVzaXphYmxlOiB0cnVlLCBcclxuICAgIG1pbldpZHRoOiAxNTAsIFxyXG4gICAgbWluSGVpZ2h0OiAxMDBcclxufTtcclxuXHJcbi8qKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXaW5kb3cuICovXHJcbmNsYXNzIFdpbmRvdyBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuXHJcbiAgICAgICAgLy8gT3BlcmF0aW9ucyB1c3VhbGx5IGNhcnJpZWQgb3V0IGluIGNvbXBvbmVudFdpbGxNb3VudCBnbyBoZXJlXHJcbiAgICAgICAgbGV0IGlkID0gcHJvcHMuaWQ7XHJcbiAgICAgICAgaWYodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICBpZCA9IFV0aWwuZ2V0VVVJRCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG5cclxuICAgICAgICAvLyBNYW51YWxseSBiaW5kIHRoaXMgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQgaW5zdGFuY2UuLi5cclxuICAgICAgICB0aGlzLm9uT3BlbiA9IHRoaXMub25PcGVuLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbkNsb3NlID0gdGhpcy5vbkNsb3NlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vblJlc2l6ZSA9IHRoaXMub25SZXNpemUuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9uRHJhZ1N0YXJ0ID0gdGhpcy5vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25EcmFnRW5kID0gdGhpcy5vbkRyYWdFbmQuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLm9uUmVmcmVzaCA9IHRoaXMub25SZWZyZXNoLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbkFjdGl2YXRlID0gdGhpcy5vbkFjdGl2YXRlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbkRlYWN0aXZhdGUgPSB0aGlzLm9uRGVhY3RpdmF0ZS5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIC8vIOy1nOy0iCDroIzrjZTrp4HsnbQg7J287Ja064KcIOuLpOydjCjtlZzrsogg7Zi47LacKVxyXG4gICAgICAgIHRoaXMuJHdpbmRvdyA9ICQoJyMnK3RoaXMuaWQpO1xyXG4gICAgICAgIHRoaXMud2luZG93ID0gdGhpcy4kd2luZG93LmtlbmRvV2luZG93KHRoaXMub3B0aW9ucygpKS5kYXRhKCdrZW5kb1dpbmRvdycpO1xyXG5cclxuICAgICAgICAvLyBFdmVudHNcclxuICAgICAgICB0aGlzLndpbmRvdy5iaW5kKCdvcGVuJywgdGhpcy5vbk9wZW4pO1xyXG4gICAgICAgIHRoaXMud2luZG93LmJpbmQoJ2Nsb3NlJywgdGhpcy5vbkNsb3NlKTtcclxuICAgICAgICB0aGlzLndpbmRvdy5iaW5kKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplKTtcclxuICAgICAgICB0aGlzLndpbmRvdy5iaW5kKCdkcmFnc3RhcnQnLCB0aGlzLm9uRHJhZ1N0YXJ0KTtcclxuICAgICAgICB0aGlzLndpbmRvdy5iaW5kKCdkcmFnZW5kJywgdGhpcy5vbkRyYWdFbmQpO1xyXG4gICAgICAgIHRoaXMud2luZG93LmJpbmQoJ3JlZnJlc2gnLCB0aGlzLm9uUmVmcmVzaCk7XHJcbiAgICAgICAgdGhpcy53aW5kb3cuYmluZCgnYWN0aXZhdGUnLCB0aGlzLm9uQWN0aXZhdGUpO1xyXG4gICAgICAgIHRoaXMud2luZG93LmJpbmQoJ2RlYWN0aXZhdGUnLCB0aGlzLm9uRGVhY3RpdmF0ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgY2xhc3NOYW1lLCB0aXRsZUljb25DbGFzc05hbWUgfSA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgLy8gcmVuZGVy7J2YIGRpduuKlCBrLXdpbmRvdy1jb250ZW50IOyXkCDtlbTri7nrkJjripQgZG9t7J2064ukLlxyXG4gICAgICAgIC8vIOu2gOuqqOyduCBrLXdpbmRvdyDsl5AgYWRkQ2xhc3Mg7ZW07KSA64ukLlxyXG4gICAgICAgIGlmKHR5cGVvZiBjbGFzc05hbWUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJHdpbmRvdy5wYXJlbnQoKS5hZGRDbGFzcyhjbGFzc05hbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdGl0bGUgaWNvblxyXG4gICAgICAgIC8vIHRoaXMud2luZG93LndyYXBwZXIuZmluZCgnLmstd2luZG93LXRpdGxlJykucHJlcGVuZCgnPHNwYW4gY2xhc3M9JyArIHRpdGxlSWNvbkNsYXNzTmFtZSArICc+PC9zcGFuPicpO1xyXG4gICAgICAgICQoJzxzcGFuPjwvc3Bhbj4nKS5pbnNlcnRCZWZvcmUodGhpcy53aW5kb3cud3JhcHBlci5maW5kKCcuay13aW5kb3ctdGl0bGUnKSkuYWRkQ2xhc3ModGl0bGVJY29uQ2xhc3NOYW1lKTtcclxuICAgIH1cclxuXHJcbiAgICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xyXG4gICAgICAgIC8vIOy7tO2PrOuEjO2KuOqwgCDsg4jroZzsmrQgcHJvcHPrpbwg67Cb7J2EIOuVjCDtmLjstpwo7LWc7LSIIOugjOuNlOungSDsi5zsl5DripQg7Zi47Lac65CY7KeAIOyViuydjClcclxuICAgICAgICBpZih0eXBlb2YgbmV4dFByb3BzLnRpdGxlSWNvbkNsYXNzTmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbmV4dFByb3BzLnRpdGxlSWNvbkNsYXNzTmFtZSAhPT0gdGhpcy5wcm9wcy50aXRsZUljb25DbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRUaXRsZUljb24obmV4dFByb3BzLnRpdGxlSWNvbkNsYXNzTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgb3B0aW9ucygpIHtcclxuICAgICAgICBjb25zdCB7IHRpdGxlLCB2aXNpYmxlLCBhY3Rpb25zLCBtb2RhbCwgcmVzaXphYmxlLCB3aWR0aCwgaGVpZ2h0LCBtaW5XaWR0aCwgbWluSGVpZ2h0IH0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxyXG4gICAgICAgICAgICB2aXNpYmxlOiB2aXNpYmxlLFxyXG4gICAgICAgICAgICBhY3Rpb25zOiBhY3Rpb25zLFxyXG4gICAgICAgICAgICBtb2RhbDogbW9kYWwsXHJcbiAgICAgICAgICAgIHJlc2l6YWJsZTogcmVzaXphYmxlLFxyXG4gICAgICAgICAgICBtaW5XaWR0aDogbWluV2lkdGgsXHJcbiAgICAgICAgICAgIG1pbkhlaWdodDogbWluSGVpZ2h0XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gd2lkdGhcclxuICAgICAgICBpZih0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKG9wdGlvbnMsIHsgd2lkdGg6IHdpZHRoIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaGVpZ2h0XHJcbiAgICAgICAgaWYodHlwZW9mIGhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgJC5leHRlbmQob3B0aW9ucywgeyBoZWlnaHQ6IGhlaWdodCB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIG1ldGhvZHNcclxuICAgIG9wZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2luZG93Lm9wZW4oKTtcclxuICAgIH1cclxuXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aW5kb3cuY2xvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBjZW50ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2luZG93LmNlbnRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIHBvcyh4LCB5KSB7XHJcbiAgICAgICAgdGhpcy4kd2luZG93Lm9mZnNldCh7IGxlZnQ6IHgsIHRvcDogeSB9KTtcclxuICAgIH1cclxuXHJcbiAgICB0aXRsZSh2YWwpIHtcclxuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2luZG93LnRpdGxlKCk7XHJcbiAgICAgICAgfWVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aW5kb3cudGl0bGUodmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0VGl0bGVJY29uKGljb25DbGFzc05hbWUpIHtcclxuICAgICAgICBpZih0eXBlb2YgaWNvbkNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy53aW5kb3cud3JhcHBlci5maW5kKCcuay13aW5kb3ctdGl0bGUnKS5wcmV2KCkuYXR0cignY2xhc3MnLCBpY29uQ2xhc3NOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gZXZlbnRzXHJcbiAgICBvbk9wZW4oZSkge1xyXG5cclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbk9wZW4gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25PcGVuKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkNsb3NlKGUpIHtcclxuXHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMub25DbG9zZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNsb3NlKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvblJlc2l6ZShlKSB7XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uUmVzaXplICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uUmVzaXplKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkRyYWdTdGFydChlKSB7XHJcblxyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uRHJhZ1N0YXJ0ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uRHJhZ1N0YXJ0KGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkRyYWdFbmQoZSkge1xyXG5cclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkRyYWdFbmQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25EcmFnRW5kKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvblJlZnJlc2goZSkge1xyXG5cclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vblJlZnJlc2ggIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25SZWZyZXNoKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkFjdGl2YXRlKGUpIHtcclxuXHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMub25BY3RpdmF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkFjdGl2YXRlKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkRlYWN0aXZhdGUoZSkge1xyXG5cclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkRlYWN0aXZhdGUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25EZWFjdGl2YXRlKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIC8vIO2VhOyImCDtla3rqqlcclxuICAgICAgICBjb25zdCB7IGNsYXNzTmFtZSwgY2hpbGRyZW4gfSA9IHRoaXMucHJvcHM7XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgaWQ9e3RoaXMuaWR9PntjaGlsZHJlbn08L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5XaW5kb3cucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xyXG5XaW5kb3cuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgV2luZG93OyIsIi8qKlxyXG4gKiBUYWIgY29tcG9uZW50XHJcbiAqXHJcbiAqIHZlcnNpb24gPHR0PiQgVmVyc2lvbjogMS4wICQ8L3R0PiBkYXRlOjIwMTYvMDgvMDZcclxuICogYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86aHJhaG5AbmtpYS5jby5rclwiPkFobiBIeXVuZy1SbzwvYT5cclxuICpcclxuICogZXhhbXBsZTpcclxuICogPFB1Zi5UYWIgLz5cclxuICpcclxuICogS2VuZG8gVGFiU3RyaXAg65287J2067iM65+s66as7JeQIOyiheyGjeyggeydtOuLpC5cclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XHJcblxyXG4vKiogQ2xhc3MgcmVwcmVzZW50aW5nIGEgVGFiLiAqL1xyXG5jbGFzcyBUYWIgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIC8vIO2VhOyImCDtla3rqqlcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8bGk+e3RoaXMucHJvcHMuY2hpbGRyZW59PC9saT5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUYWI7IiwiLyoqXHJcbiAqIFRhYkNvbnRlbnQgY29tcG9uZW50XHJcbiAqXHJcbiAqIHZlcnNpb24gPHR0PiQgVmVyc2lvbjogMS4wICQ8L3R0PiBkYXRlOjIwMTYvMDgvMDZcclxuICogYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86aHJhaG5AbmtpYS5jby5rclwiPkFobiBIeXVuZy1SbzwvYT5cclxuICpcclxuICogZXhhbXBsZTpcclxuICogPFB1Zi5UYWJDb250ZW50IC8+XHJcbiAqXHJcbiAqIEtlbmRvIFRhYlN0cmlwIOudvOydtOu4jOufrOumrOyXkCDsooXsho3soIHsnbTri6QuXHJcbiAqL1xyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5pbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xyXG5cclxuLyoqIENsYXNzIHJlcHJlc2VudGluZyBhIFRhYkNvbnRlbnQuICovXHJcbmNsYXNzIFRhYkNvbnRlbnQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcclxuICAgICAgICBzdXBlcihwcm9wcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIC8vIO2VhOyImCDtla3rqqlcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAge3RoaXMucHJvcHMuY2hpbGRyZW59XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRhYkNvbnRlbnQ7IiwiLyoqXHJcbiAqIFRhYlN0cmlwIGNvbXBvbmVudFxyXG4gKlxyXG4gKiB2ZXJzaW9uIDx0dD4kIFZlcnNpb246IDEuMCAkPC90dD4gZGF0ZToyMDE2LzA4LzA2XHJcbiAqIGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmhyYWhuQG5raWEuY28ua3JcIj5BaG4gSHl1bmctUm88L2E+XHJcbiAqXHJcbiAqIGV4YW1wbGU6XHJcbiAqIDxQdWYuVGFiU3RyaXAgY2xhc3NOYW1lPXtjbGFzc05hbWV9IHNlbGVjdGVkSW5kZXg9ezB9IG9uU2VsZWN0PXtmdW5jfSAvPlxyXG4gKlxyXG4gKiBLZW5kbyBUYWJTdHJpcCDrnbzsnbTruIzrn6zrpqzsl5Ag7KKF7IaN7KCB7J2064ukLlxyXG4gKi9cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCwgUHJvcFR5cGVzIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgY2xhc3NOYW1lcyBmcm9tICdjbGFzc25hbWVzJztcclxuaW1wb3J0IFV0aWwgZnJvbSAnLi4vLi4vc2VydmljZXMvVXRpbCc7XHJcblxyXG5jb25zdCBwcm9wVHlwZXMgPSB7XHJcbiAgICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXHJcbiAgICBzZWxlY3RlZEluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gICAgY29udGVudFVybHM6IFByb3BUeXBlcy5hcnJheSxcclxuICAgIGFuaW1hdGlvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbXHJcbiAgICAgICAgUHJvcFR5cGVzLm9iamVjdCxcclxuICAgICAgICBQcm9wVHlwZXMuYm9vbFxyXG4gICAgXSksXHJcbiAgICB0YWJQb3NpdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsnbGVmdCcsJ3JpZ2h0JywnYm90dG9tJ10pLFxyXG4gICAgb25TZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25BY3RpdmF0ZTogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICBvblNob3c6IFByb3BUeXBlcy5mdW5jLFxyXG4gICAgb25Db250ZW50TG9hZDogUHJvcFR5cGVzLmZ1bmMsXHJcbiAgICBvbkVycm9yOiBQcm9wVHlwZXMuZnVuY1xyXG59O1xyXG5cclxuY29uc3QgZGVmYXVsdFByb3BzID0ge1xyXG4gICAgc2VsZWN0ZWRJbmRleDogMCwgXHJcbiAgICBhbmltYXRpb246IGZhbHNlXHJcbn07XHJcblxyXG4vKiogQ2xhc3MgcmVwcmVzZW50aW5nIGEgVGFiU3RyaXAuICovXHJcbmNsYXNzIFRhYlN0cmlwIGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XHJcbiAgICAgICAgc3VwZXIocHJvcHMpO1xyXG5cclxuICAgICAgICAvLyBPcGVyYXRpb25zIHVzdWFsbHkgY2FycmllZCBvdXQgaW4gY29tcG9uZW50V2lsbE1vdW50IGdvIGhlcmVcclxuICAgICAgICBsZXQgaWQgPSBwcm9wcy5pZDtcclxuICAgICAgICBpZih0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIGlkID0gVXRpbC5nZXRVVUlEKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcblxyXG4gICAgICAgIC8vIE1hbnVhbGx5IGJpbmQgdGhpcyBtZXRob2QgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZS4uLlxyXG4gICAgICAgIHRoaXMub25TZWxlY3QgPSB0aGlzLm9uU2VsZWN0LmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vbkFjdGl2YXRlID0gdGhpcy5vbkFjdGl2YXRlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5vblNob3cgPSB0aGlzLm9uU2hvdy5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25Db250ZW50TG9hZCA9IHRoaXMub25Db250ZW50TG9hZC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25FcnJvciA9IHRoaXMub25FcnJvci5iaW5kKHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xyXG4gICAgICAgIC8vIOy1nOy0iCDroIzrjZTrp4HsnbQg7J287Ja064KcIOuLpOydjCjtlZzrsogg7Zi47LacKVxyXG4gICAgICAgIHRoaXMuJHRhYnN0cmlwID0gJCgnIycrdGhpcy5pZCk7XHJcbiAgICAgICAgdGhpcy50YWJzdHJpcCA9IHRoaXMuJHRhYnN0cmlwLmtlbmRvVGFiU3RyaXAodGhpcy5vcHRpb25zKCkpLmRhdGEoJ2tlbmRvVGFiU3RyaXAnKTtcclxuXHJcbiAgICAgICAgLy8gRXZlbnRzXHJcbiAgICAgICAgdGhpcy50YWJzdHJpcC5iaW5kKCdzZWxlY3QnLCB0aGlzLm9uU2VsZWN0KTtcclxuICAgICAgICB0aGlzLnRhYnN0cmlwLmJpbmQoJ2FjdGl2YXRlJywgdGhpcy5vbkFjdGl2YXRlKTtcclxuICAgICAgICB0aGlzLnRhYnN0cmlwLmJpbmQoJ3Nob3cnLCB0aGlzLm9uU2hvdyk7XHJcbiAgICAgICAgdGhpcy50YWJzdHJpcC5iaW5kKCdjb250ZW50TG9hZCcsIHRoaXMub25Db250ZW50TG9hZCk7XHJcbiAgICAgICAgdGhpcy50YWJzdHJpcC5iaW5kKCdlcnJvcicsIHRoaXMub25FcnJvcik7XHJcblxyXG4gICAgICAgIHRoaXMuc2VsZWN0KHRoaXMucHJvcHMuc2VsZWN0ZWRJbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBvcHRpb25zKCkge1xyXG4gICAgICAgIGNvbnN0IHthbmltYXRpb24sIGNvbnRlbnRVcmxzLCB0YWJQb3NpdGlvbn0gPSB0aGlzLnByb3BzO1xyXG5cclxuICAgICAgICAvLyBhbmltYXRpb24gKGZhbHNlfG9iamVjdCkgdHJ1ZeuKlCDsnKDtmqjtlZjsp4Ag7JWK7J2MXHJcbiAgICAgICAgdmFyIF9hbmltYXRpb247XHJcbiAgICAgICAgaWYodHlwZW9mIGFuaW1hdGlvbiA9PT0gJ2Jvb2xlYW4nICYmIGFuaW1hdGlvbiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBfYW5pbWF0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgb3Blbjoge1xyXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdHM6ICdmYWRlSW4nXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICAgIF9hbmltYXRpb24gPSBhbmltYXRpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgYW5pbWF0aW9uOiBfYW5pbWF0aW9uXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gdGFiUG9zaXRpb25cclxuICAgICAgICBpZih0YWJQb3NpdGlvbikge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChvcHRpb25zLCB7dGFiUG9zaXRpb246IHRhYlBvc2l0aW9ufSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjb250ZW50VXJsc1xyXG4gICAgICAgIGlmKGNvbnRlbnRVcmxzKSB7XHJcbiAgICAgICAgICAgICQuZXh0ZW5kKG9wdGlvbnMsIHtjb250ZW50VXJsczogY29udGVudFVybHN9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIG1ldGhvZHNcclxuICAgIHNlbGVjdChpbmRleCkge1xyXG4gICAgICAgIHRoaXMudGFic3RyaXAuc2VsZWN0KGluZGV4KTtcclxuICAgIH1cclxuXHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBldmVudHNcclxuICAgIG9uU2VsZWN0KGUpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdvblNlbGVjdCcpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coZSk7XHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMub25TZWxlY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblNlbGVjdChlKTsgLy8gZS5pdGVtLCBpbmRleCDslYzslYTrgrTshJwg64SY6riw7J6QXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uQWN0aXZhdGUoZSkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ29uQWN0aXZhdGUnKTtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKGUpO1xyXG4gICAgICAgIGlmKHR5cGVvZiB0aGlzLnByb3BzLm9uQWN0aXZhdGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkFjdGl2YXRlKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvblNob3coZSkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coJ29uU2hvdycpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coZSk7XHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMub25TaG93ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25TaG93KGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBvbkNvbnRlbnRMb2FkKGUpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKCdvbkNvbnRlbnRMb2FkJyk7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhlKTtcclxuICAgICAgICBpZih0eXBlb2YgdGhpcy5wcm9wcy5vbkNvbnRlbnRMb2FkID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Db250ZW50TG9hZChlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25FcnJvcihlKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZygnb25FcnJvcicpO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coZSk7XHJcbiAgICAgICAgaWYodHlwZW9mIHRoaXMucHJvcHMub25FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uRXJyb3IoZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiByZW5kZXIgZnVuY3Rpb25cclxuICAgICAqL1xyXG4gICAgcmVuZGVyQ2hpbGRyZW4oKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbixcclxuICAgICAgICAgICAgY291bnQgPSAwO1xyXG5cclxuICAgICAgICByZXR1cm4gUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgaWYoY2hpbGQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XHJcblxyXG4gICAgICAgICAgICAvLyBUYWJzXHJcbiAgICAgICAgICAgIGlmKGNvdW50KysgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBSZWFjdC5DaGlsZHJlbi5tYXAoY2hpbGQucHJvcHMuY2hpbGRyZW4sICh0YWIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGFiID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudCh0YWIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRhYkNvbnRlbnRcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgLy8g7ZWE7IiYIO2VreuqqVxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDxkaXYgaWQ9e3RoaXMuaWR9IGNsYXNzTmFtZT17dGhpcy5wcm9wcy5jbGFzc05hbWV9PlxyXG4gICAgICAgICAgICAgICAge3RoaXMucmVuZGVyQ2hpbGRyZW4oKX1cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG5cclxuVGFiU3RyaXAucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xyXG5UYWJTdHJpcC5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBUYWJTdHJpcDsiLCIvKipcclxuICogVGFicyBjb21wb25lbnRcclxuICpcclxuICogdmVyc2lvbiA8dHQ+JCBWZXJzaW9uOiAxLjAgJDwvdHQ+IGRhdGU6MjAxNi8wOC8wNlxyXG4gKiBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpocmFobkBua2lhLmNvLmtyXCI+QWhuIEh5dW5nLVJvPC9hPlxyXG4gKlxyXG4gKiBleGFtcGxlOlxyXG4gKiA8UHVmLlRhYnMgLz5cclxuICpcclxuICogS2VuZG8gVGFiU3RyaXAg65287J2067iM65+s66as7JeQIOyiheyGjeyggeydtOuLpC5cclxuICovXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XHJcblxyXG4vKiogQ2xhc3MgcmVwcmVzZW50aW5nIGEgVGFicy4gKi9cclxuY2xhc3MgVGFicyBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgIH1cclxuXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgLy8g7ZWE7IiYIO2VreuqqVxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIDx1bD57dGhpcy5wcm9wcy5jaGlsZHJlbn08L3VsPlxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRhYnM7IiwiLyoqXG4gKiBwcy11dGlsIHNlcnZpY2VzXG4gKiBcbiAqIHZlcnNpb24gPHR0PiQgVmVyc2lvbjogMS4wICQ8L3R0PiBkYXRlOjIwMTYvMDMvMDFcbiAqIGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmhyYWhuQG5raWEuY28ua3JcIj5BaG4gSHl1bmctUm88L2E+XG4gKiBcbiAqIGV4YW1wbGU6XG4gKiBhcHAuY29udHJvbGxlcignQ3RybCcsIFsnJHNjb3BlJywgJ3BzVXRpbCcsIGZ1bmN0aW9uKCRzY29wZSwgcHNVdGlsKSB7XG4gKiBcdCAgIHZhciByb290UGF0aCA9IHBzVXRpbC5nZXRSb290UGF0aCgpO1xuICogfV0pO1xuICogXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZ2V0RGF0ZVRvU3RyaW5nKGRhdGUpIHtcblx0dmFyIHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCksXG5cdFx0bW9udGggPSB6ZXJvZmlsbChkYXRlLmdldE1vbnRoKCkgKyAxLCAyKSxcblx0XHRkYXkgPSB6ZXJvZmlsbChkYXRlLmdldERhdGUoKSwgMiksXG5cdFx0aG91cnMgPSAoZGF0ZS5nZXRIb3VycygpIDwgMCkgPyAnMDAnIDogemVyb2ZpbGwoZGF0ZS5nZXRIb3VycygpLCAyKSxcdC8vIGRhdGVyYW5nZXBpY2tlciBob3VycyA57Iuc6rCEIOyYpOuyhO2RnOyLnOuQmOuKlCDrsoTqt7jroZwg7J247ZW0IOu5vOykgOuLpC5cblx0XHRtaW51dGVzID0gemVyb2ZpbGwoZGF0ZS5nZXRNaW51dGVzKCksIDIpLFxuXHRcdHNlY29uZHMgPSB6ZXJvZmlsbChkYXRlLmdldFNlY29uZHMoKSwgMiksXG5cdFx0ZGF0ZVN0cmluZyA9IHllYXIgKyAnLScgKyBtb250aCArICctJyArIGRheSArICcgJyArIGhvdXJzICsgJzonICsgbWludXRlcyArICc6JyArIHNlY29uZHM7XG5cblx0cmV0dXJuIGRhdGVTdHJpbmc7XG59XG5cbmZ1bmN0aW9uIHplcm9maWxsKG4sIGRpZ2l0cykge1xuXHR2YXIgemVybyA9ICcnO1xuXHRuID0gbi50b1N0cmluZygpO1xuXG5cdGlmIChuLmxlbmd0aCA8IGRpZ2l0cykge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGlnaXRzIC0gbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0emVybyArPSAnMCc7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHplcm8gKyBuO1xufVxuXG4vLyBkYXRlOiDquLDspIDsnbwsIGhvdXJzOiDqtaztlZjqs6DsnpDtlZjripQg7J207KCEIOyLnOqwhFxuZnVuY3Rpb24gZ2V0TGFzdERhdGUoZGF0ZSwgaG91cnMpIHtcblx0cmV0dXJuIG5ldyBEYXRlKERhdGUucGFyc2UoZGF0ZSkgLSAxMDAwICogNjAgKiA2MCAqIGhvdXJzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGdldERhdGVUb1N0cmluZzogZ2V0RGF0ZVRvU3RyaW5nLFxuXHRnZXRMYXN0RGF0ZTogZ2V0TGFzdERhdGVcbn07IiwiLyoqXG4gKiBOdW1iZXJVdGlsIHNlcnZpY2VzXG4gKiBcbiAqIHZlcnNpb24gPHR0PiQgVmVyc2lvbjogMS4wICQ8L3R0PiBkYXRlOjIwMTYvMDUvMTlcbiAqIGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmhyYWhuQG5raWEuY28ua3JcIj5BaG4gSHl1bmctUm88L2E+XG4gKiBcbiAqIGV4YW1wbGU6XG4gKiB2YXIgTnVtYmVyVXRpbCA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL051bWJlclV0aWwnKTtcbiAqIE51bWJlclV0aWwuZGlnaXQoKTtcbiAqXG4gKiBQdWYuTnVtYmVyVXRpbC5kaWdpdCgpO1xuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE51bWJlclV0aWwge1xuXHRzdGF0aWMgZGlnaXQoaSkge1xuXHRcdHZhciBkaXNwbGF5VGV4dDtcblx0XHRpZihpPDEwKSB7XG5cdFx0XHRkaXNwbGF5VGV4dCA9ICcwJytpO1xuXHRcdH1lbHNlIHtcblx0XHRcdGRpc3BsYXlUZXh0ID0gaS50b1N0cmluZygpO1xuXHRcdH1cblx0XHRyZXR1cm4gZGlzcGxheVRleHQ7XG5cdH1cbn0iLCIvKipcbiAqIFJlZ0V4cCBzZXJ2aWNlc1xuICogXG4gKiB2ZXJzaW9uIDx0dD4kIFZlcnNpb246IDEuMCAkPC90dD4gZGF0ZToyMDE2LzA1LzIwXG4gKiBhdXRob3IgPGEgaHJlZj1cIm1haWx0bzpocmFobkBua2lhLmNvLmtyXCI+QWhuIEh5dW5nLVJvPC9hPlxuICogXG4gKiBleGFtcGxlOlxuICogdmFyIFJlZ0V4cCA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL1JlZ0V4cCcpO1xuICogUmVnRXhwLmNoZWNrRW1haWwoc3RyVmFsdWUpO1xuICpcbiAqIFB1Zi5SZWdFeHAuY2hlY2tFbWFpbChzdHJWYWx1ZSk7XG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHJlZ0V4cF9FTUFJTCA9IC9bMC05YS16QS1aXVtfMC05YS16QS1aLV0qQFtfMC05YS16QS1aLV0rKFxcLltfMC05YS16QS1aLV0rKXsxLDJ9JC87XG5cbmZ1bmN0aW9uIGNoZWNrRW1haWwoc3RyVmFsdWUpIHtcblx0aWYgKCFzdHJWYWx1ZS5tYXRjaChyZWdFeHBfRU1BSUwpKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0Y2hlY2tFbWFpbDogY2hlY2tFbWFpbFxufTsiLCIvKipcbiAqIFJlc291cmNlIHNlcnZpY2VzXG4gKiBcbiAqIHZlcnNpb24gPHR0PiQgVmVyc2lvbjogMS4wICQ8L3R0PiBkYXRlOjIwMTYvMDYvMDNcbiAqIGF1dGhvciA8YSBocmVmPVwibWFpbHRvOmhyYWhuQG5raWEuY28ua3JcIj5BaG4gSHl1bmctUm88L2E+XG4gKiBcbiAqIGV4YW1wbGU6XG4gKiBQdWYuUmVzb3VyY2UubG9hZFJlc291cmNlKCk7XG4gKiBQdWYuUmVzb3VyY2UuaTE4bihrZXkpO1xuICpcbiAqIOuLpOq1reyWtCDsspjrpqxcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBsb2FkIHByb3BlcnRpZXNcbnZhciBsb2FkUmVzb3VyY2UgPSBmdW5jdGlvbihuYW1lLCBwYXRoLCBtb2RlLCBsYW5ndWFnZSwgY2FsbGJhY2spIHtcblxuXHQkLmkxOG4ucHJvcGVydGllcyh7XG5cdCAgICBuYW1lOiBuYW1lLFxuXHQgICAgcGF0aDogcGF0aCxcblx0ICAgIG1vZGU6IG1vZGUsXG5cdCAgICBsYW5ndWFnZTogbGFuZ3VhZ2UsXG5cdCAgICBjYWxsYmFjazogY2FsbGJhY2tcblx0XHQvKlxuXHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0Ly8gQWNjZXNzaW5nIGEgc2ltcGxlIHZhbHVlIHRocm91Z2ggdGhlIG1hcFxuXHRcdFx0alF1ZXJ5LmkxOG4ucHJvcCgnbXNnX2hlbGxvJyk7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgYSB2YWx1ZSB3aXRoIHBsYWNlaG9sZGVycyB0aHJvdWdoIHRoZSBtYXBcblx0XHRcdGpRdWVyeS5pMThuLnByb3AoJ21zZ19jb21wbGV4JywgJ0pvaG4nKTtcblx0XG5cdFx0XHQvLyBBY2Nlc3NpbmcgYSBzaW1wbGUgdmFsdWUgdGhyb3VnaCBhIEpTIHZhcmlhYmxlXG5cdFx0XHRhbGVydChtc2dfaGVsbG8gKycgJysgbXNnX3dvcmxkKTtcblx0XHRcdC8vIEFjY2Vzc2luZyBhIHZhbHVlIHdpdGggcGxhY2Vob2xkZXJzIHRocm91Z2ggYSBKUyBmdW5jdGlvblxuXHRcdFx0YWxlcnQobXNnX2NvbXBsZXgoJ0pvaG4nKSk7XG5cdFx0XHRhbGVydChtc2dfaGVsbG8pO1xuXHQgICAgfVxuXHQgICAgKi9cblx0fSk7XG59O1xuXG52YXIgaTE4biA9IGZ1bmN0aW9uKGtleSkge1xuXHQvL3ZhciBhcmdzID0gJ1xcJycgKyBrZXkgKyAnXFwnJztcblx0Ly9mb3IgKHZhciBpPTE7IGk8YXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgIC8vICAgYXJncyArPSAnLCBcXCcnICsgYXJndW1lbnRzW2ldICsgJ1xcJyc7XG5cdC8vfVxuXHQvL3JldHVybiBldmFsKCckLmkxOG4ucHJvcCgnICsgYXJncyArICcpJyk7XG5cdHJldHVybiAkLmkxOG4ucHJvcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcblxudmFyIGkxOG5CeUtleSA9IGZ1bmN0aW9uKGtleSkge1xuXHQvL3ZhciBhcmdzID0gJ1xcJycgKyBrZXkgKyAnXFwnJztcblx0Ly9mb3IgKHZhciBpPTE7IGk8YXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdC8vXHRhcmdzICs9ICcsIFxcJycgKyAkLmkxOG4ucHJvcChhcmd1bWVudHNbaV0pICsgJ1xcJyc7XG5cdC8vfVxuXHQvL3JldHVybiBldmFsKCckLmkxOG4ucHJvcCgnICsgYXJncyArICcpJyk7XG5cdHZhciBhcmdzID0gW2tleV07XG5cdGZvciAodmFyIGk9MTsgaTxhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRhcmdzLnB1c2goJC5pMThuLnByb3AoYXJndW1lbnRzW2ldKSk7XG5cdH1cblx0cmV0dXJuICQuaTE4bi5wcm9wLmFwcGx5KHRoaXMsIGFyZ3MpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cdGxvYWRSZXNvdXJjZTogbG9hZFJlc291cmNlLFxuXHRpMThuOiBpMThuLFxuXHRpMThuQnlLZXk6IGkxOG5CeUtleVxufTsiLCIvKipcbiAqIFV0aWwgc2VydmljZXNcbiAqIFxuICogdmVyc2lvbiA8dHQ+JCBWZXJzaW9uOiAxLjAgJDwvdHQ+IGRhdGU6MjAxNi8wMy8wMVxuICogYXV0aG9yIDxhIGhyZWY9XCJtYWlsdG86aHJhaG5AbmtpYS5jby5rclwiPkFobiBIeXVuZy1SbzwvYT5cbiAqIFxuICogZXhhbXBsZTpcbiAqIHZhciBVdGlsID0gcmVxdWlyZSgnLi4vc2VydmljZXMvVXRpbCcpO1xuICogVXRpbC5nZXRVVUlEKCk7XG4gKlxuICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFV0aWwge1xuXHRzdGF0aWMgZ2V0VVVJRCgpIHtcblx0XHRyZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG5cdFx0XHR2YXIgciA9IE1hdGgucmFuZG9tKCkqMTZ8MCwgdiA9IGMgPT0gJ3gnID8gciA6IChyJjB4M3wweDgpO1xuXHRcdFx0cmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuXHRcdH0pO1xuXHR9XG5cblx0c3RhdGljIHVuaXF1ZUlEKCkge1xuXHRcdHJldHVybiAnaWQtJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KTtcblx0fVxuXG5cdHN0YXRpYyBzbGVlcChtaWxsaXNlY29uZHMpIHtcblx0XHR2YXIgc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDFlNzsgaSsrKSB7XG5cdFx0XHRpZiAoKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnQpID4gbWlsbGlzZWNvbmRzKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIOyLnOyeke2OmOydtOyngOuhnCDshKTsoJVcblx0c3RhdGljIHNldFN0YXJ0UGFnZShvYmosIHVybCkge1xuXHRcdG9iai5zdHlsZS5iZWhhdmlvcj0ndXJsKCNkZWZhdWx0I2hvbWVwYWdlKSc7XG5cdFx0Ly9vYmouc2V0SG9tZVBhZ2UoJ2h0dHA6Ly9pbnRlcm5ldC5zY291cnQuZ28ua3IvJyk7XG5cdFx0b2JqLnNldEhvbWVQYWdlKHVybCk7XG5cdH1cblxuXHQvLyDsv6DtgqQg7ISk7KCVXG5cdC8qXG5cdGZ1bmN0aW9uIHNldENvb2tpZShuYW1lLCB2YWx1ZSwgZXhwaXJlcykge1xuXHRcdC8vIGFsZXJ0KG5hbWUgKyBcIiwgXCIgKyB2YWx1ZSArIFwiLCBcIiArIGV4cGlyZXMpO1xuXHRcdGRvY3VtZW50LmNvb2tpZSA9IG5hbWUgKyBcIj1cIiArIGVzY2FwZSh2YWx1ZSkgKyBcIjsgcGF0aD0vOyBleHBpcmVzPVwiICsgZXhwaXJlcy50b0dNVFN0cmluZygpO1xuXHR9XG5cdCovXG5cdHN0YXRpYyBzZXRDb29raWUoY25hbWUsIGN2YWx1ZSwgZXhkYXlzLCBjZG9tYWluKSB7XG5cdFx0dmFyIGQgPSBuZXcgRGF0ZSgpO1xuXHRcdGQuc2V0VGltZShkLmdldFRpbWUoKSArIChleGRheXMqMjQqNjAqNjAqMTAwMCkpO1xuXHRcdHZhciBleHBpcmVzID0gJ2V4cGlyZXM9JyArIGQudG9VVENTdHJpbmcoKTtcblx0XHR2YXIgZG9tYWluO1xuXHRcdGlmKGNkb21haW4pIHtcblx0XHRcdGRvbWFpbiA9ICc7IGRvbWFpbj0nICsgY2RvbWFpbjtcblx0XHR9XG5cdFx0ZG9jdW1lbnQuY29va2llID0gY25hbWUgKyAnPScgKyBlc2NhcGUoY3ZhbHVlKSArICc7IHBhdGg9LzsgJyArIGV4cGlyZXMgKyBkb21haW47XG5cdH1cblxuXHQvLyDsv6DtgqQg6rCA7KC47Jik6riwXG5cdC8qXG5cdGZ1bmN0aW9uIGdldENvb2tpZShOYW1lKSB7XG5cdFx0dmFyIHNlYXJjaCA9IE5hbWUgKyBcIj1cIlxuXHRcdGlmIChkb2N1bWVudC5jb29raWUubGVuZ3RoID4gMCkgeyAvLyDsv6DtgqTqsIAg7ISk7KCV65CY7Ja0IOyeiOuLpOuptFxuXHRcdFx0b2Zmc2V0ID0gZG9jdW1lbnQuY29va2llLmluZGV4T2Yoc2VhcmNoKVxuXHRcdFx0aWYgKG9mZnNldCAhPSAtMSkgeyAvLyDsv6DtgqTqsIAg7KG07J6s7ZWY66m0XG5cdFx0XHRcdG9mZnNldCArPSBzZWFyY2gubGVuZ3RoXG5cdFx0XHRcdC8vIHNldCBpbmRleCBvZiBiZWdpbm5pbmcgb2YgdmFsdWVcblx0XHRcdFx0ZW5kID0gZG9jdW1lbnQuY29va2llLmluZGV4T2YoXCI7XCIsIG9mZnNldClcblx0XHRcdFx0Ly8g7L+g7YKkIOqwkuydmCDrp4jsp4Drp4kg7JyE7LmYIOyduOuNseyKpCDrsojtmLgg7ISk7KCVXG5cdFx0XHRcdGlmIChlbmQgPT0gLTEpXG5cdFx0XHRcdFx0ZW5kID0gZG9jdW1lbnQuY29va2llLmxlbmd0aFxuXHRcdFx0XHRyZXR1cm4gdW5lc2NhcGUoZG9jdW1lbnQuY29va2llLnN1YnN0cmluZyhvZmZzZXQsIGVuZCkpXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBcIlwiO1xuXHR9XG5cdCovXG5cdHN0YXRpYyBnZXRDb29raWUoY25hbWUpIHtcblx0XHR2YXIgbmFtZSA9IGNuYW1lICsgJz0nO1xuXHRcdHZhciBjYSA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPGNhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYyA9IGNhW2ldO1xuXHRcdFx0d2hpbGUgKGMuY2hhckF0KDApPT0nICcpIHtcblx0XHRcdFx0YyA9IGMuc3Vic3RyaW5nKDEpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGMuaW5kZXhPZihuYW1lKSA9PSAwKSB7XG5cdFx0XHRcdHJldHVybiB1bmVzY2FwZShjLnN1YnN0cmluZyhuYW1lLmxlbmd0aCwgYy5sZW5ndGgpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuICcnO1xuXHR9XG59Il19
